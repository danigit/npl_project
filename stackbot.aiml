<?xml version="1.0" ?>
<aiml>
	<category>
		
		<pattern>^ remove repeated elements ^ arraylist </pattern>
		<template>
			
			If you don't want duplicates in a Collection, you should consider why you're using a Collection that allows duplicates.
			<delay>2</delay>
			The easiest way to remove repeated elements is to add the contents to a Set (which will not allow duplicates) and then add the Set back to the ArrayList:

Set&lt;String&gt; set = new HashSet&lt;&gt;(yourList);
yourList.clear();
yourList.addAll(set);



			<delay>2</delay>
			Of course, this destroys the ordering of the elements in the ArrayList.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ int array ^ see ^ empty ^ element </pattern>
		<template>
			
			Elements in primitive arrays can't be empty.  
			<delay>2</delay>
			They'll always get initialized to something (usually 0 for int arrays, but depends on how you declare the array).


			<delay>2</delay>
			If you declare the array like so (for example):

int [] myArray ;
myArray = new int[7] ;


then all of the elements will default to 0.


			<delay>2</delay>
			An alternative syntax for declaring arrays is

int[] myArray = { 12, 7, 32, 15, 113, 0, 7 };


where the initial values for an array (of size seven in this case) are given in the curly braces {}.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java equivalent ^ java arrays ^ ienumerable ^ generics ^ c </pattern>
		<template>
			
			Iterable&lt;String&gt; is the equivalent of IEnumerable&lt;string&gt;.


			<delay>2</delay>
			It would be an odditity in the type system if arrays implemented Iterable.
			<delay>2</delay>
			String[] is an instance of Object[], but Iterable&lt;String&gt; is not an Iterable&lt;Object&gt;.
			<delay>2</delay>
			Classes and interfaces cannot multiply implement the same generic interface with different generic arguments.


			<delay>2</delay>
			String[] will work just like an Iterable in the enhanced for loop.


			<delay>2</delay>
			Iterable&lt;String&gt;0 can easily be turned into an Iterable&lt;String&gt;1:

Iterable&lt;String&gt;2

Prefer collections over arrays (for non-primitives anyway).
			<delay>2</delay>
			Arrays of reference types are a bit odd, and are rarely needed since Java 1.5.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ variable length ^ statically typed ^ java array ^ list </pattern>
		<template>
			
			If you use generics (java 5), you can avoid all casting with

 List&lt;String&gt; myList = new ArrayList&lt;String&gt;();
 myList.add(" a test");
 String temp = myList.get(0);


Unless I am missing something in your question that should cover both needs.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java sort string array ^ file names ^ extension </pattern>
		<template>
			
			Arrays.sort(filenames, new Comparator&lt;String&gt;() {
    @Override
    public int compare(String s1, String s2) {
        // the +1 is to avoid including the '.' in the extension and to avoid exceptions
        // EDIT:
        // We first need to make sure that either both files or neither file
        // has an extension (otherwise we'll end up comparing the extension of one
        // to the start of the other, or else throwing an exception)
        final int s1Dot = s1.lastIndexOf('.');
        final int s2Dot = s2.lastIndexOf('.');
        if ((s1Dot == -1) == (s2Dot == -1)) { // both or neither
            s1 = s1.substring(s1Dot + 1);
            s2 = s2.substring(s2Dot + 1);
            return s1.compareTo(s2);
        } else if (s1Dot == -1) { // only s2 has an extension, so s1 goes first
            return -1;
        } else { // only s1 has an extension, so s1 goes second
            return 1;
        }
    }
});



			<delay>2</delay>
			For completeness: java.util.Arrays and java.util.Comparator.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ 2d arrays use ^ 1d arrays ^ resources ^ java </pattern>
		<template>
			
			In the first case you have one array object pointing to fifty array objects holding 8 int's.

			<delay>2</delay>
			So 1 + 50 array objects + fifty pointers in the first array object.


			<delay>2</delay>
			In the second case you have one array object pointing to 8 array objects holding 50 int's.

			<delay>2</delay>
			So 1 + 8 array objects + eight pointers in the first array object.  
			<delay>2</delay>
			Holding the int's is a wash. 


			<delay>2</delay>
			There is not a good way to evaluate CPU usage for this.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ removing ^ java ^ element ^ array </pattern>
		<template>
			
			You could use commons lang's ArrayUtils.


			<delay>2</delay>
			array = ArrayUtils.removeElement(array, element)


commons.apache.org library:Javadocs

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ dimensional array ^ bidimensional array ^ viceversa ^ numbers ^ java ^ converting </pattern>
		<template>
			
			Do you mean something like this?


			<delay>2</delay>
			import java.util.*; 

public class Test {
    public static void main(String[] args) {
        String[][] data = new String[][] {
            { "Foo", "Bar" },
            { "A", "B" }
        };

        String[] flattened = flatten(data);

        for (String x : flattened) {
            System.out.println(x);
        }
    }

    public static &lt;T&gt; T[] flatten(T[][] source) {
        int size = 0;
        for (int i=0; i &lt; source.length; i++) {
            size += source[i].length;
        }

        // Use the first subarray to create the new big one
        T[] ret = Arrays.copyOf(source[0], size);
        int index = source[0].length;
        for (int i=1; i &lt; source.length; i++) {
            System.arraycopy(source[i], 0, ret, index, source[i].length);
            index += source[i].length;
        }
        return ret;
    }

}



			<delay>2</delay>
			If you want it for primitive types, you'll have to write an overload for each primitive type, but you can use new int[size] instead of Arrays.copyOf at that point.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ last value ^ get ^ arraylist </pattern>
		<template>
			
			The following is part of the List interface (which ArrayList implements):

E e = list.get(list.size() - 1);


E is the element type.
			<delay>2</delay>
			If the list is empty, get throws an IndexOutOfBoundsException.
			<delay>2</delay>
			You can find the whole API documentation here.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ direct access ^ java array ^ array ^ component </pattern>
		<template>
			
			yes.
			<delay>2</delay>
			You can do that, assuming args[1]
			<delay>2</delay>
			exists, otherwise you'll get an ArrayIndexOutOfBoundsException.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ check whether ^ another arraylist ^ arraylist ^ elements ^ contained </pattern>
		<template>
			
			Use Collection.containsAll():

boolean isSubset = listA.containsAll(listB);


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java iterate bits ^ byte array </pattern>
		<template>
			
			You'd have to write your own implementation of Iterable&lt;Boolean&gt; which took an array of bytes, and then created Iterator&lt;Boolean&gt; values which remembered the current index into the byte array and the current index within the current byte.
			<delay>2</delay>
			Then a utility method like this would come in handy:

private static Boolean isBitSet(byte b, int bit)
{
    return (b &amp; (1 &lt;&lt; bit)) != 0;
}


(where bit ranges from 0 to 7).
			<delay>2</delay>
			Each time next() was called you'd have to increment your bit index within the current byte, and increment the byte index within byte array if you reached "the 9th bit".


			<delay>2</delay>
			It's not really hard - but a bit of a pain.
			<delay>2</delay>
			Let me know if you'd like a sample implementation...

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ remove elements ^ linkedlist ^ efficient ^ arraylist </pattern>
		<template>
			
			It is "easier" (that is, more efficient) to remove them from a LinkedList, because removal from an ArrayList requires moving all subsequent elements to a new position in the list&mdash;all subsequent elements of the array must be assigned a new value.
			<delay>2</delay>
			With a linked list, only one pointer (or two, with a doubly-linked list) must be re-assigned.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ double type array use ^ j2me </pattern>
		<template>
			
			make sure the handset that you have provisioned to is capable of cldc 1.1 which is needed for floating point numbers, you can change how the emulator behaves in its settings to represent a cldc 1.0 device if that is what you are building for

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ convert hashmap ^ java ^ array </pattern>
		<template>
			
			hashMap.keySet().toArray(); // returns an array of keys
hashMap.values().toArray(); // returns an array of values




Edit


			<delay>2</delay>
			It should be noted that the ordering of both arrays may not be the same,
See oxbow_lakes answer for a better approach for iteration when the pair key/values are needed.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ using generics ^ arrays </pattern>
		<template>
			
			Arrays are already basic objects types, that is to say they're not a class that describes a collection of other objects like ArrayList or HashMap.


			<delay>2</delay>
			You cannot have an array of generified types either.
			<delay>2</delay>
			The following is illegal in Java:

List&lt;String&gt;[] lists = new List&lt;String&gt;[ 10 ];



			<delay>2</delay>
			This is because arrays must be typed properly by the compiler, and since Java's generics are subject to type erasure you cannot satisfy the compiler this way.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java ^ initialize ^ declare ^ array </pattern>
		<template>
			
			You can either use array declaration or array literal (but only when you declare and affect the variable right away, array literals cannot be used for re-assigning an array). 


			<delay>2</delay>
			For primitive types: 

int[] myIntArray = new int[3];
int[] myIntArray = {1, 2, 3};
int[] myIntArray = new int[]{1, 2, 3};

// Since Java 8. Doc of IntStream: https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html

int [] myIntArray = IntStream.range(0, 100).toArray(); // From 0 to 99
int [] myIntArray = IntStream.rangeClosed(0, 100).toArray(); // From 0 to 100
int [] myIntArray = IntStream.of(12,25,36,85,28,96,47).toArray(); // The order is preserved.
int [] myIntArray = IntStream.of(12,25,36,85,28,96,47).sorted().toArray(); // Sort 



			<delay>2</delay>
			For classes, for example String
			<delay>2</delay>
			, it's the same:

String[] myStringArray = new String[3];
String[] myStringArray = {"a", "b", "c"};
String[] myStringArray = new String[]{"a", "b", "c"};



			<delay>2</delay>
			The third way of initializing is useful when you declare the array first and then initialize it.
			<delay>2</delay>
			The cast is necessary here.


			<delay>2</delay>
			String[] myStringArray;
myStringArray = new String[]{"a", "b", "c"};


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ convert inputstream ^ byte array ^ java </pattern>
		<template>
			
			You can use Apache Commons IO to handle this and similar tasks.


			<delay>2</delay>
			The IOUtils type has a static method to read an InputStream and return a byte[].


			<delay>2</delay>
			InputStream is;
byte[] bytes = IOUtils.toByteArray(is);


Internally this creates a ByteArrayOutputStream and copies the bytes to the output, then calls toByteArray().
			<delay>2</delay>
			It handles large files by copying the bytes in blocks of 4KiB.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ arraylist preferable ^ java ^ array </pattern>
		<template>
			
			Some differences:


Arrays are immutable in their size, you cannot easly remove and element and remove the hole whereas using an ArrayList is
			<delay>2</delay>
			straightforward
Arrays are fast (handled directly by the JVM as special objects) than an ArrayList and requires less memory 

			<delay>2</delay>
			Arrays have a nice syntax for accessing elements (e.g. a[i] vs a.get(i))

			<delay>2</delay>
			Arrays don't play well with generics (e.g. you cannot create a generic array)

			<delay>2</delay>
			Arrays cannot be easly wrapped as ArrayList (e.g. Collections utils like checkedList, synchronizedList and unmodifiableList)
declaring the ArrayList as List you can easly swap implementation with a LinkedList when you need; this imho is the best advantage over plain arrays 

			<delay>2</delay>
			Array's toString, a[i]0 and
			<delay>2</delay>
			a[i]1 are weird and error-prone, you must use Arrays class utilities


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ populate ^ jcombobox ^ arraylist </pattern>
		<template>
			
			Use the toArray() method of the ArrayList class and pass it into the constructor of the JComboBox

See the JavaDoc and tutorial for more info.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ primitive type ^ copy array ^ non ^ java </pattern>
		<template>
			
			System.arraycopy


(which gives you the ability to copy arbitrary portions of an array via the offset and length parameters).
			<delay>2</delay>
			Or

java.util.Arrays.copyOf


Which was added in JDK 6 and is a generic method so it can be used:

Integer[] is = new Integer[] { 4, 6 }
Integer[] copy = Arrays.copyOf(is, is.length);



			<delay>2</delay>
			Or it can narrow a type:

Number[] is = new Number[]{4, 5};
Integer[] copy = Arrays.copyOf(is, is.length, Integer[].class);


Note that you can also use the clone method on an array:

Number[] other = is.clone();


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ counting distinct integers ^ java </pattern>
		<template>
			
			Set&lt;Integer&gt; s = new HashSet&lt;Integer&gt;();
for (int i : a) s.add(i);
int distinctCount = s.size();


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ arrays like php ^ join ()? ^ java ^ function </pattern>
		<template>
			
			Starting from Java8 it is possible to use String.join().


			<delay>2</delay>
			String.join(", ", new String[]{"Hello", "World", "!"})


Generates:

Hello, World, !



			<delay>2</delay>
			Otherwise, Apache Commons Lang has a StringUtils class which has a join function which will join arrays together to make a String.


			<delay>2</delay>
			For example:

StringUtils.join(new String[] {"Hello", "World", "!"}, ", ")


Generates the following String:

Hello, World, !


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ byte [] ^ list ^ creating </pattern>
		<template>
			
			byte[] byteArray = new byte[byteList.size()];
for (int index = 0; index &lt; byteList.size(); index++) {
    byteArray[index] = byteList.get(index);
}



			<delay>2</delay>
			You may not like it but that’s about the only way to create a Genuine™ Array® of byte.


			<delay>2</delay>
			As pointed out in the comments, there are other ways.
			<delay>2</delay>
			However, none of those ways gets around a) creating an array and b) assigning each element.
			<delay>2</delay>
			This one uses an iterator.


			<delay>2</delay>
			byte[] byteArray = new byte[byteList.size()];
int index = 0;
for (byte b : byteList) {
    byteArray[index++] = b;
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ use ^ list ^ java ^ array </pattern>
		<template>
			
			I see the question as being the opposite- 


			<delay>2</delay>
			When should you use an Array over a List? 


			<delay>2</delay>
			Only you have a specific reason to do so (eg: Project Constraints, Memory Concerns (not really a good reason), etc.)


			<delay>2</delay>
			Lists are much easier to use (imo), and have much more functionality. 


			<delay>2</delay>
			Note: You should also consider whether or not something like a Set, or another datastructure is a better fit than a List for what you are trying to do.


			<delay>2</delay>
			Each datastructure, and implmentation, has different pros/cons.
			<delay>2</delay>
			Pick the ones that excel at the things that you need to do.


			<delay>2</delay>
			If you need get() to be O(1) for any item?
			<delay>2</delay>
			Likely use an ArrayList, Need O(1) insert()?
			<delay>2</delay>
			Possibly a Linked List.
			<delay>2</delay>
			Need O(1) contains()?
			<delay>2</delay>
			Possibly a Hashset.


			<delay>2</delay>
			TLDR:
			<delay>2</delay>
			Each data structure is good at some things, and bad at others.
			<delay>2</delay>
			Look at your objectives and choose the data structure that best fits the given problem.


			<delay>2</delay>
			Edit: 


  One thing not noted is that you're
  better off declaring the variable as
  its interface (i.e. List or Queue)
  rather than its implementing class.
  
			<delay>2</delay>
			This way, you can change the
  implementation at some later date
  without changing anything else in the
  code. 
  
  
			<delay>2</delay>
			As an example: 


List&lt;String&gt; myList = new ArrayList&lt;String&gt;(); 



  vs


List&lt;String&gt; myList = new LinkedList&lt;String&gt;(); 



  Note that myList is a List in both examples.
  
			<delay>2</delay>
			--R.
			<delay>2</delay>
			Bemrose


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ final arraylist declaration </pattern>
		<template>
			
			Final means that the variable pointing to the arraylist can't change.
			<delay>2</delay>
			But that does not mean that you can not call any method of the object, so you can perform insert, search and any other operation to the object

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ one single array ^ combine several arrays ^ best way </pattern>
		<template>
			
			
Create an array of the right size (by going through and summing the lengths of all the source arrays)

			<delay>2</delay>
			Repeatedly call System.arraycopy to copy one source array at a time into the target array, updating the place where you copy it to on each iteration.



			<delay>2</delay>
			So something like:

public static double[] Combine(double[][] arrays)
{
    int totalLength = 0;
    for (double[] source : arrays)
    {
        totalLength += source.length;
    }
    double[] ret = new double[totalLength];
    int index = 0;
    for (double[] source : arrays)
    {
        System.arraycopy(source, 0, ret, index, source.length);
        index += source.length;
    }
    return ret;
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ 2d array ^ list ^ java </pattern>
		<template>
			
			e.g. or what do you mean

int[][] a2d = new int[15][15];
int[][] b2d = new int[10][10];
List&lt;int[][]&gt; list2d = new ArrayList&lt;int[][]&gt;(10);
list2d.add(a2d);
list2d.add(b2d);


or do you mean you have a Set&lt;int[][]&gt;
			<delay>2</delay>
			then you can simply do what tpierzina suggested

List&lt;int[][]&gt; list2d = new ArrayList&lt;int[][]&gt;();
list2d.addAll(nameOfYourSetVariable);


or

List&lt;int[][]&gt; list2d = new ArrayList&lt;int[][]&gt;(nameOfYourSetVariable);


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ dimension length array reflection java ^ multi </pattern>
		<template>
			
			There is no such thing as "length" for multi-dimensional array; it may not be rectangular.
			<delay>2</delay>
			I'm guessing you're talking about the number of dimensions.
			<delay>2</delay>
			You need to descend into it iteratively and count.


			<delay>2</delay>
			public int getDimensionCount(Object array) {
  int count = 0;
  Class arrayClass = array.getClass();
  while ( arrayClass.isArray() ) {
    count++;
    arrayClass = arrayClass.getComponentType();
  }
  return count;
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java ^ dates ^ array </pattern>
		<template>
			
			The same way you do for String  and Int , you just place different types inside: 


			<delay>2</delay>
			Date [] dates = {
    new Date(), 
    new Date()
 };


Declared an array of size two with two dates.


			<delay>2</delay>
			You can also initialize with null values:

 Date [] dates = new Date[2];


Or add more significant values:

 Date [] dates = {
    getDateFromString("25/11/2009"), 
    getDateFromString("24/12/2009")
 };

.... 
public Date getDateFromString( String s ) {
    Date result = ...// parse the string set the value etc. 
    return result;
}


EDIT


  ...
			<delay>2</delay>
			but is there anyway you can finish up what you were doing in the getDateFromString method?



			<delay>2</delay>
			Sure, I didn't initially because my point was to show, that you could put anything that is of type "Date" there. 


			<delay>2</delay>
			You just have to use the SimpleDateFormate.parse() method ( inherited from DateFormat class ) 

  simpleDateFormatInstance.parse( "24/12/2009" ); // returns christmas 2009.



			<delay>2</delay>
			Here's a complete working sample: 

import java.text.SimpleDateFormat;
import java.text.ParseException;
import java.util.Date;
import static java.lang.System.out;

public class DateArrayTest {

    private static final SimpleDateFormat dateFormat 
                   = new SimpleDateFormat("dd/MM/yyyy");
    private static final Date invalidDate = new Date(0);


    // test creating a date from a string.
    public static void main( String [] args ) { 
        Date [] randomDates = {
            fromString("01/01/2010"), // new year
            fromString("16/09/2010"), // 200 yrs Mex indepence 
            fromString("21/03/2010"), // uhhmm next spring?
            fromString("this/should/fail"), // invalid date.
        };

        for( Date date: randomDates ) {
            print( date );
        }
    }

    /**
     * Creates a date from the given string spec. 
     * The date format must be dd/MM/yyyy ie. 
     * 24 december 2009 would be: 24/12/2009
     * @return invalidDate if the format is invalid.
     */
    private static final Date fromString( String spec ) {
        try {
            return dateFormat.parse( spec );
        } catch( ParseException dfe ) {
            return invalidDate;
        }
    }
    private static final void print( Date date ) {
        if( date == invalidDate ) {
            out.println("Invalid date");
        } else {
            out.println( dateFormat.format( date ) );
        }
    }
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ find odd elements ^ two arrays </pattern>
		<template>
			
			    int[] longArray = { 1, 3, 2 };
    int[] shortArray = { 1, 2 };

    //Check which array is longer, if b longer than a then swap

    for (int x:longArray){
        set.add(x);
    }
    for (int x:shortArray){
        if (set.contains(x))
           set.remove(x);
    }
    //odd numbers
    for (Object i:set.toArray())
        System.out.println(i+",");



			<delay>2</delay>
			I put two answers for the voting, the previous is nested loops and might be slow for very long arrays.
			<delay>2</delay>
			In the next solution some might dont prefer the TreeSet.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ specific reasons ^ arrays objects ^ java </pattern>
		<template>
			
			Because the Java Language Specification says so :) 


  In the Java programming language arrays are objects (§4.3.1), are dynamically created, and may be assigned to variables of type Object (§4.3.2).
			<delay>2</delay>
			All methods of class Object may be invoked on an array.



			<delay>2</delay>
			So, unlike C++, Java provides true arrays as first-class objects: 



			<delay>2</delay>
			There is a length member. 

			<delay>2</delay>
			There is a clone() method which overrides the method of the same name in class Object.

			<delay>2</delay>
			Plus all the members of the class Object.

			<delay>2</delay>
			An exception is thrown if you attempt to access an array out of bounds.

			<delay>2</delay>
			Arrays are instanciated in dynamic memory.


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java arrays </pattern>
		<template>
			
			Arrays are "special" in Java - they don't implement any interfaces, which means they can't implement the collection interfaces.
			<delay>2</delay>
			They're collections in "natural language" terms, and you can use the enhanced for loop over them - but if you want to use an array within the collection API, you'll need something like Arrays.asList which wraps an array with the List&lt;T&gt; interface.
			<delay>2</delay>
			(The result is only a view on the array - changes to the array are visible through the list, and vice versa.)


			<delay>2</delay>
			(This is in contrast to .NET, where T[] implements IList&lt;T&gt; etc.)

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ value ^ split ^ java ^ array </pattern>
		<template>
			
			String [] splits = string.split("")


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ convert hash map ^ 2d array </pattern>
		<template>
			
			HashMap map = new HashMap();
Object[][] arr = new Object[map.size()][2];
Set entries = map.entrySet();
Iterator entriesIterator = entries.iterator();

int i = 0;
while(entriesIterator.hasNext()){

    Map.Entry mapping = (Map.Entry) entriesIterator.next();

    arr[i][0] = mapping.getKey();
    arr[i][1] = mapping.getValue();

    i++;
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ generate random number ^ array </pattern>
		<template>
			
			import java.util.Random;

...

Random random = new Random();
System.out.println(n[random.nextInt(n.length)]);


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java arraylist middle </pattern>
		<template>
			
			If you have N items, the middle item is usually defined as item at index N/2 (0-based).


			<delay>2</delay>
			10 items
0,1,2,3,4,5,6,7,8,9
          |
          5

13 items
0,1,2,3,4,5,6,7,8,9,0,1,2
            |
            6


Generally, if you need to find the middle of items between index low (inclusive) and high (exclusive), it's mathematically int mid = (low + high) / 2.
			<delay>2</delay>
			But due to arithmetic overflow in limited-precision integer, the proper formula is int mid = (low + high) &gt;&gt;&gt; 1;

See also


Google Research Blog post by Josh Bloch



			<delay>2</delay>
			Extra,
			<delay>2</delay>
			Extra - Read All About It
			<delay>2</delay>
			: Nearly All Binary Searches and Mergesorts are Broken



			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ scanner input ^ array ... ^ put ^ numbers ^ example ^ couple </pattern>
		<template>
			
			You could try something like this:

public static void main (String[] args)
{
    Scanner input = new Scanner(System.in);
    double[] numbers = new double[5];

    for (int i = 0; i &lt; numbers.length; i++)
    {
        System.out.println("Please enter number");
        numbers[i] = input.nextDouble();
    }
}



			<delay>2</delay>
			It seems pretty basic stuff unless I am misunderstanding you

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ get hashtable values ^ arraylist </pattern>
		<template>
			
			Use the ArrayList constructor that takes a collection.


			<delay>2</delay>
			ArrayList&lt;Word&gt; arr = new ArrayList&lt;Word&gt;(hw.values());



			<delay>2</delay>
			Then every value that was in the HashTable will be in the new ArrayList.


			<delay>2</delay>
			You can find documentation about the constructor in the javadocs.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ free memory ^ byte array ^ java </pattern>
		<template>
			
			Stop referencing it.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ maximum size ^ java arrays </pattern>
		<template>
			
			Haven't seen the right answer, even though it's very easy to test.


			<delay>2</delay>
			In a recent HotSpot VM, the correct answer is Integer.MAX_VALUE - 5.  
			<delay>2</delay>
			Once you go beyond that:

public class Foo {
  public static void main(String[] args) {
    Object[] array = new Object[Integer.MAX_VALUE - 4];
  }
}



			<delay>2</delay>
			You get:

Exception in thread "main" java.lang.OutOfMemoryError:
  Requested array size exceeds VM limit


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ http get ^ send ^ array </pattern>
		<template>
			
			I know this post is really old, but I have to reply because although BalusC's answer is marked as correct, it's not completely correct.


			<delay>2</delay>
			You have to write the query adding "[]" to foo like this:

foo[]=val1&amp;foo[]=val2&amp;foo[]=val3


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java array sorting </pattern>
		<template>
			
			Here is a nice selection including code examples for the various ways to sort arrays and/or collections: Rosetta Code

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java ^ finding ^ element ^ array </pattern>
		<template>
			
			There is a contains method for lists, so you should be able to do:


			<delay>2</delay>
			Arrays.asList(yourArray).contains(yourObject);


Warning:
			<delay>2</delay>
			this might not do what you (or I) expect, see Tom's comment below. 

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ smaller parts ^ divide array </pattern>
		<template>
			
			You can use the method Arrays.copyOfRange(original, from, to)

 public static byte[][] divideArray(byte[] source, int chunksize) {


        byte[][] ret = new byte[(int)Math.ceil(source.length / (double)chunksize)][chunksize];

        int start = 0;

        for(int i = 0; i &lt; ret.length; i++) {
            ret[i] = Arrays.copyOfRange(source,start, start + chunksize);
            start += chunksize ;
        }

        return ret;
    }



			<delay>2</delay>
			Or You can use as Max suggested the System.arraycopy

public static byte[][] divideArray(byte[] source, int chunksize) {


        byte[][] ret = new byte[(int)Math.ceil(source.length / (double)chunksize)][chunksize];

        int start = 0;

        for(int i = 0; i &lt; ret.length; i++) {
            if(start + chunksize &gt; source.length) {
                System.arraycopy(source, start, ret[i], 0, source.length - start);
            } else {
                System.arraycopy(source, start, ret[i], 0, chunksize);
            }
            start += chunksize ;
        }


        return ret;
    }


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java vector ^ arraylist </pattern>
		<template>
			
			Yup - just use the constructor which takes a collection as its parameter:

Vector&lt;String&gt; vector = new Vector&lt;String&gt;();
// (... Populate vector here...)
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(vector);


Note that it only does a shallow copy.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ arraylist work </pattern>
		<template>
			
			Internally an ArrayList uses an Object[].


			<delay>2</delay>
			As you add items to an ArrayList, the list checks to see if the backing array has room left.  
			<delay>2</delay>
			If there is room, the new item is just added at the next empty space.  
			<delay>2</delay>
			If there is not room, a new, larger, array is created, and the old array is copied into the new one.


			<delay>2</delay>
			Now, there is more room left, and the new element is added in the next empty space.


			<delay>2</delay>
			Since people really like the source code:

/**
 * The array buffer into which the elements of the ArrayList are stored.
 * The capacity of the ArrayList is the length of this array buffer.
 */
private transient Object[] elementData;


Straight out of the JDK.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ initialized java array go onto stack ^ heap </pattern>
		<template>
			
			You can think of it as always going on the heap.


			<delay>2</delay>
			I believe some smart VMs are able to stack-allocate objects if they can detect it's safe - but conceptually it's on the heap.
			<delay>2</delay>
			In particular, all array types are reference types (even if the element type is primitive), so the array variable (which is on the stack) is just a reference to an object, and objects normally go on the heap.


			<delay>2</delay>
			In particular, imagine a small change:

byte[] someMethod() { 
    byte[] array = { 0, 0 };
    return array;
}



			<delay>2</delay>
			If the array were allocated on the stack, what would the returned reference have to refer to?

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ create singleton array ^ best way </pattern>
		<template>
			
			Object [] singleton = { new SomeObject() };


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ first element ^ best way ^ remove ^ array </pattern>
		<template>
			
			The size of arrays in Java cannot be changed.  
			<delay>2</delay>
			So, technically you cannot remove any elements from the array.


			<delay>2</delay>
			One way to simulate removing an element from the array is to create a new, smaller array, and then copy all of the elements from the original array into the new, smaller array.


			<delay>2</delay>
			String[] yourArray = Arrays.copyOfRange(oldArr, 1, oldArr.length);



			<delay>2</delay>
			However, I would not suggest the above method.  
			<delay>2</delay>
			You should really be using a List&lt;String&gt;.  
			<delay>2</delay>
			Lists allow you to add and remove items from any index.  
			<delay>2</delay>
			That would look similar to the following:

List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // or LinkedList&lt;String&gt;();
list.add("Stuff");
// add lots of stuff
list.remove(0); // removes the first item


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ prints objects ^ write ^ method ^ java ^ array </pattern>
		<template>
			
			There are several useful toString() and deepToString() methods in java.util.Arrays class.


			<delay>2</delay>
			String[] strings = { "foo", "bar", "waa" };
System.out.println(Arrays.toString(strings)); // [foo, bar, waa]


An alternative is to just loop over them yourself and print each item separately.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java ^ assigning ^ arraylist ^ array </pattern>
		<template>
			
			You can use Arrays.asList():

Type[] anArray = ...
ArrayList&lt;Type&gt; aList = new ArrayList&lt;Type&gt;(Arrays.asList(anArray));


or alternatively, Collections.addAll():

ArrayList&lt;Type&gt; aList = new ArrayList&lt;Type&gt;();
Collections.addAll(theList, anArray); 


Note that you aren't technically assigning an array to a List (well, you can't do that), but I think this is the end result you are looking for.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ much data ^ maximum ^ list ^ hold </pattern>
		<template>
			
			It depends on the List implementation.
			<delay>2</delay>
			Since you index arrays with ints, an ArrayList can't hold more than Integer.MAX_VALUE elements.
			<delay>2</delay>
			A LinkedList isn't limited in the same way, though, and can contain any amount of elements.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ 2d array question java </pattern>
		<template>
			
			arr.length 


will be the number of rows

arr[x].length


will be the number of columns in row x.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ string array ^ return ^ possible </pattern>
		<template>
			
			Yes, but in Java the type is String[], not string[].
			<delay>2</delay>
			The case is important.


			<delay>2</delay>
			For example a method could look something like this:

public String[] foo() {
    // ...
}



			<delay>2</delay>
			Here is a complete example:

public class Program
{
    public static void main(String[] args) {
        Program program = new Program();
        String[] greeting = program.getGreeting();
        for (String word: greeting) {
            System.out.println(word);
        }
    }

    public String[] getGreeting() {
        return new String[] { "hello", "world" };
    }
}


Result:


hello
world



			<delay>2</delay>
			ideone

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java scanner () ^ read ^ array </pattern>
		<template>
			
			There is nothing built in, but you could certainly join all of the elements in your array and pass the resulting string into the Scanner constructor.


			<delay>2</delay>
			A solution with better performance but a greater time investment is to implement Readable by wrapping your array, and keeping track of the current element in the array and the current position in that element's string representation.
			<delay>2</delay>
			You can then fill the buffer with data from the backing array as the Scanner reads from your Readable object.
			<delay>2</delay>
			This approach lets you lazily stream data from your array into the Scanner, but at the cost of requiring you to write some code.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ efficient array elements un ^ ordering ^ java </pattern>
		<template>
			
			I think you want Collections.shuffle(List)?
			<delay>2</delay>
			If not that, you will need to give us more details about what you're trying to do.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ multi dimensional ^ java array </pattern>
		<template>
			
			Here you go

char[] chars = ("01234567890123456789012345678901234567890123456789" + 
                "01234567890123456789012345678901234567890123456789")
                .toCharArray();

char[][] char2D = new char[10][10];

for (int i = 0; i &lt; 100; i++)
    char2D[i / 10][i % 10] = chars[i];



			<delay>2</delay>
			Now the this code...

System.out.println(Arrays.deepToString(char2D).replaceAll("],","],\n"));


...prints the following

[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ objects ^ creating ^ arraylist </pattern>
		<template>
			
			ArrayList&lt;Matrices&gt; list = new ArrayList&lt;Matrices&gt;();
list.add( new Matrices(1,1,10) );
list.add( new Matrices(1,2,20) );


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ string []' ^ java ^ converting ^ arraylist </pattern>
		<template>
			
			List&lt;String&gt; list = ..;
String[] array = list.toArray(new String[0]);



			<delay>2</delay>
			For example:

List&lt;String&gt; list = new ArrayList&lt;String&gt;();
//add some stuff
list.add("android");
list.add("apple");
String[] stringArray = list.toArray(new String[0]);


The toArray() method without passing any argument returns Object[].
			<delay>2</delay>
			So you have to pass an array as an argument, which will be filled with the data from the list, and returned.
			<delay>2</delay>
			You can pass an empty array as well, but you can also pass an array with the desired size.


			<delay>2</delay>
			Important update: Originally the code above used new String[list.size()].
			<delay>2</delay>
			However, this blogpost reveals that due to JVM optimizations, using new String[0] is better now.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ single arraylist ^ arraylist ^ group ^ add </pattern>
		<template>
			
			I hope I understand your question correctly.


			<delay>2</delay>
			An ArrayList is a list of Object types.
			<delay>2</delay>
			If you wish to add an ArrayList as the item in your ArrayList, then you can do this.


			<delay>2</delay>
			An example

ArrayList list = new ArrayList();

ArrayList list2 = new ArrayList();
ArrayList list3 = new ArrayList();

list.add(list2);
list.add(list3);



			<delay>2</delay>
			This will result in your first ArrayList (list) containing two arraylists in position 0 and 1.


			<delay>2</delay>
			If however you are looking to add the contents of several ArrayLists to a single list of elements, then you use addAll on the  ArrayList.
			<delay>2</delay>
			Such as

ArrayList consolidatedList = new ArrayList();
list.addAll(list2);
list.addAll(list3);


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ maximum number ^ java array ^ dimensions </pattern>
		<template>
			
			The Java language does not limit the number of dimensions, but the Java VM spec limits the number of dimensions to 255.


			<delay>2</delay>
			For example, the following code will fail to compile:

class Main {
    public static void main(String[] args) {
        final int[][][][][][][][][][][][][][][][]
                 [][][][][][][][][][][][][][][][]
                 [][][][][][][][][][][][][][][][]
                 [][][][][][][][][][][][][][][][]
                 [][][][][][][][][][][][][][][][]
                 [][][][][][][][][][][][][][][][]
                 [][][][][][][][][][][][][][][][]
                 [][][][][][][][][][][][][][][][]
                 [][][][][][][][][][][][][][][][]
                 [][][][][][][][][][][][][][][][]
                 [][][][][][][][][][][][][][][][]
                 [][][][][][][][][][][][][][][][]
                 [][][][][][][][][][][][][][][][]
                 [][][][][][][][][][][][][][][][]
                 [][][][][][][][][][][][][][][][]
                 [][][][][][][][][][][][][][][][] x;
    }
}


with error:

1.java:18: error: array type has too many dimensions
                 [][][][][][][][][][][][][][][][] x;
                                                  ^
1 error



			<delay>2</delay>
			(Ref: https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.1 "An array type descriptor is valid only if it represents 255 or fewer dimensions.")

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java bitmap ^ read ^ file </pattern>
		<template>
			
			Skip the byte array if you want:
    Bitmap bitmap = BitmapFactory.decodeFile(filename);

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ hash table ^ copy ^ array </pattern>
		<template>
			
			You can easily put them into a Hashtable of int -> float.  
			<delay>2</delay>
			The following method will use their index in the array as the key.


			<delay>2</delay>
			float[] arr;
Hashtable&lt;Integer, Float&gt; table = new Hashtable&lt;Integer, Float&gt;(arr.length);
for (int i = 0; i &lt; arr.length; i++) {
    table.put(i, arr[i]);
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ copy 2 array ^ new one </pattern>
		<template>
			
			My reputation doesn't allow me to comment on Adamski's answer, but there is an error on this line:

 System.arraycopy(src2, 0, dest, src1.length - 1, src2.length);


With src1.length - 1 as an argument to destPos, you overwrite the last element copied from the src1 array.
			<delay>2</delay>
			In this case you overwrite the element on index 4, which is the 5th element of the array.


			<delay>2</delay>
			This code might be easier to understand:

    int[] array1 = { 1, 2, 3 };
    int[] array2 = { 4, 5, 6, 7 };
    int[] array3 = new int[ array1.length + array2.length ];

    System.arraycopy( array1, 0, array3, 0, array1.length );
    System.arraycopy( array2, 0, array3, array1.length, array2.length );

    for (int i = 0; i &lt; array3.length; i++) {
        System.out.print( array3[i] + ", " );
    }


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ byte array ^ string ^ convert </pattern>
		<template>
			
			The Best way to convert bytearray to String is 

public void convertByteArrayToString(Charset encoding) {

        byte[] byteArray = new byte[] {87, 79, 87, 46, 46, 46};

        String value = new String(byteArray, encoding);

        System.out.println(value);
    }


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ pass array ^ one servlet ^ another servlet </pattern>
		<template>
			
			You can 


put your array in request context as an attribute using request.setAttribute()
forward the request to second servlet using RequestDispatcher.forward() 
in your second servlet read the value using request.getAttribute()


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ best way ^ vector ^ strings ^ convert ^ array </pattern>
		<template>
			
			Call the constructor of Vector that uses an existing collection (your array, in this case) to initialize itself:

String[] strings = { "Here", "Are", "Some", "Strings" };
Vector&lt;String&gt; vector = new Vector&lt;String&gt;(Arrays.asList(strings));


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java arraylist extend ^ 3 )/ 2 ^ ensurecapacity () ^ const 1 ^ 1 ^ oldcapacity ^ capacity ^ 5 </pattern>
		<template>
			
			It helps mitigate the exponential increase in time that would result if the array was expanded by one element instead.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ stackoverflow ^ different ^ arrayindexoutofbounds </pattern>
		<template>
			
			StackOverflowError occurs during endless recursive calls.
			<delay>2</delay>
			It has nothing to do with arrays.
			<delay>2</delay>
			ArrayIndexOutOfBoundsException occurs when when you try to use an index beyond the size of the array.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java array destroy </pattern>
		<template>
			
			Only if Array_Name had actually been referencing an array to begin with.
			<delay>2</delay>
			And only if there are no other references to the array.
			<delay>2</delay>
			And it will reclaim only those elements of the array which aren't referenced by anything outside of the array.
			<delay>2</delay>
			And it will only do so when it feels like getting around to it :-)


			<delay>2</delay>
			(The syntax Array_Name[] = NULL isn't really meaningful.
			<delay>2</delay>
			But I'm assuming you'd done something like:

 Foo[] Array_Name = new Foo[n];
 //...
 Array_Name = null; // Note the lowercase "null"



			<delay>2</delay>
			This might make the array a proper target for garbage collection, given the conditions I described above.)

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java allow arrays ^ size 0 </pattern>
		<template>
			
			It signifies that it is empty.
			<delay>2</delay>
			I.e. you can loop over it as if it had items and have no result occur:

for(int k = 0; k &lt; strings.length; k++){
   // something
}



			<delay>2</delay>
			Thereby avoiding the need to check.
			<delay>2</delay>
			If the array in question were null, an exception would occur, but in this case it just does nothing, which may be appropriate.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ array handling algorithms </pattern>
		<template>
			
			This was recently covered on the ihas1337code blog.
			<delay>2</delay>
			See the comments section for solutions.


			<delay>2</delay>
			Essentially the most efficient way to solve this is to put the numbers in a hash_map and then loop through the array a second time checking each element x
			<delay>2</delay>
			if element (N - x) exists in the hash_map. 


			<delay>2</delay>
			You can optimize a bit from there, but that is the general idea.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ byte array ^ deephashcode </pattern>
		<template>
			
			First off, no need for "Deep".
			<delay>2</delay>
			It's a primitive.
			<delay>2</delay>
			You don't need Deep.


			<delay>2</delay>
			Just use Arrays.hashCode(byte[] yourArray)

Edit: To clarify, Deep implies delving into the Objects contained within the array.
			<delay>2</delay>
			Given that you are dealing with a primitive, you just need to use the primitive value itself in the calculation.
			<delay>2</delay>
			That's why none of the Deep methods revolve around primitives.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ memory address ^ java ^ array </pattern>
		<template>
			
			There is no programmer-realizable notion of an "address" in Java.  
			<delay>2</delay>
			In a language like C or C++, objects' identities are equated with
			<delay>2</delay>
			their address - two objects are the same object if they live in the same memory location.  
			<delay>2</delay>
			In Java, this notion of identity is decoupled from the object's address.  
			<delay>2</delay>
			This allows some optimizations that are not possible in C++.  
			<delay>2</delay>
			For example, the garbage collector could, in theory, move objects around in memory to avoid fragmentation, so long as it modifies references so they point to the right location.  
			<delay>2</delay>
			Because memory addresses can't be accessed directly by the programmer, this operation is permissible.  
			<delay>2</delay>
			In C++, it wouldn't work, because the compiler couldn't tell if a particular bit pattern in memory was some sort of encoded pointer.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ android opengl modify vertex array ^ draw call </pattern>
		<template>
			
			It's not bad practice if you modify the vertex array when you draw it as ordinary vertex array.


			<delay>2</delay>
			It's bad practice to modify the vertex array if you use vertex buffer objects in your draw method.
			<delay>2</delay>
			That's because you have to reupload it to your VRAM once it is edited.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ primitive types ^ containing package ^ java ^ arrays </pattern>
		<template>
			
			Simple Answer

Let's test:

public static void main(final String[] args){
    System.out.println(long.class.getPackage());
    System.out.println(Object[].class.getPackage());
}


Output:


  null
  
			<delay>2</delay>
			null  



			<delay>2</delay>
			No they don't :-)




			<delay>2</delay>
			Primitive Types

Primitive classes are special constructs that don't have a package.
			<delay>2</delay>
			For reference, see the source of Long.TYPE, the alias for long.class:

/**
 * The &lt;code&gt;Class&lt;/code&gt; instance representing the primitive type
 * &lt;code&gt;long&lt;/code&gt;.
 *
 * @since   JDK1.1
 */
public static final Class&lt;Long&gt; TYPE =
       (Class&lt;Long&gt;) Class.getPrimitiveClass("long");


As you can see, a primitive class is loaded through a package-private and native mechanism:

static native Class getPrimitiveClass(String name);


and casted to Class&lt;Long&gt; (in order to enable auto-boxing, I guess)

Wrapper Types and their Primitive Types


			<delay>2</delay>
			BTW: every wrapper class has a static final field called TYPE that maps to the corresponding primitive class, as the following code shows:

private static Class&lt;?&gt; getPrimitiveClass(final Class&lt;?&gt; wrapperClass){
    try{
        final Field field = wrapperClass.getDeclaredField("TYPE");
        final int modifiers = field.getModifiers();
        if(Modifier.isPublic(modifiers) &amp;&amp; Modifier.isStatic(modifiers)
            &amp;&amp; Modifier.isFinal(modifiers)
            &amp;&amp; Class.class.equals(field.getType())){
            return (Class&lt;?&gt;) field.get(null);
        } else{
            throw new IllegalArgumentException("This is not a wrapper class: "
                + wrapperClass);
        }
    } catch(final NoSuchFieldException e){
        throw new IllegalArgumentException("This is not a wrapper class:"
            + wrapperClass + ", field TYPE doesn't exists.", e);
    } catch(final IllegalAccessException e){
        throw new IllegalArgumentException("This is not a wrapper class:"
            + wrapperClass + ", field TYPE can't be accessed.", e);
    }
}

public static void main(final String[] args){
    final List&lt;Class&lt;?&gt;&gt; wrappers =
        Arrays.&lt;Class&lt;?&gt;&gt; asList(
            Byte.class, Long.class, Integer.class,
            Short.class, Boolean.class, Double.class
            // etc.
        );
    for(final Class&lt;?&gt; clazz : wrappers){
        System.out.println("Wrapper type: " + clazz.getName()
            + ", primitive type: "
            + getPrimitiveClass(clazz).getCanonicalName());
    }

}


Output:


  Wrapper type: java.lang.Byte, primitive type:
			<delay>2</delay>
			byte
  Wrapper type: java.lang.Long, primitive type:
			<delay>2</delay>
			long
  Wrapper type: java.lang.Integer, primitive type:
			<delay>2</delay>
			int
  Wrapper type:
			<delay>2</delay>
			java.lang.Short, primitive type:
			<delay>2</delay>
			short
  Wrapper type:
			<delay>2</delay>
			java.lang.Boolean, primitive type:
			<delay>2</delay>
			boolean
  Wrapper type:
			<delay>2</delay>
			java.lang.Double, primitive type:
			<delay>2</delay>
			double  




Array Types

Arrays can be created through Array.newInstance(type, length), which internally calls this method:

public static void main(final String[] args){
    System.out.println(long.class.getPackage());
    System.out.println(Object[].class.getPackage());
}
0

so again, the classes are special constructs created by native code (and they don't have a package, or else you could find them somewhere)

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ extend arraylist ^ java </pattern>
		<template>
			
			Yes you can.


			<delay>2</delay>
			public class MyArrayList&lt;E&gt; extends ArrayList&lt;E&gt;
{
}



			<delay>2</delay>
			However, I'm not sure why you would want to do this.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java getting array keys </pattern>
		<template>
			
			The Map collection has a keySet() method, and I think that's the closest thing to PHP's associative arrays in Java. 

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ array indexof ^ java </pattern>
		<template>
			
			There are a couple of ways to accomplish this using the Arrays utility class.


			<delay>2</delay>
			If the array is not sorted and is not an array of primitives:

java.util.Arrays.asList(theArray).indexOf(o)



			<delay>2</delay>
			If the array is primitives and not sorted, one should use a solution offered by one of the other answers such as Kerem Baydoğan's, Andrew McKinlay's or Mishax's.  
			<delay>2</delay>
			The above code will compile even if theArray is primitive (possibly emitting a warning) but you'll get totally incorrect results nonetheless.


			<delay>2</delay>
			If the array is sorted, you can make use of a binary search for performance:

java.util.Arrays.binarySearch(theArray, o)


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ byte [] ^ java ^ clob </pattern>
		<template>
			
			with commons-io

byte[] data = IOUtils.toByteArray(clob.getAsciiStream());


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ binary values ^ vice ^ versa ^ string ^ java ^ float ^ convert </pattern>
		<template>
			
			I'm not sure it is what you want, but here's a solution to have the binary representation of the IEEE 754 floating-point "double format" bit layout for a float
			<delay>2</delay>
			(it is basically the memory representation of a float) :

int intBits = Float.floatToIntBits(yourFloat); 
String binary = Integer.toBinaryString(intBits);



			<delay>2</delay>
			For the reverse procedure :

int intBits = Integer.parseInt(myString, 2);
float myFloat = Float.intBitsToFloat(intBits);


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ rubix cube ^ array java ^ model </pattern>
		<template>
			
			The source code for this one is available:

 http://software.rubikscube.info/AnimCube/



			<delay>2</delay>
			Your in luck, it's Java.
			<delay>2</delay>
			:)


			<delay>2</delay>
			This paper shows different ways to model the cube -

http://portal.acm.org/citation.cfm?id=801107&amp;coll=portal&amp;dl=ACM

and another exploratory paper...

http://www.chilton.com/~jimw/rubik.html

but a simple answer would be a 3x3x3 array with 3 digits.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ store arraylist ^ java ^ array </pattern>
		<template>
			
			That depends on what you want:

List&lt;String&gt; list = new ArrayList&lt;String&gt;();
// add items to the list



			<delay>2</delay>
			Now if you want to store the list in an array, you can do one of these:

Object[] arrOfObjects = new Object[]{list};
List&lt;?&gt;[] arrOfLists = new List&lt;?&gt;[]{list};



			<delay>2</delay>
			But if you want the list items in an array, do one of these:

Object[] arrayOfObjects = list.toArray();
String[] arrayOfStrings = list.toArray(new String[list.size()]);


Reference:


Collection.toArray()
Collection.toArray(T[])


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ convert array ^ strings ^ string ^ java </pattern>
		<template>
			
			With control over the delimiter (Java 8+):
String str = String.join(&quot;,&quot;, arr);

...or &lt;8:
StringBuilder builder = new StringBuilder();
for(String s : arr) {
    builder.append(s);
}
String str = builder.toString();


			<delay>2</delay>
			Alternatively, if you just want a &quot;debug-style&quot; dump of an array:
String str = Arrays.toString(arr);


			<delay>2</delay>
			And if you're coming from the Android angle:
String str = TextUtils.join(&quot;,&quot;, arr);

You can modify the above depending on what characters, if any, you want in between strings.

			<delay>2</delay>
			You may see near identical code to the pre-Java 8 code but using StringBuffer - StringBuilder is a newer class that's not thread-safe, but therefore has better performance in a single thread because it does away with unneeded synchronization.
			<delay>2</delay>
			In short, you're better using StringBuilder in 99% of cases - functionality wise, the two are identical.

			<delay>2</delay>
			DON'T use a string and just append to it with +=
			<delay>2</delay>
			like some of the answers show here.
			<delay>2</delay>
			This sends the GC through the roof because you're creating and throwing away as many string objects as you have items in your array.
			<delay>2</delay>
			For small arrays you might not really notice the difference, but for large ones it can be orders of magnitude slower.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ sd card ^ array list ^ images ^ getting </pattern>
		<template>
			
			You need to query the Image media store to retrieve the data.


			<delay>2</delay>
			Cursor c = managedQuery(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
                    new String[] { /*columns you want */, null, null, null);
c.moveToFirst();
while(!c.isLast()) {
// add some data to your array list
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ use two different algorithm ^ sorting arrays </pattern>
		<template>
			
			The reason for using mergesort is that they want a stable algorithm - e.g. where equal objects (by compareTo() or compare()) are at the same relative order as before.


			<delay>2</delay>
			For primitives, equality implies "non-distinguish-ability".
			<delay>2</delay>
			When sorting {5, 3, 5} to {3, 5, 5} it does not matter which of the fives was the first one before.

			<delay>2</delay>
			So we can use the quicker (and non-stable) quicksort algorithm here.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ string [] ^ hashset ^ converting </pattern>
		<template>
			
			set.toArray(new String[set.size()]);


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ one convert ^ list ^ java ^ hashmap </pattern>
		<template>
			
			HashMap&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;();
map.put (1, "Mark");
map.put (2, "Tarryn");
List&lt;String&gt; list = new ArrayList&lt;String&gt;(map.values());
for (String s : list) {
    System.out.println(s);
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ converting char [] ^ byte [] </pattern>
		<template>
			
			Convert without creating String object:

import java.nio.CharBuffer;
import java.nio.ByteBuffer;
import java.util.Arrays;

byte[] toBytes(char[] chars) {
  CharBuffer charBuffer = CharBuffer.wrap(chars);
  ByteBuffer byteBuffer = Charset.forName("UTF-8").encode(charBuffer);
  byte[] bytes = Arrays.copyOfRange(byteBuffer.array(),
            byteBuffer.position(), byteBuffer.limit());
  Arrays.fill(byteBuffer.array(), (byte) 0); // clear sensitive data
  return bytes;
}


Usage:

char[] chars = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};
byte[] bytes = toBytes(chars);
/* do something with chars/bytes */
Arrays.fill(chars, '\u0000'); // clear sensitive data
Arrays.fill(bytes, (byte) 0); // clear sensitive data


Solution is inspired from Swing recommendation to store passwords in char[].
			<delay>2</delay>
			(See Why is char[] preferred over String for passwords?)


			<delay>2</delay>
			Remember not to write sensitive data to logs and ensure that JVM won't hold any references to it.




			<delay>2</delay>
			The code above is correct but not effective.
			<delay>2</delay>
			If you don't need performance but want security you can use it.
			<delay>2</delay>
			If security also not a goal then do simply String.getBytes.
			<delay>2</delay>
			Code above is not effective if you look down of implementation of encode in JDK.
			<delay>2</delay>
			Besides you need to copy arrays and create buffers.
			<delay>2</delay>
			Another way to convert is inline all code behind encode (example for UTF-8):

val xs: Array[Char] = "A ß € 嗨 𝄞 🙂".toArray
val len = xs.length
val ys: Array[Byte] = new Array(3 * len) // worst case
var i = 0; var j = 0 // i for chars; j for bytes
while (i &lt; len) { // fill ys with bytes
  val c = xs(i)
  if (c &lt; 0x80) {
    ys(j) = c.toByte
    i = i + 1
    j = j + 1
  } else if (c &lt; 0x800) {
    ys(j) = (0xc0 | (c &gt;&gt; 6)).toByte
    ys(j + 1) = (0x80 | (c &amp; 0x3f)).toByte
    i = i + 1
    j = j + 2
  } else if (Character.isHighSurrogate(c)) {
    if (len - i &lt; 2) throw new Exception("overflow")
    val d = xs(i + 1)
    val uc: Int = 
      if (Character.isLowSurrogate(d)) {
        Character.toCodePoint(c, d)
      } else {
        throw new Exception("malformed")
      }
    ys(j) = (0xf0 | ((uc &gt;&gt; 18))).toByte
    ys(j + 1) = (0x80 | ((uc &gt;&gt; 12) &amp; 0x3f)).toByte
    ys(j + 2) = (0x80 | ((uc &gt;&gt;  6) &amp; 0x3f)).toByte
    ys(j + 3) = (0x80 | (uc &amp; 0x3f)).toByte
    i = i + 2 // 2 chars
    j = j + 4
  } else if (Character.isLowSurrogate(c)) {
    throw new Exception("malformed")
  } else {
    ys(j) = (0xe0 | (c &gt;&gt; 12)).toByte
    ys(j + 1) = (0x80 | ((c &gt;&gt; 6) &amp; 0x3f)).toByte
    ys(j + 2) = (0x80 | (c &amp; 0x3f)).toByte
    i = i + 1
    j = j + 3
  }
}
// check
println(new String(ys, 0, j, "UTF-8"))


Excuse me for using Scala language.
			<delay>2</delay>
			If you have problems with converting this code to Java I can rewrite it.
			<delay>2</delay>
			What about performance always check on real data (with JMH for example).
			<delay>2</delay>
			This code looks very similar to what you can see in JDK[2] and Protobuf[3].

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ arraylist replace element ^ given index ^ exists </pattern>
		<template>
			
			  arrayList.set(index i,String replaceElement);


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ 20 random bytes ^ create ^ array </pattern>
		<template>
			
			Try the Random.nextBytes method:

byte[] b = new byte[20];
new Random().nextBytes(b);


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ ascii byte array ^ java string ^ convert </pattern>
		<template>
			
			Using the getBytes method, giving it the appropriate Charset (or Charset name).


			<delay>2</delay>
			Example:

String s = "Hello, there.";
byte[] b = s.getBytes(StandardCharsets.US_ASCII);


(Before Java 7: byte[] b = s.getBytes("US-ASCII");)

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ byte array ^ j2me ^ image </pattern>
		<template>
			
			Use createImage(byte[] imageData, int imageOffset, int imageLength)
			<delay>2</delay>
			an example can be seen here 

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ char array ^ string ^ convert </pattern>
		<template>
			
			Use String#toCharArray().


			<delay>2</delay>
			char[] chars = "some string".toCharArray();


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ sorting string arraylist ^ android </pattern>
		<template>
			
			ArrayList&lt;String&gt; names = new ArrayList&lt;String&gt;();
names =fillNames() // whatever method you need to fill here;
Collections.sort(names);


http://download.oracle.com/javase/6/docs/api/java/util/Collections.html#sort%28java.util.List%29


  Sorts the specified list into ascending order, according to the natural ordering of its elements.
			<delay>2</delay>
			All elements in the list must implement the Comparable interface.
			<delay>2</delay>
			Furthermore, all elements in the list must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the list).



			<delay>2</delay>
			String implements Comparable:


  java.lang Class String
  
  java.lang.Object   extended by
  java.lang.String
  
  
			<delay>2</delay>
			All Implemented Interfaces:
      Serializable, CharSequence, Comparable


http://download.oracle.com/javase/6/docs/api/java/lang/String.html

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ dimensional array ^ column ^ checking ^ 2 </pattern>
		<template>
			
			If you want to check one column you need one loop, if you want to check N columns you need two nested loops.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ map ^ list ^ java ^ hashmap ^ arraylist </pattern>
		<template>
			
			If you're asking whether or not HashMap implements the Map interface, like ArrayList implements the List interface, then yes.


			<delay>2</delay>
			public class ArrayList&lt;E&gt;
extends AbstractList&lt;E&gt;
implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable

public class HashMap
extends AbstractMap
implements Map, Cloneable, Serializable


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ converting string array ^ util ^ list ^ java </pattern>
		<template>
			
			List&lt;String&gt; strings = Arrays.asList(new String[]{"one", "two", "three"});



			<delay>2</delay>
			This is a list view of the array, the list is partly unmodifiable, you can't add or delete elements.
			<delay>2</delay>
			But the time complexity is O(1).


			<delay>2</delay>
			If you want a modifiable a List:

List&lt;String&gt; strings = 
     new ArrayList&lt;String&gt;(Arrays.asList(new String[]{"one", "two", "three"}));



			<delay>2</delay>
			This will copy all elements from the source array into a new list (complexity: O(n))

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ unordered character array ^ unique elements ^ java ^ get </pattern>
		<template>
			
			One-liner:

Set&lt;Character&gt; uniqueChars = new HashSet&lt;Character&gt;(Arrays.asList(array));


(the array will need to be Character[] not char[].
			<delay>2</delay>
			Otherwise you'd have to convert it to the wrapper array)


			<delay>2</delay>
			Note that, if this is homework, you would need a more algorithmic approach in order to show that you understand what you are doing.
			<delay>2</delay>
			The above solution may not be applicable.
			<delay>2</delay>
			But here's how it works:


the array is turned into a List.
			<delay>2</delay>
			This is O(1), as the array just backs the new, unmodifiable list.
			<delay>2</delay>
			This is done so that the array can conform the the List interface, which is required by the HashSet constructor
a HashSet
			<delay>2</delay>
			is a collection backed by a Set&lt;Character&gt; uniqueChars = new HashSet&lt;Character&gt;(Arrays.asList(array));
0 (hashtable).
			<delay>2</delay>
			It computes the hashes of keys and stores them in an internal array, under an index = hash.
			<delay>2</delay>
			Thus lookup is O(1).

			<delay>2</delay>
			the Set&lt;Character&gt; uniqueChars = new HashSet&lt;Character&gt;(Arrays.asList(array));
1 constructor simply iterates the passed Set&lt;Character&gt; uniqueChars = new HashSet&lt;Character&gt;(Arrays.asList(array));
2 and calls Set&lt;Character&gt; uniqueChars = new HashSet&lt;Character&gt;(Arrays.asList(array));
3 for each item.
			<delay>2</delay>
			Items that are the same are not allowed twice in the set (sets by definition do not allow duplicates).
			<delay>2</delay>
			This is so, because the hash of the item will be the same as an existing one, so the new one will replace the old one.
			<delay>2</delay>
			Note that items with the same hash are allowed, but not those that are also equal (Set&lt;Character&gt; uniqueChars = new HashSet&lt;Character&gt;(Arrays.asList(array));
4)


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ array final ^ use ^ making ^ java ^ immutable </pattern>
		<template>
			
			There may be several.
			<delay>2</delay>
			At least, it ensures that


later code cannot point the variable 'array' to another array 

			<delay>2</delay>
			the variable 'array' can be seen by anonymous inner classes (e.g. listeners).



			<delay>2</delay>
			Importantly, it does not ensure that the contents of 'array' are immutable.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ two dimensional array ^ major order ^ major ^ stored ^ row ^ java ^ column </pattern>
		<template>
			
			Java doesn't have multi-dimensional arrays.
			<delay>2</delay>
			It has arrays of arrays.
			<delay>2</delay>
			So for instance,

int[][]


...is an array of int[] (and of course int[] is an array of int).


			<delay>2</delay>
			Consequently, Java is neither column-major nor row-major order (but see note below about how to read a[2][3]), because while a given array's entries are stored in a contiguous block of memory, the subordinate arrays those entries point to are object references to completely separate, unrelated blocks of memory.
			<delay>2</delay>
			This also means that Java's arrays of arrays are inherently jagged: The entry at [0] might refer to a 3-slot array, the one at [1] might refer to a 4-slot array, [2] might not refer to an array at all (it could have null), and perhaps int[][]
0 refers to a 6-slot array.


			<delay>2</delay>
			A picture is worth 1k-24 words and all that:


                         
			<delay>2</delay>
			+−−−−−−−−+
                   
			<delay>2</delay>
			+−−−−>| int[]  |
+−−−−−−−−−−−+      
			<delay>2</delay>
			|     +−−−−−−−−+
|  int[]
			<delay>2</delay>
			[]  |      
			<delay>2</delay>
			|     | 0: int |
+−−−−−−−−−−−+      
			<delay>2</delay>
			|     | 1: int |
| 0: int[]  |−−−−−−+     | 2: int |
| 1: int[]  |−−−−−−+     +
			<delay>2</delay>
			−−−−−−−−+
| 2: null   |      |
| 3: int[]  
			<delay>2</delay>
			|−−+   |     +−−−−−−−−+
+−−−−−−−−−−−+  |   +−−−−>| int[]  |
               
			<delay>2</delay>
			|         +−−−−−−−−+
               
			<delay>2</delay>
			|         | 0: int |
               
			<delay>2</delay>
			|         | 1: int |
               
			<delay>2</delay>
			|         | 2: int |
               
			<delay>2</delay>
			|         | 3: int |
               
			<delay>2</delay>
			|         +−−−−−−−−+
               |
               
			<delay>2</delay>
			|         +−−−−−−−−+
               +−−−−−−−−−| int[]  |
                         
			<delay>2</delay>
			−−−−−−−−+
                         | 0: int |
                         | 1: int |
                         | 2: int |
                         | 3: int |
                         | 4: int |
                         | 5: int |
                         
			<delay>2</delay>
			+−−−−−−−−+



			<delay>2</delay>
			Once you know that, you know that (say) int[][]
1 means "Get the array referenced by the entry at index
			<delay>2</delay>
			int[][]
2 of int[][]
3, then get the entry referenced by index int[][]
4 of that subordinate array.
			<delay>2</delay>
			" I think of it as fairly similar to row-major order, but it's not quite the same thing.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ char array ^ use ^ unknown ^ size ^ java </pattern>
		<template>
			
			In general, you can use a java.util.List when you don't know the size up front.


			<delay>2</delay>
			List&lt;Character&gt; chars = new ArrayList&lt;Character&gt;();
chars.add('f');
chars.add('o');
chars.add('o');



			<delay>2</delay>
			Depending on your needs, a StringBuilder might make more sense than a List&lt;Character&gt;.


			<delay>2</delay>
			StringBuilder sb = new StringBuilder();
sb.append('f')
  .append('o')
  .append('o');



			<delay>2</delay>
			If you want to get really slick, use Trove for its list-of-primitives so you can work with the (third-party equivalent of) a List&lt;char&gt;.
			<delay>2</delay>
			nevermind.
			<delay>2</delay>
			Trove does not have a TCharArrayList.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ write byte [] ^ java ^ file </pattern>
		<template>
			
			A File object doesn't contain the content of the file.
			<delay>2</delay>
			It is only a pointer to the file on your hard drive (or other storage medium, like an SSD, USB drive, network share).
			<delay>2</delay>
			So I think what you want is writing it to the hard drive.


			<delay>2</delay>
			You have to write the file using some classes in the Java API

BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(yourFile));
bos.write(fileBytes);
bos.flush();
bos.close();


You can also use a Writer instead of an OutputStream.
			<delay>2</delay>
			Using a writer will allow you to write text
			<delay>2</delay>
			(String, char[]).


			<delay>2</delay>
			BufferedWriter bw = new BufferedWriter(new FileWriter(yourFile));



			<delay>2</delay>
			Since you said you wanted to keep everything in memory and don't want to write anything, you might try to use ByteArrayInputStream.
			<delay>2</delay>
			This simulates an InputStream, which you can pass to the most of the classes.


			<delay>2</delay>
			ByteArrayInputStream bais = new ByteArrayInputStream(yourBytes);


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ list vs ^ arraylist </pattern>
		<template>
			
			List is in interface while ArrayList is a class.


			<delay>2</delay>
			See ArrayList, and List.


			<delay>2</delay>
			E.g, you can't use this setup:

List&lt;String&gt; list = new List&lt;String&gt;();...
			<delay>2</delay>
			Because it's an interface.


			<delay>2</delay>
			However, this works:

ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();


			<delay>2</delay>
			Also... You can do as duffymo says below, which is more or less the same as implementing the List interface (making your own list implementation).

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java xml ^ array </pattern>
		<template>
			
			have a look at xstream - http://x-stream.github.io/. Very easy to use library to convert XML into java objects.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java use string ^ "]= 1 ;) ^ index array key ^ array [" ^ ex </pattern>
		<template>
			
			No.


			<delay>2</delay>
			To do something like this, you have to use a Map.


			<delay>2</delay>
			Map&lt;String, Integer&gt; aMap = new HashMap&lt;String, Integer&gt;();
aMap.put("a" , Integer.valueOf(1));


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ create base64binary data </pattern>
		<template>
			
			Try commons-codec with public static byte[] encodeBase64(byte[] binaryData).

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ convert byte [] ^ object file ^ java </pattern>
		<template>
			
			The File object is just a wrapper around the name for a real file on the disk.
			<delay>2</delay>
			It does not contain any data.
			<delay>2</delay>
			You will have to write your byte array into a file first.
			<delay>2</delay>
			After the API you then call is done, you can maybe delete that file again.
			<delay>2</delay>
			Search for how to manage temporary files in Java.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java array ^ bytes </pattern>
		<template>
			
			Not sure what you meant by resized and merged 

from the documentation:


  byte: The byte data type is an 8-bit signed two's complement integer.
			<delay>2</delay>
			It has a minimum value of -128 and a maximum value of 127 (inclusive).
			<delay>2</delay>
			The byte data type can be useful for saving memory in large arrays, where the memory savings actually matters.
			<delay>2</delay>
			They can also be used in place of int where their limits help to clarify your code; the fact that a variable's range is limited can serve as a form of documentation.



			<delay>2</delay>
			Edit: If by resized/merged you are talking about the array itself, there's nothing special about a byte array compared to other arrays.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ multidimensional array problem ^ java </pattern>
		<template>
			
			Yes.
			<delay>2</delay>
			Length dimensions vary from row to row.
			<delay>2</delay>
			You can do matrix[i].length to get the length of row i.
			<delay>2</delay>
			If you know the matrix is square, all the row lengths will equals matrix[0].length anyways, so it doesn't matter.


			<delay>2</delay>
			If you're trying to iterate through all elements:

for(int i = 0; i &lt; matrix.length; i++){
    for(int j &lt; 0; j &lt; matrix[i].length; j++){
        count += matrix[i][j];
    }
}


The same principle can be applied for any number of dimensions.
			<delay>2</delay>
			For loops, you need 1 nested loop per dimension.
			<delay>2</delay>
			For lengths, each bracketed part is actually a new element, so 3d array
			<delay>2</delay>
			ar will yield a 2d array with ar[i], 1d with ar[i][j], and 0d (single element of the array type) with ar[i][j][k]

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ read file bytes ^ java </pattern>
		<template>
			
			FileInputStream fis = new FileInputStream("your file name");
byte[] bytes = new byte[100]; // replace 100 with the desired size, of course
int offset = 0;               // which element to stuff the byte into  

fis.read(bytes, offset, 1);   // the 1 is how many bytes to read


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java iterator ^ 2d array ^ create </pattern>
		<template>
			
			If you implement the Iterable interface, you can use a for-each loop.
			<delay>2</delay>
			Related examples may be found here. 

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ byte array ^ value ^ assign </pattern>
		<template>
			
			If you're trying to assign hard-coded values, you can use:

byte[] bytes = { (byte) 204, 29, (byte) 207, (byte) 217 };


Note the cast because Java bytes are signed - the cast here will basically force the overflow to a negative value, which is probably what you want.


			<delay>2</delay>
			If you're actually trying to parse a string, you need to do that - split the string into parts and parse each one.


			<delay>2</delay>
			If you're trying to convert a string into its binary representation under some particular encoding, you should use String.getBytes, e.g.

byte[] abc = "204.29.207.217".getBytes("UTF-8");


(Note that conventionally the [] is put as part of the type of the variable, not after the variable name.
			<delay>2</delay>
			While the latter is allowed, it's discouraged as a matter of style.)

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java array declaration without hard coding ^ size </pattern>
		<template>
			
			Use a List.
			<delay>2</delay>
			The size does not need to be declared on creation of the List.
			<delay>2</delay>
			The toArray() method will return an array representation of the list.
			<delay>2</delay>
			There are multiple implementations you can use but the most popular tends to be ArrayList (though it is best to map the implementation to your particular situation).

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ convert int [] ^ big integer </pattern>
		<template>
			
			First, make sure you know in which format your int[] is meant to be interpreted.


			<delay>2</delay>
			Each int can be seen as consisting of four bytes, and these bytes together can be converted to an BigInteger.
			<delay>2</delay>
			The details are the byte order - which byte is the most and which one the least significant?


			<delay>2</delay>
			Also, do you have a signed or unsigned number?


			<delay>2</delay>
			A simple way to convert your ints to bytes (for latter use in a BigInteger constructor) would be to use ByteBuffer and wrap an IntBuffer around it.


			<delay>2</delay>
			public BigInteger toBigInteger(int[] data) {
    byte[] array = new byte[data.length * 4];
    ByteBuffer bbuf = ByteBuffer.wrap(array);
    IntBuffer ibuf = bbuf.asIntBuffer();
    ibuf.put(data);
    return new BigInteger(array);
}


Obvious adaptions would be to set the byte order of bbuf, or use another BigInteger constructor (for unsigned).

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ perfomance benefits ^ ensurecapacity ()? ^ arraylist </pattern>
		<template>
			
			The performance benefit is realised in cases where you are about to add multiple elements to the list and know how many you're going to be adding.  
			<delay>2</delay>
			By calling ensureCapacity(int) you cause the underlying array to be resized once instead of potentially many times.


			<delay>2</delay>
			Note however, that in reality you should rarely need to call this method; typically you will either instantiate the ArrayList with a known capacity, or in cases where the list size is unknown you should probably be considering using a LinkedList instead.


			<delay>2</delay>
			Also note that the resize strategy of ArrayList is typically implemented in such a way that array copies are a rare operation (e.g. the capacity may increase by 50% every time the array becomes full).  
			<delay>2</delay>
			In other words, even if you do not call ensureCapacity in advance you are unlikely to notice any slow-down within your code.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ arraylist object ^ avoid adding ^ avoid ^ modified ^ e ^ deleting ^ content </pattern>
		<template>
			
			By creating an unmodifiable list out of it:

List&lt;Object&gt; dontModify = Collections.unmodifiableList(originalList);


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ possible add ^ string ^ java ^ int ^ array </pattern>
		<template>
			
			No, Java is a strongly-typed language.
			<delay>2</delay>
			So you cannot add a String and an int to the same array if the array is typed as either String or int.


			<delay>2</delay>
			However if your array is typed as Object, you can add a String and an Integer (an integer literal will be autoboxed) to that same array.
			<delay>2</delay>
			This is not recommended and is probably a sign that you should think more about your design.
			<delay>2</delay>
			The first question you need to ask yourself is why you need to do this.
			<delay>2</delay>
			If you do have a valid reason, then it would be better to convert from one to the other instead of having an array typed as Object.


			<delay>2</delay>
			Having a catch-call array where you can shove in any object in a bad idea for many reasons:


You are enforcing no separation between the objects.
			<delay>2</delay>
			Are the objects actually related to each other?
			<delay>2</delay>
			If so you type then using an interface or create an abstract class that each of the types extend.

			<delay>2</delay>
			Since you have no separation between the objects, anything you pull out of the array is an Object.
			<delay>2</delay>
			How would you know what it is?
			<delay>2</delay>
			You need to inspect its type explicitly.
			<delay>2</delay>
			This is an extremely cumbersome and unmaintainable design. 

			<delay>2</delay>
			You essentially end up losing type-safety and will not be able to benefit from type-mismatch errors that will show up during compilation.
			<delay>2</delay>
			This will hide possible errors in your code where you may have forgotten to inspect the type, or where you are casting an object to the wrong type.
			<delay>2</delay>
			This can lead to all kinds of nightmarish bugs.

			<delay>2</delay>
			Your code is going to be littered with explicit checks and casts and will be unmaintainable (by you or anyone else).

			<delay>2</delay>
			Your code leaks abstraction everywhere.
			<delay>2</delay>
			No one can look at the array and realize what the array contains.
			<delay>2</delay>
			Anyone who uses your code needs to remember an overwhelming amount of detail as to what types of objects the array can contain. 

			<delay>2</delay>
			Obfuscation is never a valid reason.
			<delay>2</delay>
			Code should be clear, easy to read, easy to maintain, and easy to understand (for you and for anyone else who will read your code).
			<delay>2</delay>
			Any code that looks obfuscated or is "clever" either needs to be rewritten or documented extensively to explain the reason for its "cleverness".
			<delay>2</delay>
			As far as obfuscating the source, it is a non-issue since you're going to be distributing the String0 files anyway.
			<delay>2</delay>
			You can run that through a decompiler to look at the source code.
			<delay>2</delay>
			There is nothing you can do at the source level to satisfactorily obfuscate your code; you're only going to make it difficult for you or anyone else to maintain.
			<delay>2</delay>
			Obfuscation can be done at the byte-code level and so that doesn't really apply to this situation.


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ byte array without external lib ^ get mimetype </pattern>
		<template>
			
			There is a way to do that using Java 7, but it is kind of clumsy (um tanto "desajeitado"):  



			<delay>2</delay>
			write the bytes to a (temporary) file,  
use Files.probeContentType(Path) to check the contents of that file


if the bytes came from a file you could use probeContentType directly on it.  




			<delay>2</delay>
			EDIT:
not very useful, at least on Windows: probeContentType seams to primarily use the file extension to determine the file type [:-|

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ escape arrayindexoutofboundsexception </pattern>
		<template>
			
			Use iterators or enhanced for-loops to abstract away the explicit use of array indexes:

Iterator&lt;Object&gt; myIterator = Arrays.asList(arrayOfObjects).iterator();
while(myIterator.hasNext()) {
    doSomething(myIterator.next());
}


or

for(Object o : arrayOfObjects) {
    doSomething(o);
}




Update:  you've updated the question; now it has an ArrayList.  
			<delay>2</delay>
			Iterators and enhanced for-loops work with ArrayLists (and many other collections), too:

for(Question myQuestion : q) {
    doSomethingWithAQuestion(myQuestion);
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ specific size ^ list ^ elements ^ create </pattern>
		<template>
			
			You can use Collections.nCopies.


			<delay>2</delay>
			Note however that the list returned is immutable.
			<delay>2</delay>
			In fact, the docs says "it the newly allocated data object is tiny (it contains a single reference to the data object)".


			<delay>2</delay>
			If you need a mutable list, you would do something like

List&lt;String&gt; hellos = new ArrayList&lt;String&gt;(Collections.nCopies(1000, "Hello"));



			<delay>2</delay>
			If you want 1000 distinct objects, you can use

List&lt;YourObject&gt; objects = Stream.generate(YourObject::new)
                                 .limit(1000)
                                 .collect(Collectors.toList());


Again, there is not guarantees about the capabilities of the resulting list implementation.
			<delay>2</delay>
			If you need, say an ArrayList, you would do

                                 ...
                                 .collect(ArrayList::new);


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ string array ^ values ^ make ^ java </pattern>
		<template>
			
			You could do something like this

String[] myStrings = { "One", "Two", "Three" };


or in expression

functionCall(new String[] { "One", "Two", "Three" });


or

String myStrings[];
myStrings = new String[] { "One", "Two", "Three" };


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ convert array elements ^ new dictionary ^ best way ^ keys </pattern>
		<template>
			
			This isn't much to go on, but let's see: 


			<delay>2</delay>
			Say you have an int[10] and you want to store them in a HashMap
			<delay>2</delay>
			(Dictionaries aren't used much these days).
			<delay>2</delay>
			You could do this:

Map&lt;Integer, Integer&gt; dict = new HashMap&lt;Integer, Integer&gt;();
for(int i = 0; i &lt; array.length; i++) {
    dict.put(i,array[i]); // autoboxing takes care of primitives
}



			<delay>2</delay>
			If you were looking to use the actual values in the array as the keys in the dictionary, then you have to ask yourself "
			<delay>2</delay>
			Where are my dictionary values coming from?"


			<delay>2</delay>
			For example, if you wanted the values to be the index, you could just reverse the above

dict.put(array[i],i);



			<delay>2</delay>
			Perhaps you have another array with some values in it.


			<delay>2</delay>
			code_placeholder_5

Simply put, you have a put method.
			<delay>2</delay>
			The first parameter is going to be the key, the second parameter is going to be the value.
			<delay>2</delay>
			As long as you're iterating over the array you'll have your keys; then it's just a matter of deciding what values go in there.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ merge 3 arraylist ^ one </pattern>
		<template>
			
			Use ArrayList.addAll().
			<delay>2</delay>
			Something like this should work (assuming lists contain String objects; you should change accordingly).


			<delay>2</delay>
			List&lt;String&gt; combined = new ArrayList&lt;String&gt;();
combined.addAll(firstArrayList);
combined.addAll(secondArrayList);
combined.addAll(thirdArrayList);


Update

I can see by your comments that you may actually be trying to create a 2D list.
			<delay>2</delay>
			If so, code such as the following should work:

List&lt;List&lt;String&gt;&gt; combined2d = new ArrayList&lt;List&lt;String&gt;&gt;();
combined2d.add(firstArrayList);
combined2d.add(secondArrayList);
combined2d.add(thirdArrayList);


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ creating multiple arrays ^ users input </pattern>
		<template>
			
			You can use java collections for this.
			<delay>2</delay>
			That way you no need to worry about the size being entered by the user.
			<delay>2</delay>
			I suggest Multimap.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ running time ^ lastindexof ^ java ^ arraylist </pattern>
		<template>
			
			the average execution time is proportional to number of elements.
			<delay>2</delay>
			That is, this method is an O(n) operation, where n is number of elements.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ string [] ^ list properties ^ convert </pattern>
		<template>
			
			Properties implements Map which has a keySet() method which returns a Set with all keys.
			<delay>2</delay>
			The Set in turn has a toArray() method which allows you to get the values as a plain array.


			<delay>2</delay>
			So, this should do:

String[] keys = properties.keySet().toArray(new String[0]);


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java equivalent ^ getlength ^ c ^ array </pattern>
		<template>
			
			No, because Java doesn't have multi-dimensional arrays.
			<delay>2</delay>
			It only has jagged arrays, i.e. arrays of arrays.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ get filename ^ byte array </pattern>
		<template>
			
			No.
			<delay>2</delay>
			You can take a guess at a mimetype from the content data itself, but the filename is not in there.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ extract file extension ^ byte array </pattern>
		<template>
			
			It turned out that there is a decent method in JDK's URLConnection class, please refer to the following answer: Getting A File&#39;s Mime Type
			<delay>2</delay>
			In Java


			<delay>2</delay>
			If one needs to extract file extension from byte array instead of file, one should simply use java.io.ByteArrayInputStream (class to read bytes specifically from byte arrays) instead of java.io.FileInputStream (class to read bytes specifically from files) like in the following example:


			<delay>2</delay>
			byte[] content = ;
InputStream is = new ByteArrayInputStream(content);
String mimeType = URLConnection.guessContentTypeFromStream(is);
 //...close stream


Hope this helps...

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ variable declared ^ nested loop ^ loop ^ outside ^ initialized ^ array ^ access </pattern>
		<template>
			
			You cannot.
			<delay>2</delay>
			You must declare the array outside the loop.
			<delay>2</delay>
			This may seem strange at first but what if the condition for the loop to run even once is never met?
			<delay>2</delay>
			How could you possibly then access an array which was never even created?

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ tobytearray () return null ^ would java ^ io ^ bytearrayoutputstream </pattern>
		<template>
			
			No, it never will.
			<delay>2</delay>
			It would never make sense to return null, and if you look at the implementation it definitely won't.
			<delay>2</delay>
			(I realize it's generally better to rely on the documented guarantees than the implementation, but I see no reason to suppose it would ever return null here.)


			<delay>2</delay>
			In particular, the documentation states:


  Creates a newly allocated byte array.



			<delay>2</delay>
			and


  Returns:
			<delay>2</delay>
			the current contents of this output stream, as a byte array.



			<delay>2</delay>
			Those wouldn't be correct if it returned null, would it?

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ getting values ^ saving ^ arraylists </pattern>
		<template>
			
			use Intent for passing value to another class(extends activity)
			<delay>2</delay>
			intentObj.putExtras() will help.


			<delay>2</delay>
			to put:

ArrayList&lt;String&gt; arrayList= new ArrayList&lt;String&gt;();
arrayList.add("hello");
arrayList.add("there");
Intent intent = new Intent(getApplicationContext(), secondClass.class);
        intent.putStringArrayListExtra("pass_list", arrayList);
        startActivity(intent);


to get

ArrayList&lt;String&gt; arrayList= getIntent().getStringArrayListExtra("pass_list");


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ move elements ^ java arraylist ^ java ^ file </pattern>
		<template>
			
			Make your class implement Serializable.


			<delay>2</delay>
			Open an ObjectOutputStream wrapping a FileOutputStream

write the entire List with writeObject()


			<delay>2</delay>
			close the ObjectOutputStream.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ specfic type ^ object prior ^ restrict ^ generic ^ arraylist ^ accept </pattern>
		<template>
			
			Write a wrapper function that accepts only the allowed type, and hide the collection.
			<delay>2</delay>
			That was standard best-practice pre-Java-5.


			<delay>2</delay>
			private final List strings = new ArrayList();

public void add(String s)
{
    strings.add(s);
}

public String remove(String s)
{
    return (String) strings.remove(s);
}

// etc...



			<delay>2</delay>
			Yes, this sucks.


			<delay>2</delay>
			Might I ask: is there a reason you're not using generics?
			<delay>2</delay>
			They are bytecode-compatible with Java 1.4

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ show text randomly chosen ^ pressed ^ list ^ button </pattern>
		<template>
			
			There is a simple solution for it.
			<delay>2</delay>
			You make use of the Random() class or you use Math.random() to iterate through your string as an array of characters.
			<delay>2</delay>
			Then you just choose random bits of it, until it's gone.


			<delay>2</delay>
			All you have to make sure of though, is that the arrays size is always checked so that you don't hit an OutOfBoundsException 

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ avoiding duplicate integers ^ integer array </pattern>
		<template>
			
			The solution depends on your requirement.
			<delay>2</delay>
			If you have a small array size (n&lt;10^6), scanning through the array on every insertion would suffice, but if you have a large array and frequent insertions, I would propose a different solution.


			<delay>2</delay>
			Scanning through an array on every insertion would require a complexity of O(n).
			<delay>2</delay>
			For small numbers, the overhead is ignorable, but as the size of array increases, traversal on every insertion is inefficient.


			<delay>2</delay>
			If you need performance and if memory is not your constraint, you can take a boolean array and initialize all elements to false.
			<delay>2</delay>
			Then whenever you get a number, make its index value in the boolean array to true, And while inserting, check whether the boolean value at the index number of the element being inserted.


			<delay>2</delay>
			Here is the code to initialize the boolean array
			<delay>2</delay>
			(initializing it would make all elements false):

boolean [] duplicateValuesArray = new boolean[Integer.MAX_VALUE];



			<delay>2</delay>
			Here is the function which inserts an element in the array:

    public void insertElement(int elementToBeInserted) {
        if(!duplicateValuesArray[elementToBeInserted])  //check if element already in array
            duplicateValuesArray[elementToBeInserted] = true;
            mainArray[index++] = elementToBeInserted;
    }



			<delay>2</delay>
			In this way, whenever you get a number, value for that index in the boolean array is set to true, and while insertion, everytime the index is checked, if value is true, that element exists in the array, do not insert it.


			<delay>2</delay>
			The complexity for this is much lower if you have a large mainArray
			<delay>2</delay>
			(n>10^6)
			<delay>2</delay>
			and you have frequent insertions.
			<delay>2</delay>
			This is because, initializing a boolean array is one time O(n) complexity, and after that, checking for the element in the boolean array and insertion of element is just O(1) operation, happens in constant time. 


			<delay>2</delay>
			Thus effective complexity is reduced to just initializing the boolean array.
			<delay>2</delay>
			And even in terms of memory footprint, I wouldn't mind because a boolean primitive just occupies one bit in the memory.


			<delay>2</delay>
			P.S
			<delay>2</delay>
			: Basically it is a memory vs performance trade off, and this is the Universal Computing Trade off, found everywhere.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ importing java ^ using ^ time ^ list ^ awt </pattern>
		<template>
			
			There is an ambiguity in the naming conventions of List in  class awt and util, so we can handle it in 2 ways:



			<delay>2</delay>
			Use import

import java.awt.*;

import java.util.List;

import java.util.*;
Use the full path, as mentioned in Head
			<delay>2</delay>
			First Java,"either use import or the full name"

java.util.List&lt;String&gt; list = new java.util.ArrayList&lt;String&gt;();


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java ^ create ^ classes ^ array </pattern>
		<template>
			
			Something like:

Class[] classes = new Class[] {Class1.class, Class2.class};



			<delay>2</delay>
			Though I'm not quite sure what your question is...

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ create 400 dimensional array ^ java </pattern>
		<template>
			
			You could use Array.newInstance, but:


  The number of dimensions of the new array must not exceed the number of array dimensions supported by the implementation (typically 255).



			<delay>2</delay>
			But I believe it would be better for you to create better abstractions for your domain.
			<delay>2</delay>
			Dealing with such an array would be difficult.
			<delay>2</delay>
			Maybe you can give more information about what you're trying to achieve so that a better answer can be provided.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ string [] array ^ double [] array ^ converting </pattern>
		<template>
			
			You'll need to create a target array of equal size to the original array, and iterate over it, converting element by element.


			<delay>2</delay>
			Example:

double[] d = { 2.0, 3.1 };
String[] s = new String[d.length];

for (int i = 0; i &lt; s.length; i++)
    s[i] = String.valueOf(d[i]);


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ android equivalent ^ tobytearray ^ org ^ ioutils ^ io ^ commons ^ apache </pattern>
		<template>
			
			Try Guava.
			<delay>2</delay>
			I haven't tested it but seems like it has what you need.
			<delay>2</delay>
			toByteArray is listed in their IO tools.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ adding elements ^ list ^ java ^ iterating </pattern>
		<template>
			
			You may use a ListIterator which has support for a remove/add method during the iteration itself.


			<delay>2</delay>
			ListIterator&lt;Book&gt; iter = books.listIterator();
while(iter.hasNext()){
    if(iter.next().getIsbn().equals(isbn)){
        iter.add(new Book(...));
    }
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ comes first ^ 2d array ^ rows ^ columns </pattern>
		<template>
			
			Java is considered "row major", meaning that it does rows first.
			<delay>2</delay>
			This is because a 2D array is an "array of arrays".


			<delay>2</delay>
			For example:  

int[ ][ ] a = new int[2][4];  // Two rows and four columns.

a[0][0] a[0][1] a[0][2] a[0][3]

a[1][0] a[1][1] a[1][2] a[1][3]



			<delay>2</delay>
			It can also be visualized more like this:

a[0] -&gt;  [0] [1] [2] [3]
a[1] -&gt;  [0] [1] [2] [3]



			<delay>2</delay>
			The second illustration shows the "array of arrays" aspect.
			<delay>2</delay>
			The first array contains {a[0] and a[1]}, and each of those is an array containing four elements, {[0][1][2][3]}.


			<delay>2</delay>
			TL;DR summary:

Array[number of arrays][how many elements in each of those arrays]



			<delay>2</delay>
			For more explanations, see also Arrays - 2-dimensional.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ retrieving elemnts ^ specifying ^ indexes ^ arraylist </pattern>
		<template>
			
			Yes you can use the subList method:

List&lt;...&gt; list2 = list1.subList(startIndex, endIndex);



			<delay>2</delay>
			This returns a view on that part of the original list, it does not copy the data.

			<delay>2</delay>
			If you want a copy:

List&lt;...&gt; list2 = new ArrayList&lt;...&gt; (list1.subList(startIndex, endIndex));


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ initialize array ^ possible ^ interface </pattern>
		<template>
			
			
  Simple question - Is it posible to initalize array in an interface?



			<delay>2</delay>
			Yes.


  
			<delay>2</delay>
			This works
			<delay>2</delay>
			but i want to initialize array by "for" intsruction.
			<delay>2</delay>
			Ok thanks for help 



			<delay>2</delay>
			That's not a simple question ;)


			<delay>2</delay>
			You can't do this strictly because you can't add a static block to an interface.
			<delay>2</delay>
			But you can have a nested class or enum.


			<delay>2</delay>
			IMHO, that could be more confusing than useful as follows:

public interface I {
    int[] values = Init.getValue();

    enum Init {;
        static int[] getValue() {
            int[] arr = new int[5];
            for(int i=0;i&lt;arr.length;i++)
                arr[i] = i * i;
            return arr;
        }
    }
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ convert string [] ^ set ^ list ^ java </pattern>
		<template>
			
			Arrays.asList() would do the trick here.


			<delay>2</delay>
			String[] words = {"ace", "boom", "crew", "dog", "eon"};   

List&lt;String&gt; wordList = Arrays.asList(words);  


For converting to Set, you can do as below

Set&lt;T&gt; mySet = new HashSet&lt;T&gt;(Arrays.asList(words)); 


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ converting byte [] ^ dom document ^ string </pattern>
		<template>
			
			You need a DocumentBuilder and to call parse() on it using an InputSource configured with the string of XML via a StringReader.


			<delay>2</delay>
			Don't call parse() directly with the string, since it'll interpret that string as a URI referencing the XML!

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ memory allocation ^ java ^ array </pattern>
		<template>
			
			There is no way of telling, since even using JNI insulates you from the actual implementation.


			<delay>2</delay>
			That being said, it is probably true that most practical implementations allocate array elements as contiguous internal blocks of memory.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ optimal way ^ sort ^ array </pattern>
		<template>
			
			When you have the the Power bring it to good use...
			<delay>2</delay>
			Why reinvent the wheel ???

Use  Arrays.sort() to sort the Array.


			<delay>2</delay>
			- If what you hold in the Array is some kind of object and it needs to be sorted in More than One way....
			<delay>2</delay>
			then first convert it in to a ArrayList (or List) using Arrays.asList(array)

Eg:

Song[] dog = new Song[10];
 ArrayList&lt;Song&gt; list = new ArrayList&lt;Song&gt;(Arrays.asList(arr));



			<delay>2</delay>
			Then use java.util.Comparator Interface, to sort the Object on basis of more than one attribute. 


			<delay>2</delay>
			Eg:
          
			<delay>2</delay>
			Class Song can be sorted on the basis of its track title or Singer and more using Comparator Interface.


			<delay>2</delay>
			- Using Collections are lot more flexible than Array.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java allows private string [][] var [] </pattern>
		<template>
			
			The code is the same as this:

private String[][][] var;



			<delay>2</delay>
			All these forms are equivalent:

private String[][][] var;
private String[][] var[];
private String[] var[][];
private String var[][][];



			<delay>2</delay>
			And they all mean the same: a three-dimensional array of strings.
			<delay>2</delay>
			The String var[][][] syntax may seem a bit weird, but it's like that for making C/C++ programmers feel right at home in Java (that's how you normally declare an array type in C/C++).


			<delay>2</delay>
			In Java, the String[][][] var syntax is preferred, as it makes clear that the type of var is String[][][], in the other syntax and its different variations the type information is split before and after the variable - although it's perfectly legal from the compiler's view point, it's harder to read.


			<delay>2</delay>
			Even weirder, all these method declarations are legal and equivalent:

String[][][] m()  {return null;}
String[][] m() [] {return null;}
String[] m() [][] {return null;}
String m() [][][] {return null;}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ 400 ints ^ array </pattern>
		<template>
			
			Do like below as you can do this kind of assignment during initialization only.


			<delay>2</delay>
			Also note, there is no dimension parameter required(allowed)
			<delay>2</delay>
			in this case

    int[] newArray = new int[]{8,2,22,97,38,15,0,40,0,75,4,5,7,78,52,12,50,77,91,8,49,49,99,40,17,81,18,57,60,87,17,40,98,43,69,48,4,56,62,0,81,49,31,73,55,79,14,29,93,71,40,67,53,88,30,3,49,13,36,65,52,70,95,23,4,60,11,42,69,24,68,56,1,32,56,71,37,2,36,91,22,31,16,71,51,67,63,89,41,92,36,54,22,40,40,28,66,33,13,80,24,47,32,60,99,3,45,2,44,75,33,53,78,36,84,20,35,17,12,50,32,98,81,28,64,23,67,10,26,38,40,67,59,54,70,66,18,38,64,70,67,26,20,68,2,62,12,20,95,63,94,39,63,8,40,91,66,49,94,21,24,55,58,5,66,73,99,26,97,17,78,78,96,83,14,88,34,89,63,72,21,36,23,9,75,0,76,44,20,45,35,14,0,61,33,97,34,31,33,95,78,17,53,28,22,75,31,67,15,94,3,80,4,62,16,14,9,53,56,92,16,39,5,42,96,35,31,47,55,58,88,24,0,17,54,24,36,29,85,57,86,56,0,48,35,71,89,7,5,44,44,37,44,60,21,58,51,54,17,58,19,80,81,68,5,94,47,69,28,73,92,13,86,52,17,77,4,89,55,40,4,52,8,83,97,35,99,16,7,97,57,32,16,26,26,79,33,27,98,66,88,36,68,87,57,62,20,72,3,46,33,67,46,55,12,32,63,93,53,69,4,42,16,73,38,25,39,11,24,94,72,18,8,46,29,32,40,62,76,36,20,69,36,41,72,30,23,88,34,62,99,69,82,67,59,85,74,4,36,16,20,73,35,29,78,31,90,1,74,31,49,71,48,86,81,16,23,57,5,54,1,70,54,71,83,51,54,69,16,92,33,48,61,43,52,1,89,19,67,48};


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ way ^ java ^ integers ^ initialize ^ enumeration ^ array </pattern>
		<template>
			
			Not using built-in language features.
			<delay>2</delay>
			You can easily write a method to do it, of course, but there's nothing built-in - and I suspect that it's sufficiently rarely useful that it's not in many third party utility libraries (such as Guava) either.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ detect special characters like ^ byte array </pattern>
		<template>
			
			If you don't use a fancy encoding all uppercase letters will have values from 65 to 90 and all lowercase letters are between 97 and 122.
			<delay>2</delay>
			(See ASCII Encoding).
			<delay>2</delay>
			All bytes with other values are not letters of the alphabet.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java array conversions ^ c ++ </pattern>
		<template>
			
			jshortArray convertShortArrayToJNI(JNIEnv* env, short* arr, size_t count) {
  jshortArray retval = env-&gt;NewShortArray(count);
  env-&gt;SetShortArrayRegion(retval,0,count,arr);
  return retval;
}



			<delay>2</delay>
			You don't need to free the retval.
			<delay>2</delay>
			It is a "local reference", which means that it will be freed by JVM as soon as you return through JNI from the recent call.
			<delay>2</delay>
			Unless you are calling it from a native thread, of course...

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ store three different objects ^ list array ^ java </pattern>
		<template>
			
			The best and also Object Oriented approach is to Create a class with surname, forename and result as attributes(instance variables) like below:

class Student{
private String surname;
private String forename;
private String result;
public Details(String surname, String forename, String res){
   //initialize properties here
  }
}


now, create a List which only accepts Student Object.


			<delay>2</delay>
			List&lt;Student&gt; list = new ArrayList&lt;Student&gt;();
list.add(new Student("surname", "forname", "pass"));


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ allowing certain values 0 ^ java ^ f ^ array ^ 9 </pattern>
		<template>
			
			You can restrict user to enter another value by this: (This program is for if You are taking values from user).
			<delay>2</delay>
			This will asks for number until you enter number within 0 to 9.


			<delay>2</delay>
			You can make your code according to this.
			<delay>2</delay>
			(This is just for your reference, How can you restrict user to enter wrong thing)

Scanner scan=new Scanner(System.in);
int i=-1;
i=scan.nextInt();
while(i&lt;=0 &amp;&amp; i&gt;=9){
    i=scan.nextInt();
}


EDIT


			<delay>2</delay>
			As per your comment, In that case you need to change this as:

String s="";
while(!s.matches("^[0-9A-F]+$")){
    s=scan.nextLine();
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ user input ^ fill ^ characters ^ array </pattern>
		<template>
			
			
  I googled it a lot and found nothing!
			<delay>2</delay>
			Could someone help me with
  filling an array of characters from user input, please?



			<delay>2</delay>
			My Google said, try this one..

Option 1 :

    import java.io.*;
   class array {

    public static void main(String args[]) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String tmp = br.readLine();
        int length = tmp.length();
        char c[] = new char[length];
        tmp.getChars(0, length, c, 0);
        CharArrayReader input1 = new CharArrayReader(c);
        int i;
        System.out.print("input1 is:");
        while ((i = input1.read()) != -1) {
            System.out.print((char) i);
        }

    }
}


Option 2:

class array
{
    public static void main(String args[])
    {
        Scanner sc=new Scanner(System.in);
        System.out.println("Please enter elements...");
        char[] a=sc.next().toCharArray();
        System.out.println("Array elements are : ");
        for (int i=0;i&lt;a.length;i++)
            System.out.println(a[i]);
    }
}



			<delay>2</delay>
			But, in this case, it won't accept after space character.


			<delay>2</delay>
			Before, start your coding in Java, you must know these terms :

BufferedReader

Exception handling

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ vice versa ^ short array ^ file ^ converting </pattern>
		<template>
			
			I really doubt if SHORT if possible.
			<delay>2</delay>
			Nevertheless, you can check out Apache Commons File Utils for reading file as byte[] and vice verse.


			<delay>2</delay>
			public static byte[] readFileToByteArray(File file) throws IOException


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ selected elements ^ select list ^ get number ^ multi ^ jlist </pattern>
		<template>
			
			JList.getSelectedIndices().length would give you the array length  :)
			<delay>2</delay>
			Refer Javadocs mate

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ convert string ^ java ^ integer ^ array </pattern>
		<template>
			
			From zvzdhk:

String[] array = "1,2,3,4,5".split(",");



			<delay>2</delay>
			Then, parse your integers:

int[] ints = new int[array.length];
for(int i=0; i&lt;array.length; i++)
{
    try {
        ints[i] = Integer.parseInt(array[i]);           
    } catch (NumberFormatException nfe) {
        //Not an integer 
    }
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ quick array conversion ^ c ++ ^ java </pattern>
		<template>
			
			You would do it like so:

int array[][3] = {{0,0,0},{1,0,0}};



			<delay>2</delay>
			Only the first dimension may be omitted.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ next row ^ dimensional array ^ array ^ values ^ two ^ strings ^ store </pattern>
		<template>
			
			If you absolutely have to use your two-dimensional array, then you will need nested loops to print it out.

for

for(int i=0; i &lt; FutureValueArray.length; ++i) {
   System.out.println("whatever you print before each row);
   for(int j=0; j &lt; utureValueArray[i]; ++j) {
      Sytem.out.print(utureValueArray[i][j] + "\t");
   }
}


for each

for(String[] row : FutureValueArray) {
   System.out.println("whatever you print before each row);
   for(String cell : row) {
      Sytem.out.print(cell + "\t"); 
   }
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ hash table size setting </pattern>
		<template>
			
			No, you don't.
			<delay>2</delay>
			A quality implementation (Hashtable/HashMap) will resize itself automatically as the number of elements increases.


			<delay>2</delay>
			If you are talking about your own implementation, the answer depends on whether the hash table is capable of increasing the number of buckets as its size grows.


			<delay>2</delay>
			If you are worried about the performance implications of the resizing, the correct approach is to profile this in the context of your overall application.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java arraylist use binary search ^ contains () method </pattern>
		<template>
			
			No, you need to use Collections to use binary search, usually after sorting it.  
			<delay>2</delay>
			An ArrayList doesn't know anything about its ordering, and you have to know a list is sorted before you can use binary search.


			<delay>2</delay>
			Alternately, you could use TreeSet, which is as efficient as using a binary search.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ allocate space ^ 5 things ^ write ^ array </pattern>
		<template>
			
			You can do it like this:

private Object[] myObjects = new Object[5];


Change the type as needed.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ user ^ name ^ java ^ get ^ array </pattern>
		<template>
			
			Normally you can't change the name of a variable (be it an array, or any other data type) after you've defined it, it's set in stone in the source code of the program.
			<delay>2</delay>
			Perhaps you meant something else?

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ string array ^ storing values ^ variables ^ java </pattern>
		<template>
			
			If you want to access any of the words in the array, then you can do so.
			<delay>2</delay>
			You do not need to give them all variable names.
			<delay>2</delay>
			For instance, say you have your words array.

			<delay>2</delay>
			To print the 3rd word in the word array to the console:

System.out.println(words[2]);



			<delay>2</delay>
			Noting that the first element in an array is element 0.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ maximum value ^ find ^ array </pattern>
		<template>
			
			Have a max int and set it to the first value in the array.
			<delay>2</delay>
			Then in a for loop iterate through the whole array and see if the max int is larger than the int at the current index.


			<delay>2</delay>
			int max = array.get(0);

for (int i = 1; i &lt; array.length; i++) {
    if (array.get(i) &gt; max) {
      max = array.get(i);
    }
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ methods like jni getdoublearrayelements set iscopy ^ true ^ false </pattern>
		<template>
			
			I think it's more a matter of which JVM implementation does copying and which does pinning, not what runtime conditions might determine that choice, although I can certainly imagine that say an object in permgen space might be more amenable to being pinned than a brand new one.


			<delay>2</delay>
			The decision is the JVM's, not yours.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ print list ^ buffered image ^ java </pattern>
		<template>
			
			In case of printing several graphics images, one per page, use the page index to iterate through these pages and print one on each page.
			<delay>2</delay>
			For example, if several images are represented in the following array:

BufferedImage[] images = new BufferedImage[10];


then use the print() method as shown in the following code fragment:

public int print(Graphics graphics,
           PageFormat pageFormat, int pageIndex)
           throws PrinterException {

    if (pageIndex &lt; images.length) {
        graphics.drawImage(images[pageIndex], 100, 100, null);
        return PAGE_EXISTS;
    } else {
        return NO_SUCH_PAGE:
    }
}



			<delay>2</delay>
			If the document is continuous, the application must calculate how much content can fit on each page, and break the page at that point.
			<delay>2</delay>
			If text document consists of many lines, then an application must calculate how many of these lines can fit entirely on a page.
			<delay>2</delay>
			The Point class creates a point representing a location in (x,y)


			<delay>2</delay>
			To calculate the height of a single line of text, use the FontMetrics class.


			<delay>2</delay>
			Font font = new Font("Serif", Font.PLAIN, 10);
FontMetrics metrics = graphics.getFontMetrics(font);
int lineHeight = metrics.getHeight();



			<delay>2</delay>
			The PageFormat parameter describes the printable area of the page.
			<delay>2</delay>
			In particular, to find the vertical span of the page use the following code fragment:

double pageHeight = pageFormat.getImageableHeight();


Use the following code fragment to calculate the number of lines that fit on a page and the number of page breaks:

int linesPerPage = ((int)pageHeight)/lineHeight);
int numBreaks = (textLines.length-1)/linesPerPage;
int[] pageBreaks = new int[numBreaks];
for (int b=0; b &lt; numBreaks; b++) {
    pageBreaks[b] = (b+1)*linesPerPage; 
}



			<delay>2</delay>
			Use the print() method to calculate the printable area for the following reasons:


			<delay>2</delay>
			Text measurement depends on the FontRenderContext and this is implicit in the FontMetrics object returned by the printer graphics which is not available except inside the print() method.

			<delay>2</delay>
			The page format may not be disclosured until printing occurs.
			<delay>2</delay>
			Since if the user selected a landscape mode in the print dialog, then this setting needs to be accounted for.
			<delay>2</delay>
			The PageFormat object passed into the print() method provides this information.

			<delay>2</delay>
			The page break positions are used as represented in the following code fragment:

/* Draw each line that is on this page.
 * Increment 'y' position by lineHeight
 * for each line.
 */
int y = 0; 
int start = (pageIndex == 0) ? 0 : pageBreaks[pageIndex-1];
int end   = (pageIndex == pageBreaks.length)
                 ? textLines.length : pageBreaks[pageIndex];
for (int line=start; line&lt;end; line++) {
    y += lineHeight;
    g.drawString(textLines[line], 0, y);
}



			<delay>2</delay>
			If a document contains 100 lines and only 48 lines fit on a page, then an application prints 3 pages with page breaks after 48 and 96 lines of text.
			<delay>2</delay>
			The remaining 4 lines are printed on the last page.
			<delay>2</delay>
			The complete code for this example is in PaginationExample.java.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ getting top 3 highest values ^ arraylist </pattern>
		<template>
			
			List&lt;Integer&gt; list;
Collections.sort(list);
List&lt;Integer&gt; top3 = new ArrayList&lt;Integer&gt;(list.subList(list.size() -3, list.size()));



			<delay>2</delay>
			I could have simply used the subList, but the list returned from subList() is a view on the base list, so changes made there would be reflected in top3.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ learn ^ important ^ arrays ^ arraylists </pattern>
		<template>
			
			Check out this comparison.


			<delay>2</delay>
			As you can see, there are important differences between the two constructs.
			<delay>2</delay>
			You'll find APIs using one or the other (or both), and you have to understand the pros/cons and the functional differences between the two.


			<delay>2</delay>
			One particular difference is that a native array can store primitives without the inefficiencies of boxing/unboxing.
			<delay>2</delay>
			That's significant when you have sizeable arrays representing data streams / data sets.


			<delay>2</delay>
			Note also that an ArrayList is not covariant.
			<delay>2</delay>
			That is, an Integer[] is a Number[], but an ArrayList&lt;Integer&gt; is not a ArrayList&lt;Number&gt;.
			<delay>2</delay>
			See here for more details.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ string array ^ string ^ split </pattern>
		<template>
			
			String[] array = arr.split("\\n");


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ adding values ^ syntax ^ arraylist ^ array </pattern>
		<template>
			
			int[] row = list.get(rowNumber);
row[columnNumber] = value;


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ array copy method ^ class system </pattern>
		<template>
			
			It's there for historical reasons: it's there since JDK 1.0, while the Java class Arrays where this method logically belongs has not been introduced until Java 1.2 release.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ primitives array ^ perform sorting ^ java library ^ custom comparator </pattern>
		<template>
			
			You can use Comparator on the Objects only.
			<delay>2</delay>
			You can't on the primitive types.

			<delay>2</delay>
			By using ArrayUtils class you can convert primitive array to wrapper and vice-versa .

			<delay>2</delay>
			So Use Apache Commons ArrayUtils class.  


			<delay>2</delay>
			Integer objectArray = ArrayUtils.toObject(array);   
Arrays.sort(objectArray,new MyComparator());
int[] sortedArray = ArraysUtils.toPrimitive(objectArray);


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ convert byte array ^ bytearrayoutputstream </pattern>
		<template>
			
			byte[] bytes = ....;
ByteArrayOutputStream baos = new ByteArrayOutputStream(bytes.length);
baos.write(bytes, 0, bytes.length);


Method description:


  Writes len bytes from the specified byte array starting at offset off to this byte array output stream.


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ integer array values ^ sort ^ smallest ^ largest ^ function </pattern>
		<template>
			
			Very easy:

int[] intarray;
// ...
Arrays.sort(intarray);



			<delay>2</delay>
			If you have a List instead:

List&lt;Integer&gt; numbers;
// ...
Collections.sort(numbers);


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ edit elements ^ class type ^ java ^ array </pattern>
		<template>
			
			Object[] myArray = new Object7;

			<delay>2</delay>
			Object myObject = myArray[5]; // get object at index 5 then make changes to your object

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ text file ^ string array ^ put </pattern>
		<template>
			
			Please refer to this article: 

http://www.mkyong.com/java/how-to-read-file-from-java-bufferedreader-example/

specifically:

    BufferedReader br = null;

    try {

        String sCurrentLine;

        br = new BufferedReader(new FileReader("C:\\testing.txt"));

        while ((sCurrentLine = br.readLine()) != null) {
            System.out.println(sCurrentLine);
        }

    } catch (IOException e) {
        e.printStackTrace();
    } 


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ accepts objects ^ type ^ need ^ arraylist ^ array </pattern>
		<template>
			
			List&lt;Object&gt; array = new ArrayList&lt;Object&gt;();



			<delay>2</delay>
			Each class is of the type object, so this should do it.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ start iterating ^ set index ^ arraylist </pattern>
		<template>
			
			There are many ways to do this.
			<delay>2</delay>
			In this examples I assume your list holds Integers.



			<delay>2</delay>
			You can use ListIterator 

ListIterator&lt;Integer&gt; it = list.listIterator(100);
while (it.hasNext()) {
    System.out.println(it.next());
}


or with for (to keep iterator scoped inside loop)

for (ListIterator&lt;Integer&gt; lit = list.listIterator(100); lit.hasNext();) {
    System.out.println(lit.next());
}

or normal for loop but start from i=100

for (int i=100; i&lt;list.size(); i++){
    System.out.println(list.get(i));
}

or just create subList and iterate over it
			<delay>2</delay>
			like you normally do

for (Integer i : list.subList(100, list.size())){
    System.out.println(i);
}



			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ converting boolean array ^ binary java ^ method </pattern>
		<template>
			
			If you want to serialize boolean array, check this: How to convert boolean array to binary and vice versa in Java?


			<delay>2</delay>
			If you want to use bits instead of booleans, check BitSet class: http://docs.oracle.com/javase/7/docs/api/java/util/BitSet.html


  
			<delay>2</delay>
			This class implements a vector of bits that grows as needed.
			<delay>2</delay>
			Each
  component of the bit set has a boolean value.
			<delay>2</delay>
			The bits of a BitSet are
  indexed by nonnegative integers.
			<delay>2</delay>
			Individual indexed bits can be
  examined, set, or cleared.
			<delay>2</delay>
			One BitSet may be used to modify the
  contents of another BitSet through logical AND, logical inclusive OR,
  and logical exclusive OR operations.
  
  
			<delay>2</delay>
			By default, all bits in the set initially have the value false.



			<delay>2</delay>
			You can use these methods:

BitSet#set(int) to set the bit to true at specified position.

			<delay>2</delay>
			BitSet#clear(int) to set the bit to false at specified position.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ random values generating </pattern>
		<template>
			
			You need to use the array index to fetch the value. 


			<delay>2</delay>
			Just as you are storing the value in the array using indexes using petName[i] = JOptionPane.showInputDialog("What is your pet called?");, you need to retrieve values from the array using  Use petName[index]

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ imageicon array ^ declare </pattern>
		<template>
			
			Say like this:

ImageIcon[][] arr = new ImageIcon[10][5];


Note that after this line, the array elements will be uninitialized (they will be all equal to null).


			<delay>2</delay>
			If you want to initialize them, you need to loop through your array and call some of the ImageIcon constructors e.g.

arr[i][j] = new ImageIcon();


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ compare int ^ placed ^ array </pattern>
		<template>
			
			Use a Set&lt;Integer&gt;, duplicates will not be stored.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ certain string ^ array list ^ remove ^ names </pattern>
		<template>
			
			Get the index of the newly added element.  
			<delay>2</delay>
			Use this index to get a sublist and pass the sublist to the removeAll method:

Removing

//addition = newly added String     
list.removeAll(new ArrayList&lt;String&gt;(list.subList(0,list.indexOf(addition))));


Full Example

public class ArrayListSortDelete {
    public static void main(String[] args) {
        String addition = "BB";
        List&lt;String&gt; list = new ArrayList(Arrays.asList(new String[] { "A", "B", "C", "D" }));
        list.add(addition);
        Collections.sort(list);

        System.out.println("Before");
        for (String s : list) {
            System.out.println(s);
        }

            //new ArrayList&lt;String&gt;() avoids concurrent modification.
        list.removeAll(new ArrayList&lt;String&gt;(list.subList(0,list.indexOf(addition))));

        System.out.println("After:");
        for (String s : list) {
            System.out.println(s);
        }

    }

}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ one class point ^ another class ^ make ^ java ^ arraylist </pattern>
		<template>
			
			Pass the arraylist in constructor of another class. 

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ get (- 1 ^ python though ^ last element ^ use arraylist ^ get ^ arraylist ^ works ^ java </pattern>
		<template>
			
			If you want that behaviour:

List&lt;T&gt; snake = new ArrayList&lt;&gt;(){
    @Override
    public T get(int i) {
        return super.get((i + size()) % size());
   }
};



			<delay>2</delay>
			This will work for any value of i.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java check position ^ empty ^ array ^ "" </pattern>
		<template>
			
			String array[] = new String {" ", "hi", "there", " ", "how"};


use a for cicle:

int empty
for(int i=0; i&lt;=array.length(); i++){
    if(array[i].equals(" ") || array[i].equals("")){
        empty++;
    }
}
System.out.println("empty values: " + empty);


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ generically typed arrays ^ suppression problems </pattern>
		<template>
			
			It's because arrays generally don't go well with generic types.
			<delay>2</delay>
			The most common way people handle data structures with generic types is to use Lists. 


			<delay>2</delay>
			So for example, you would create a List&lt;T&gt; object rather than an array.
			<delay>2</delay>
			One reason why arrays don't go well with generics and gives you the type safety warning is because arrays are co-variant:
			<delay>2</delay>
			meaning that they can contain sub-types. 


			<delay>2</delay>
			For example, an array of objects can contain longs and ints, which would fail at run-time when you tried to call items from the array.
			<delay>2</delay>
			With Lists, it prevents you from inserting subtypes at compile time that could cause your code to fail at run-time. 


			<delay>2</delay>
			So a rule of thumb would be to use a List instead of an array, but if you're really intent on using arrays and are sure that you will not be inserting any sub-types into the array, then you can add the line @SuppressWarnings("unchecked") above the line that you gave.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ searching ^ list </pattern>
		<template>
			
			You are comparing the whole array A with the string.


			<delay>2</delay>
			try comparing the individual elements.


			<delay>2</delay>
			if (A[compCount -1].equals(animal)) {
  System.out.println("String " + animal + " was found using " + compCount + " comparisions.");
  break;
 }


Also note that you should break after printing.


			<delay>2</delay>
			Also it would be better still to use equalsIgnoreCase

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java replacing char ^ index </pattern>
		<template>
			
			You could accomplish this by using substring() to pick apart and recreate the string, but another way is to just convert it to a char[] and operate on that, e.g.:

char[] data = captureString[0].toCharArray();
data[strOneRand] = Character.toUpperCase(data[strOneRand]); // or whatever
String outputFinal = new String(data);



			<delay>2</delay>
			An example of accomplishing this with substring() can be found in the accepted answer of Replace a character at a specific index in a string?.
			<delay>2</delay>
			An example of doing it with a StringBuilder can be found there as well.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ arraylist index calculation java </pattern>
		<template>
			
			Without actual code:


iterate thorough the array 
count the 1s you found 
if you found a 0 then start over the count 

			<delay>2</delay>
			check after increasing the counter: if the counter reaches 3 then return with true 
if you reached the end of the array and no more elements then return with false


Something like this
			<delay>2</delay>
			, I hope I could help.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java 8 stream ^ convert ^ array </pattern>
		<template>
			
			The easiest method is to use the toArray(IntFunction&lt;A[]&gt; generator) method with an array constructor reference.
			<delay>2</delay>
			This is suggested in the API documentation for the method.


			<delay>2</delay>
			String[] stringArray = stringStream.toArray(String[]::new);



			<delay>2</delay>
			What it does is find a method that takes in an integer (the size) as argument, and returns a String[], which is exactly what (one of the overloads of) new String[] does.


			<delay>2</delay>
			You could also write your own IntFunction:

Stream&lt;String&gt; stringStream = ...;
String[] stringArray = stringStream.toArray(size -&gt; new String[size]);



			<delay>2</delay>
			The purpose of the IntFunction&lt;A[]&gt; generator is to convert an integer, the size of the array, to a new array.


			<delay>2</delay>
			Example code:

Stream&lt;String&gt; stringStream = Stream.of("a", "b", "c");
String[] stringArray = stringStream.toArray(size -&gt; new String[size]);
Arrays.stream(stringArray).forEach(System.out::println);


Prints:

a
b
c


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ two different types ^ within java ^ multidimensional arrays </pattern>
		<template>
			
			In Java, this is normally done with a class.


			<delay>2</delay>
			class C {
public String name;
public int num;
}


(later)

C[] myArray = new C[5];
myArray[3] = new C();
myArray[3].name = "Ford";
myArray[3].num = 42;


name and num should typically be made private and accessed with getters and setters, but this is beyond the point.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ arraylist construct ^ capacity ^ array </pattern>
		<template>
			
			This will not compile since the element type cannot be a primitive.
			<delay>2</delay>
			Use Integer instead.


			<delay>2</delay>
			new ArrayList&lt;Integer&gt;(20); will create a list backed by an array with an initial capacity of 20.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ 2d char arrays ^ 2d array ^ create </pattern>
		<template>
			
			That seems complicated … but still, this is how:

char[][][][] board = new char[3][3][3][3];



			<delay>2</delay>
			This sounds like a Sudoku board.
			<delay>2</delay>
			It'd be much, much easier if you defined a 9x9 2D char array, taking care of iterating over the right zones whenever you have to (simply by controlling the looping variables).
			<delay>2</delay>
			Trust me, thinking in terms of a 4D array is gonna be a headache.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ remove items ^ 20 characters ^ smaller ^ array </pattern>
		<template>
			
			Arrays in Java are fixed-size, just like in C. You can't remove an item from it, you can only update its value.
			<delay>2</delay>
			The value can also be null, which may serve your purpose.


			<delay>2</delay>
			However, it is not advised to use arrays for your use case; instead use a List implementation.
			<delay>2</delay>
			ArrayList is the default choice and a LinkedList
			<delay>2</delay>
			may make sense for a huge amount of additions and deletions in the middle of the list.


			<delay>2</delay>
			With Java 8, the best approach is to use the Streams API:

List&lt;String&gt; withLongStringsDiscarded = 
   myStringList.stream().filter(s -&gt; s.length() &lt;= 20).collect(Collectors.toList());


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ enum array using reflection ^ find ^ field </pattern>
		<template>
			
			First check if the field is an array with field.getType().isArray(), and then check that the array component type is an enum with field.getType().getComponentType().isEnum()

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ object array ^ much memory ^ java ^ initializing ^ allocated </pattern>
		<template>
			
			Java always knows exactly how big each element of the array is going to be, because Java has only two kinds of arrays: arrays of primitives or arrays of object references.


			<delay>2</delay>
			If it's an array of primitives (int, long, etc.)
			<delay>2</delay>
			it's the size of the primitive; and if it's an array of objects then it's the size of references to objects (pointers).

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java array string [] name ^ string name [] </pattern>
		<template>
			
			It's the same thing, both works but the second one is discouraged.

			<delay>2</delay>
			The first one:

String[] myStringArray;


Is the default and the most used.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ array subscript ^ use ^ java ^ enum </pattern>
		<template>
			
			Here's the code.
			<delay>2</delay>
			It doesn't look like good practice, though.


			<delay>2</delay>
			int[] x = new int[EnumClass.values().length];



			<delay>2</delay>
			You can then access the element by ordinal()

int val = x[enumVar.ordinal()];



			<delay>2</delay>
			Still doesn't look like good practice.


			<delay>2</delay>
			Consider using Map&lt;EnumClass, AtomicInteger&gt; like EnumMap&lt;EnumClass, AtomicInteger&gt;.
			<delay>2</delay>
			Why atomic integer?
			<delay>2</delay>
			because it can have it's value modified instead of assigning a new instance all the time (at the cost of possibly unnecessary synchronization).
			<delay>2</delay>
			That's a different issue though.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ store ^ possible ^ file ^ bytes ^ array </pattern>
		<template>
			
			yes, you can use IOUtils.toByteArray(InputStream input)
 to store it. 


			<delay>2</delay>
			also, if its a big file, you can increase java heap space by executing it with vm arguments:

java -Xmx6g myprogram


or

java -jar -Xmx6g myprogram.jar


the 6g means 6 Gigabytes of heap

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ second row ^ first row ^ array point ^ make ^ c </pattern>
		<template>
			
			In C/C++, one declares a two dimensional array the same as in JAVA, but the memory allocation by the compiler is different.  
			<delay>2</delay>
			E.g., in C one declares a two-dimensional array of int as a contiguous block of memory.


			<delay>2</delay>
			int a[][]=new int[2][4]  


is allocated as contiguous block of 32(2*4*4)bytes.
			<delay>2</delay>
			It has only only one reference pointing to the block beginning.
			<delay>2</delay>
			If you want to access an element at (i,j) then it returns the value at reference a+(i*2+j).


			<delay>2</delay>
			But in java it allocates a array of 2 pointers and allocates each row again.


			<delay>2</delay>
			a= new int[2][];
a[0] = new int[4];
a[1] = new int[4];



			<delay>2</delay>
			So you can modify the references for each row.


			<delay>2</delay>
			But in C++ also you can achieve the JAVA behavior by using the following code.


			<delay>2</delay>
			int **a = new int*[2];
a[0] = new int[4];
a[1] = new int[4];
a[0] = a[1];



			<delay>2</delay>
			If you need in C you should be able to do the same thing with malloc.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ 3 )/ 2 ^ new capacity ^ oldcapacity ^ arraylist ^ 1 </pattern>
		<template>
			
			Resizing the array is a relatively expensive operation.
			<delay>2</delay>
			It wants to try and make sure that if the method gets called with ensureCapacity(11), ensureCapacity(12), ensureCapacity(13), ... it should not have to resize the array every time.
			<delay>2</delay>
			So it resizes by a reasonable chunk (increase by 50%) instead of the minimum specified.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ plural ^ java ^ class ^ arrays </pattern>
		<template>
			
			The Utility classes which deals with Arrays, Files, Paths, Objects or Collections are plural.
			<delay>2</delay>
			Exactly because they are not an Array or a Collection but rather a number of utility functions to work on them.
			<delay>2</delay>
			You can even see that in the Javadoc intro:


  This class contains various methods for manipulating arrays



			<delay>2</delay>
			Some of those classes are fairly new additions in 1.7.
			<delay>2</delay>
			So this explains their common naming convention.
			<delay>2</delay>
			I am not sure if there is a written conventions for it, but it is surely a practical one.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ printwrite always overwriting file </pattern>
		<template>
			
			Use append mode:

FileWriter output = new FileWriter("result.txt", true);
PrintWriter write = new PrintWriter(new BufferedWriter(output));


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ matrix ^ java ^ filling </pattern>
		<template>
			
			int [][] matrix = new int[10][20];
for(int i = 0; i &lt; 10; i++) {
    for(int j = 0; j &lt; 20; j++) {
        // read information from somewhere
        matrix[i][j] = information;
    }
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ copyonwritearraylist different ^ unmodifiablelist ^ iterating </pattern>
		<template>
			
			The javadoc of CopyOnWriteArrayList states


  A thread-safe variant of ArrayList in which all mutative operations
  (add, set, and so on) are implemented by making a fresh copy of the
  underlying array.



			<delay>2</delay>
			While the javadoc of Collections#unmodifiableList(List) states


  Returns an unmodifiable view of the specified list.
			<delay>2</delay>
			This method allows
  modules to provide users with "read-only" access to internal lists.
  
  
			<delay>2</delay>
			Query operations on the returned list "read through" to the specified
  list, and attempts to modify the returned list, whether direct or via
  its iterator, result in an UnsupportedOperationException.



			<delay>2</delay>
			So, no, you can't get the features provided by CopyOnWriteArrayList with a List returned by Collections#unmodifiableList(List).

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ completly random spot ^ new integer ^ dimensional array ^ array ^ place ^ integers ^ 2 </pattern>
		<template>
			
			static void placeRandomly2D(int[][] arr, int limit) {
// generates value [0...limit) half-interval and places it into the 2D array arr
//    at random position; limit must be positive
    Random rand = new Random();
    int value = rand.nextInt(limit);
    int pos1 = rand.nextInt(arr.length);
    int pos2 = rand.nextInt(arr[pos1].length);
    arr[pos1][pos2] = value;
}



			<delay>2</delay>
			And, just in case, version for 1-dimensional array:

static void placeRandomly1D(int[] arr, int limit) {
// generates value [0...limit) half-interval and places it into the 1D array arr
//    at random position; limit must be positive
    Random rand = new Random();
    int value = rand.nextInt(limit);
    int pos = rand.nextInt(arr.length);
    arr[pos] = value;
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ stores strings ^ java ^ integers ^ creating ^ array </pattern>
		<template>
			
			An Object[] can hold both String and Integer objects.  
			<delay>2</delay>
			Here's a simple example:


			<delay>2</delay>
			    Object[] mixed = new Object[2];
    mixed[0] = "Hi Mum";
    mixed[1] = Integer.valueOf(42);
    ...
    String message = (String) mixed[0];
    Integer answer = (Integer) mixed[1];


However, if you put use an Object[] like this, you will typically need to use instanceof and / or type casts when accessing the elements.


			<delay>2</delay>
			Any design that routinely involves instanceof and/or type casts needs to be treated with suspicion.  
			<delay>2</delay>
			In most cases, there is a better (more object-oriented, more efficient, less fragile) way of achieving the same ends.


			<delay>2</delay>
			In your particular use-case, it sounds like what you really need is a mapping object that maps from String (names) to Integer (numbers of stocks).  
			<delay>2</delay>
			And the nice thing about Java is that there are existing library classes that provide this functionality;
			<delay>2</delay>
			e.g. the Object[]0 class, with Object[]1 as the key type and Object[]2 as the value type.


			<delay>2</delay>
			Another possibility might be an array, Object[]3 or Object[]4 of some custom or generic pair class.  
			<delay>2</delay>
			These have different semantic properties to Object[]5 types.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ object arrays ^ convert list ^ list ^ objects ^ java </pattern>
		<template>
			
			No, there's no method that does this directly for you.
			<delay>2</delay>
			You can write a nested for loop or use the flatMap of the stream API as follows:

List&lt;Object&gt; flat = objArrs.stream()
                           .flatMap(Stream::of)
                           .collect(Collectors.toList());


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ byte array back ^ byte array ^ video ^ parse ^ convert </pattern>
		<template>
			
			I'm not sure that you will reduce a video's size by putting each byte into an array.


			<delay>2</delay>
			If I have a video that is 4,000 bytes then you will have an array of exactly 4,000 bytes (including all of the overhead of the array itself in memory).


			<delay>2</delay>
			There is a method on a ParseFile object called .getData() that will return a byte[] array.  
			<delay>2</delay>
			So if you have a video stored in Video class in the data column you can do something like this:

byte[] bytes_of_video = videoObject.getParseFile("data").getBytes();


			<delay>2</delay>
			Now you have a byte array of the video object but the byte array will be just as big as the video file since no compression took place.  
			<delay>2</delay>
			If you want to compress the video file you can use Android's zlib compression with Deflater:

byte[] originalBytes = bytes_of_video;

     Deflater deflater = new Deflater();
     deflater.setInput(originalBytes);
     deflater.finish();

     ByteArrayOutputStream baos = new ByteArrayOutputStream();
     byte[] buf = new byte[8192];
     while (!deflater.finished()) {
         int byteCount = deflater.deflate(buf);
         baos.write(buf, 0, byteCount);
     }
     deflater.end();

     byte[] compressedBytes = baos.toByteArray();



			<delay>2</delay>
			I don't know if you are wanting to save space on the server or on the device but to save bandwidth costs you could store the compressed video data in your ParseFile object in the server and then decompress the file on the device when it's ready to be viewed/used.  
			<delay>2</delay>
			But a compressed video file on the device is not very useful since you won't be able to view/edit
			<delay>2</delay>
			/use it while it's in a compressed format.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ apply lowercase ^ hive ^ array </pattern>
		<template>
			
			If your use case is that you are transforming an array in isolation (not as part of a table), then the combination of explode, lower, and collect_list should do the trick.  
			<delay>2</delay>
			For example (please pardon the horrible execution times, I'm running on an underpowered VM):

hive&gt; SELECT collect_list(lower(val))
    &gt; FROM (SELECT explode(array('AN', 'EXAMPLE', 'ARRAY')) AS val) t;
...
... Lots of MapReduce spam
...
MapReduce Total cumulative CPU time: 4 seconds 10 msec
Ended Job = job_1422453239049_0017
MapReduce Jobs Launched: 
Job 0: Map: 1  Reduce: 1   Cumulative CPU: 4.01 sec   HDFS Read: 283 HDFS Write: 17 SUCCESS
Total MapReduce CPU Time Spent: 4 seconds 10 msec
OK
["an","example","array"]
Time taken: 33.05 seconds, Fetched: 1 row(s)


(Note:  Replace array('AN', 'EXAMPLE', 'ARRAY') in the above query with whichever expression
			<delay>2</delay>
			you are using to generate the array.


			<delay>2</delay>
			If instead your use case is such that your arrays stored in a column of a Hive table and you need to apply the lowercase transformation to them, to my knowledge
			<delay>2</delay>
			you have two principle options:

Approach #1:  
			<delay>2</delay>
			Use the combination of explode and LATERAL VIEW to separate the array.  
			<delay>2</delay>
			Use lower to transform the individual elements, and then collect_list to glue them back together.  
			<delay>2</delay>
			A simple example with silly made-up data:

explode0

Approach #2:  Write a simple UDF to apply the transformation.  
			<delay>2</delay>
			Something like:

explode1


			<delay>2</delay>
			And then invoke the UDF directly on the data:


			<delay>2</delay>
			explode2


			<delay>2</delay>
			There are some trade-offs between the two approaches.  
			<delay>2</delay>
			#2 will probably be more efficient at runtime in general than #1, since the explode3 clause in #1 forces a reduction stage while the UDF approach does not.  
			<delay>2</delay>
			However, #1 does everything in HiveQL and is a bit more easily generalized (you can replace explode4 with some other kind of string transformation in the query if you needed to).  
			<delay>2</delay>
			With the UDF approach of #2, you potentially have to write a new UDF for each different kind of transformation you want to apply.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ strings sizes ^ string based ^ sorting ^ length ^ array </pattern>
		<template>
			
			In Java 8, this can be done in one line,

Arrays.sort(randomString, (s1,s2) -&gt; Integer.compare(s1.length(), s2.length()));



			<delay>2</delay>
			If you want reverse order (higher-length to lower-length),

change it to, 

Arrays.sort(randomString, (s1,s2) -&gt; Integer.compare(s2.length(), s1.length()));



			<delay>2</delay>
			Another approach,

use Comparator.comparing(String::length),

Arrays.sort(yourArray, Comparator.comparing(String::length)); 


to reverse the order,

Arrays.sort(yourArray, Comparator.comparing(String::length).reversed()); 


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java ^ inheritance ^ arraylist </pattern>
		<template>
			
			List&lt;Parent&gt; listValue = new ArrayList&lt;Parent&gt;();
listValue.add(new Child1());
listValue.add(new Child2());



			<delay>2</delay>
			Both Child1
			<delay>2</delay>
			and Child2 are inherited from "Parent" Class.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ biggest variable ^ return ^ method ^ define ^ array </pattern>
		<template>
			
			You could do something like:

Integer array[] = {1, 4, 3, 2};
int max = Collections.max(Arrays.asList(array));
System.out.println(max);
Output:
4


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ two dimensional array ^ single dimensional array ^ subarray ^ reference ^ java </pattern>
		<template>
			
			If I understood question correctly, this is it

    int a[][] = {{1,1,1},{2,2,2}, {3,3,3}};
    int[] a2 = a[2];


,

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ delete index ^ possible ^ java ^ array </pattern>
		<template>
			
			Just assign the blank space to the position of the character you want to replace -
			<delay>2</delay>
			it's not a real deletion, an array in Java is of fixed length (it can't be resized):

array[index] = ' ';


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ newinstance () method ^ arraylist class </pattern>
		<template>
			
			Method newInstance() belongs to the class called Class.
			<delay>2</delay>
			Javadoc:


  Creates a new instance of the class represented by this Class object.
			<delay>2</delay>
			The class is instantiated as if by a new expression with an empty argument list.



			<delay>2</delay>
			So these two are equivalent:

ArrayList a = new ArrayList();
ArrayList b = ArrayList.class.newInstance();



			<delay>2</delay>
			You can do this for every class, but it is not recommended because you lose compile-time safety (it may fail at run-time if there is no no-arg constructor) and cannot track usages.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ element stored ^ integer ^ compare ^ arraylist </pattern>
		<template>
			
			You should consider using ArrayList.contains()

ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
// populate your list here
Integer i = 1;
System.out.println(list.contains(i));



			<delay>2</delay>
			You have to autobox primitive int type into Integer since ArrayList&lt;T&gt; uses generics and they don't allow to use primitive types.


			<delay>2</delay>
			EDITED for purists.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ array thread safely ^ java ^ access </pattern>
		<template>
			
			You will not get an invalid state when changing arrays using multiple threads.
			<delay>2</delay>
			However if a certain thread has edited a value in the array, there is no guarantee that another thread will see the changes.
			<delay>2</delay>
			Similar issues occur for non-volatile variables.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ two statements ^ java ^ difference </pattern>
		<template>
			
			The only difference is that the first statement works only when the array variable is declared, while the second can be written separately from the declaration :

int[] X;
int[] Y;
X = {1,2,3}; // doesn't work
Y = new int[] {1,2,3}; // works


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java declaring ^ difference ^ array </pattern>
		<template>
			
			From Oracle Java documentation

Declaring a Variable to Refer to an Array

Declare an array (named anArray) with the following line of code:

// declares an array of integers
int[] anArray;


Like declarations for variables of other types, an array declaration has two components: the array's type and the array's name.
			<delay>2</delay>
			An array's type is written as type[], where type is the data type of the contained elements; the brackets are special symbols indicating that this variable holds an array.
			<delay>2</delay>
			The size of the array is not part of its type (which is why the brackets are empty).
			<delay>2</delay>
			An array's name can be anything you want, provided that it follows the rules and conventions as previously discussed in the naming section.
			<delay>2</delay>
			As with variables of other types, the declaration does not actually create an array; it simply tells the compiler that this variable will hold an array of the specified type.


			<delay>2</delay>
			Similarly, you can declare arrays of other types:

byte[] anArrayOfBytes;
short[] anArrayOfShorts;
long[] anArrayOfLongs;
float[] anArrayOfFloats;
double[] anArrayOfDoubles;
boolean[] anArrayOfBooleans;
char[] anArrayOfChars;
String[] anArrayOfStrings;



			<delay>2</delay>
			You can also place the brackets after the array's name:

// this form is discouraged
float anArrayOfFloats[];



			<delay>2</delay>
			However, convention discourages this form; the brackets identify the array type and should appear with the type designation.


			<delay>2</delay>
			So, there is no difference between using these two type of declarations.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ object ^ check ^ array </pattern>
		<template>
			
			You have to use nested loops.
			<delay>2</delay>
			Suppose you have an array of arrays of Integer, and you want to check if a specific number is inside the array:

static boolean contains(Integer[][] array, Integer wantedInt) {
    // For each sub-array
    for (int i = 0; i &lt; array.length; i++) {
        // For each element in the sub-array
        for (int j = 0; j &lt; array[i].length; j++) {
            // If the element is the wanted one
            if (array[i][j].equals(wantedInt)) {
                // We've found it
                return true;
            }
        }
    }
    // We didn't find the wanted number
    return false;
}



			<delay>2</delay>
			You could use the same logic to search for any object type by using generics:

static &lt;T&gt; boolean contains(T[][] array, T wantedObj) {
    for (int i = 0; i &lt; array.length; i++) {
        for (int j = 0; j &lt; array[i].length; j++) {
            if (array[i][j].equals(wantedObj)) {
                return true;
            }
        }
    }
    return false;
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ take input ^ user ^ insert ^ arraylist </pattern>
		<template>
			
			I think this is what you are looking for

   ----------------------- Main Class File --------------------
   public class TestingClass {
      public static void main(String[] args) {

        Scanner input = new Scanner(System.in);
        System.out.println("Please enter the number of students detail : ");
        int numberOfInputs = input.nextInt();

        ArrayList&lt;Student&gt; StudentList = new ArrayList&lt;Student&gt;();


        for( int i=0;  i &lt; numberOfInputs ; i++){
            System.out.println("Please enter Name : ");
            String name = input.next();
            System.out.println("Please enter Address : ");
            String address = input.next();

            Student std = new Student(name, address);
            StudentList.add(std);
        }

        for(Student std : StudentList){
            System.out.println(std.toString());
        }
     }
    }


   -------------------- Student Java File ----------------------
     public class Student {

       public String    name    = "";
       public String    address = "";

       public Student(String name2, String address2) {

           this.name = name2;
           this.address = address2;
       }

     @Override
     public String toString() {

         return "Student [name=" + this.name + ", address=" + this.address + "]";
        }

     }


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ arguments without giving actual value ^ pass double ^ java </pattern>
		<template>
			
			To the first question: There is no variable cost within addSession().
			<delay>2</delay>
			If you have not defined an attribute cost within Session then this is the problem.


			<delay>2</delay>
			To the second question: I am not quite sure that I understand your problem correctly.
			<delay>2</delay>
			You have an int[] values and want to know, whether a given int x is within that array?
			<delay>2</delay>
			If so, you can achieve this with this code snippet:

for (int value : values) {
    if (value == x) {
        // Put code, that should be executed when the value is found, here
    }
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ integer array ^ jumble ^ elements </pattern>
		<template>
			
			
When an Double Integer is given

This statement is wrong , As @Mike Kobit mentioned , double is not same as integer , but for an Integer Array
Try this
Integer i[]=new Integer[]{1,2,3,4,5};
List&lt;Integer&gt; list=Arrays.asList(i);
System.out.println(list);  ------&gt; Before Shuffling
Collections.shuffle(list);
System.out.println(list); -------&gt; After shuffling
list.toArray(i);  -----&gt; Convert list back to array

Output
[1, 2, 3, 4, 5] --&gt;Before Shuffling
[1, 3, 4, 2, 5] --&gt; After Shuffling


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ reverse () usage ^ arrayutils </pattern>
		<template>
			
			The error refers to the fact that ArrayUtils cannot be found among your classes, the standard Java runtime or the libraries in your classpath.


			<delay>2</delay>
			ArrayUtils is part of Apache Commons, you need to include that jar library in your project and to add an import org.apache.commons.lang.ArrayUtils on top, to make this work.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ use one ^ array vs ^ would ^ arraylist </pattern>
		<template>
			
			Array takes up less space and are typically faster, ArrayList lets you add and remove elements from your array (can be useful for a lot of reasons).

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ dynamically initialize ^ array using ^ dynamically ^ array ^ reflect ^ possible ^ lang ^ java </pattern>
		<template>
			
			If you want to initialise the array to a size specified by the user, just use a variable for the size.


			<delay>2</delay>
			int size = 3;
int[] array = new int[size];


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ anonymous arrays ^ java </pattern>
		<template>
			
			Hello imagine that you have the following code:

public class Test { 
    public static void printArray(int []arr){
        for (int i : arr) {
            System.out.print(i);
        }
    }
    public static void main(String[] args) {

        int arr[]={1,2,3,4,5,6};
        printArray(arr);
    }
}



			<delay>2</delay>
			The output is 123456.
			<delay>2</delay>
			If you want to call the printArrayMethod in a single line you have to use a anonymous array like the following:

printArray(new int[]{1,2,3,4,5,6});



			<delay>2</delay>
			You cant use something like the following:

printArray({1,2,3,4,5,6});



			<delay>2</delay>
			It is going to provoke a compilation fail.


			<delay>2</delay>
			And the question is, Why do I need to use an anonymous array and not a normal array like the first example.


			<delay>2</delay>
			Check the following code:

public class Test { 
    public static void printArray(int []arr){
        for (int i : arr) {
            System.out.print(i);
        }
    }
    public static void main(String[] args) {
        //Many code
        printArray(new int[]{1,2,3,4,5,6});
        //Many code
    }
}



			<delay>2</delay>
			If you use a normal array this array is going to alive in your heap during all the main method execution and with the anonymous array you are only use this array to the printArray method and after this the object is going to be eligible to the garbage collector.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ nth index onward ^ printing elements ^ array </pattern>
		<template>
			
			If you are using Java-8, you can do this :

Arrays.stream(array).skip(2).forEach(System.out::println);



			<delay>2</delay>
			There won't be any exceptions thrown even if you pass a value to skip that is greater than the length of the array.
			<delay>2</delay>
			You will simply get no output in such a case.


			<delay>2</delay>
			If you are not using Java-8, I don't see any challenge.
			<delay>2</delay>
			Just loop through index 3 to n and print the elements.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ deleted deleted deleted </pattern>
		<template>
			
			Your getContacts AsyncTask runs in another thread (asynchronously as the etymology suggests).
			<delay>2</delay>
			Your list is updated after that thread finishes, but your Logging happens in parallel with the AsyncTask so at the time you log the size, the list does contain nothing.
			<delay>2</delay>
			Later when the AsyncTask finishes that's when you see things displayed in the list.


			<delay>2</delay>
			Heres a visualization


			<delay>2</delay>
			Thread:
			<delay>2</delay>
			UI -----------------------------------------------------------
			<delay>2</delay>
			ASYNCTASK


			<delay>2</delay>
			...............
			<delay>2</delay>
			| .. ArrayList mNewList = new ...;

...............
			<delay>2</delay>
			| .. mNewList = mListData.getContacts();

...............
			<delay>2</delay>
			| ..
			<delay>2</delay>
			AsyncTask::onBeforeExecute()

...............
			<delay>2</delay>
			| ..............................................................................
			<delay>2</delay>
			| ..
			<delay>2</delay>
			AsyncTask::doInBackground starts

...............
			<delay>2</delay>
			| .. Log.i(mNewList.size()); .................................... | ..
			<delay>2</delay>
			( still working )

...............
			<delay>2</delay>
			| ..............................................................................
			<delay>2</delay>
			| ..
			<delay>2</delay>
			AsyncTask::doInBackground returns

...............
			<delay>2</delay>
			| ..
			<delay>2</delay>
			AsyncTask::onPostExecute

...............
			<delay>2</delay>
			| .. mContacts.add(...) ...

...............
			<delay>2</delay>
			| ...

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ last removed element ^ list ^ java ^ array </pattern>
		<template>
			
			Most likely this is what they had in mind.


			<delay>2</delay>
			List&lt;String&gt; words = ...

String word = words.remove(0);



			<delay>2</delay>
			The method remove(int) return the object removed from the list.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ certain x ^ 2d array ^ position ^ objects ^ object ^ add </pattern>
		<template>
			
			`

import java.util.*;
class a_class{
    private int i;
    public a_class(int k){
        i=k;
    }
    public void print(){
        System.out.print(i+"\t");
    }
}
class Stack_help{
    public static void main(String []args){
        a_class [][]a=new a_class[4][4];//creating a new array of 2d objects
        for(int i=0;i&lt;4;i++){
            for(int j=0;j&lt;4;j++){
                a[i][j] = new a_class(i);
                a[i][j].print();
            }
            System.out.println("\n");
        }
    }
}


`

Probably what you are asking just run this code you will get your answer

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ object array ^ store string ^ string ^ using ^ index </pattern>
		<template>
			
			No you cannot.
			<delay>2</delay>
			Array index must be integer. 


			<delay>2</delay>
			And if you want to pair them up, look at Map, where you can use String as a key and value Map&lt;String,String&gt;.

Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();
map.put("ab","ab"); //adding key-value;

String value map.get("ab"); //gives you "ab"


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ textfile using java ^ line ^ delete </pattern>
		<template>
			
			Here's a working code, assuming you are using Java >= 7:

public static void removeLine(String ans, String file) throws IOException {
    boolean foundLine = false;
    try (BufferedReader br = Files.newBufferedReader(Paths.get(file));
            BufferedWriter bw = Files.newBufferedWriter(Paths.get(file + ".tmp"))) {
        String line;
        while ((line = br.readLine()) != null) {
            String[] tokens = line.split("::", 2);
            if (tokens[0].equals(ans)) {
                foundLine = true;
            } else {
                if (foundLine) {
                    bw.write((Integer.parseInt(tokens[0]) - 1) + "::" + tokens[1]);
                } else {
                    bw.write(line);
                }
                bw.newLine();
            }
        }
    }
    Files.move(Paths.get(file + ".tmp"), Paths.get(file), StandardCopyOption.REPLACE_EXISTING);
}



			<delay>2</delay>
			It is not possible to delete a line from a file.
			<delay>2</delay>
			What you need to do is read the existing file, write the contents you want to keep to a temporary file and then rename the temporary file to overwrite the input file.


			<delay>2</delay>
			Here, the temporary file is created in the same directory as the input file, with the extension .tmp added (note that you can also use Files.createTempFile for this).


			<delay>2</delay>
			For each line that is read, we check if this is the line the user wants to delete.



			<delay>2</delay>
			If it is, we update a boolean variable telling us that we just hit the line to be deleted and we do not copy this line to the temporary file.

			<delay>2</delay>
			If it is not, we have a choice:


Either we did not yet hit the line to be deleted.
			<delay>2</delay>
			Then we simply copy what we read to the temporary file

			<delay>2</delay>
			Or we did
			<delay>2</delay>
			and we need to decrement the first number and copy the rest of the line to the temporary file.




			<delay>2</delay>
			The current line is splitted with the help of String.split(regex, limit) (it splits the line only two times, thereby creating an array of 2 Strings: first part is the number, second part is the rest of the line).


			<delay>2</delay>
			Finally, the temporary file overwrites the input file with Files.move
			<delay>2</delay>
			(we need to use the REPLACE_EXISTING option).

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ textfile using java ^ adjust line number </pattern>
		<template>
			
			Your code looks good so far.


			<delay>2</delay>
			I suggest you do what you are trying to achieve
			<delay>2</delay>
			: you basically renumber each line.



			<delay>2</delay>
			You should introduce a variable, set it to an initial number (1,
based on your example).

			<delay>2</delay>
			You use the new number when writing it out
to the file.

			<delay>2</delay>
			You increment the variable.



			<delay>2</delay>
			I am intentionally not posting the exact code for you to improve.
			<delay>2</delay>
			Comment if you need more help.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ create rows ^ columns </pattern>
		<template>
			
			Since you cannot use array and cannot create any new method.
			<delay>2</delay>
			You can do something like this:


			<delay>2</delay>
			Output:

 O  .  .  .  . 
 .  .  .  .  . 
 .  .  .  .  . 
 .  .  .  .  . 
 .  .  .  .  E 


Codes:

    int playerX=0, playerY=0;  //holds player's location
    int exitX = 4, exitY = 4;  //holds exit's location

    //Print map
    for(int x=0; x&lt;5; x++){
        for(int y=0; y&lt;5; y++)
            if(x == playerX &amp;&amp; y == playerY)
                System.out.print(" O "); //print player location
            else if(x == exitX &amp;&amp; y == exitY)
                System.out.print(" E ");
            else    
                System.out.print(" . ");
        System.out.println("");     
    }
    /*
    //Update player's position on movement
    if (movement == DOWN)
        playerY = Math.min(playerY+1 , 5);
    else if (movement == UP)
        playerY = Math.max(playerY-1 , 0);
    else if (movement == LEFT)
        playerX = Math.max(playerX-1 , 0);
    else else if (movement == RIGHT)
        playerX = Math.max(playerY+1 , 5);  
    */



			<delay>2</delay>
			You can enclose every thing in a while loop, and repeat the loop so long player's location is not same as exit's location.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ single linear array ^ array ^ difference ^ characters </pattern>
		<template>
			
			An array of characters is just a linear array of char values.
			<delay>2</delay>
			An array can be anything, primitive or object; Object[], char[], Comparable[] and an array of a class named Car (Car[]) are all valid arrays.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ input parameter ^ setting ^ method ^ array </pattern>
		<template>
			
			public class FirstJavaClass {
    public void method(double[] input) {
        // ... do something amazing with it!
    }
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ method parameters ^ java missingformatargumentexception ^ printing ^ passed ^ array </pattern>
		<template>
			
			What did you expect the statement to do?


			<delay>2</delay>
			System.out.printf("(x,y): (%f,%f)");



			<delay>2</delay>
			You never gave any values.
			<delay>2</delay>
			Try actually giving some values for the %f markers:

System.out.printf("(x,y): (%f,%f)", this.x, this.y);



			<delay>2</delay>
			You should read the The Java™ Tutorials:
			<delay>2</delay>
			Formatting Numeric Print Output.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ vector v ^ similar ways ^ java arraylist ^ 100 </pattern>
		<template>
			
			When you instantiate an ArrayList, you can specify the initial capacity, but that doesn't populate the ArrayList.


			<delay>2</delay>
			You can use some short cuts with arrays.


			<delay>2</delay>
			For example, you can create an ArrayList of 100 null references with :

List&lt;Integer&gt; list = new ArrayList&lt;&gt; (Arrays.asList(new Integer[100]));


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ using linear search ^ check </pattern>
		<template>
			
			Assuming you're ultimately just trying to get a list of words that are in both files:

Scanner fileReader = new Scanner(file);
Set&lt;String&gt; words = new HashSet&lt;&gt;();

while (fileReader.hasNext()) {
  String s = fileReader.next();
  words.add(s);
}
fileReader.close();

Scanner otherFileReader = new Scanner(otherFile);
List&lt;String&gt; wordsInBothFiles = new ArrayList&lt;&gt;();

while (otherFileReader.hasNext()) {
  String s = otherFileReader.next();
  if (words.contains(s)) {
    wordsInBothFiles.add(s);
  }
}
otherFileReader.close();

// Do whatever it is you have to do with the shared words, like printing them:
// for (String s : wordsInBothFiles) {
//   System.out.println(s);
// }


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ could accept ^ trying ^ integers ^ create ^ arraylist ^ array </pattern>
		<template>
			
			Both int (Integer wrapper) and array's common base class is Object.
			<delay>2</delay>
			So create ArrayList using Object type. 


			<delay>2</delay>
			ArrayList&lt;Object&gt; list= new ArrayList&lt;Object&gt;();



			<delay>2</delay>
			But this is not the right way to solve this problem and there is no use of Generics here to make run-time safety.
			<delay>2</delay>
			So, re-design your program and allocate each type in seperate list or use any other appropriate Collection type.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ finding intersection </pattern>
		<template>
			
			The variable intCount is local in the innermost if-condition, which means that only the first entry of interArr is accessed.
			<delay>2</delay>
			Rearrange the implementation as follows.


			<delay>2</delay>
			public int[] intersection(Set parSet)
{
    int[] interArr = new int[numbers.length];
    int[] testArr = parSet.toArray();

    int intCount = 0; // initialization out of the loop

    for(int index = 0; index &lt; numbers.length; index++)
    {
        for(int compareInt = 0; compareInt &lt; testArr.length; compareInt++)
        {
            if(numbers[index] == testArr[compareInt])
            {
                interArr[intCount] = testArr[compareInt];
                intCount++;
            }//end if
        }//end inner for
    }//end outter for

    return interArr;
}//end method intersection


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ util ^ type ^ sort ^ java ^ arrays </pattern>
		<template>
			
			from java doc:


  Implementation note:
			<delay>2</delay>
			The sorting algorithm is a Dual-Pivot Quicksort
  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch.
			<delay>2</delay>
			This
  algorithm offers O(n log(n))
			<delay>2</delay>
			performance on many data sets that cause
  other quicksorts to degrade to quadratic performance, and is typically
  faster than traditional (one-pivot) Quicksort implementations.


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ 2d array randomly ^ single char value ^ single element ^ want ^ populate </pattern>
		<template>
			
			Are you looking for something like this?


			<delay>2</delay>
			// Your array of Char with the length of 5 by 5
char[][] arrayOfChar = new char[5][5];

// Generating a radom number with min being 0 and max being length - 1
Random rand = new Random();
int x = rand.nextInt(arrayOfChar[0].length);
int y = rand.nextInt(arrayOfChar[1].length);

// Random position in array assigned M
arrayOfChar[x][y] = 'M' ;



			<delay>2</delay>
			If you wanted an int array

// Your array of int with the length of 5 by 5
int[][] arrayOfInt = new int[5][5];

// Generating a radom number with min being 0 and max being length - 1
Random rand = new Random();
int x = rand.nextInt(arrayOfInt[0].length);
int y = rand.nextInt(arrayOfInt[1].length);

// Random position in array assigned number 8
arrayOfInt[x][y] = 8 ;


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ three columns ^ allow arraylist ^ take ^ data ^ csv </pattern>
		<template>
			
			What you can do is :


Skip the first row
			<delay>2</delay>
			if it has X Y Z.
Declare two more ArrayList to store Y and Z column. 



			<delay>2</delay>
			You can do it like this :

  public class FileParser  {
    public ArrayList&lt;String&gt; parseFile(String fileName){
    String csvFile = fileName;
    BufferedReader br = null;
    String line = "";
    final String DELIMITER = ",";
    ArrayList&lt;String&gt; dataX = new ArrayList&lt;String&gt;();
    ArrayList&lt;String&gt; dataY = new ArrayList&lt;String&gt;();
    ArrayList&lt;String&gt; dataZ = new ArrayList&lt;String&gt;();
     try {
         int counter = 0;
         int N = 10;
          br = new BufferedReader(new FileReader(csvFile));
          while ((line = br.readLine()) != null &amp;&amp; counter &lt; N) {
          if(counter &gt; 0){
            String[] dataRow = line.split(DELIMITER);
            dataX.add(dataRow[0]);
            dataY.add(dataRow[1]);
            dataZ.add(dataRow[2]);
        }
        counter++;
    }

  } catch (FileNotFoundException e) {
    e.printStackTrace();
 } catch (IOException e) {
    e.printStackTrace();
 } finally {
    if (br != null) {
        try {
            br.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

 return data;
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ certain places within ^ certain integers ^ way ^ see ^ arraylist </pattern>
		<template>
			
			Just compare the order and the array with a for-loop:

public boolean isArrayInOrder(int[] array, int... order) {
    if(array.length == order.length) {
        for(int i = 0; i &lt; array.length; ++i) {
            if(array[i] != order[i]) return false;
        }
        return true;
    }
    return false;
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java always need ^ fixed size ^ array </pattern>
		<template>
			
			An ArrayList is backed by an array, whose size is fixed, but the ArrayList class contains code that creates a larger array and copies the existing array to it when the existing array is full.


			<delay>2</delay>
			That's the difference between arrays and ArrayLists.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ time complexity ^ sorting ^ n ^ integers ^ array ^ 1 </pattern>
		<template>
			
			Use Radix Sort, which is O(n)

 public void radixsort(int[] input) {
  final int RADIX = 10;
  // declare and initialize bucket[]
  List&lt;Integer&gt;[] bucket = new ArrayList[RADIX];
  for (int i = 0; i &lt; bucket.length; i++) {
    bucket[i] = new ArrayList&lt;Integer&gt;();
  }

  // sort
  boolean maxLength = false;
  int tmp = -1, placement = 1;
  while (!maxLength) {
    maxLength = true;
    // split input between lists
    for (Integer i : input) {
      tmp = i / placement;
      bucket[tmp % RADIX].add(i);
      if (maxLength &amp;&amp; tmp &gt; 0) {
        maxLength = false;
      }
    }
    // empty lists into input array
    int a = 0;
    for (int b = 0; b &lt; RADIX; b++) {
      for (Integer i : bucket[b]) {
        input[a++] = i;
      }
      bucket[b].clear();
    }
    // move to next digit
    placement *= RADIX;
  }
}


code Ref

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java collection framework ^ size array ^ array ^ variable ^ stack ^ integers ^ implement </pattern>
		<template>
			
			If stack of Integer boxed objects suites for you then you can just use java.util.Stack implementation from Java Collections.

			<delay>2</delay>
			But if your requirement is to use only primitive types take a look at java.util.Stack implementation.
			<delay>2</delay>
			All you need to do to make it work with primitive integer is just replace type of base array and all method parameters and return values.
			<delay>2</delay>
			It's simple.


			<delay>2</delay>
			Third option is to use one of 3d party collection libraries, for example goldmnan sachs collections if I remember right.
			<delay>2</delay>
			They provide such solution already.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ kotlin like ^ size ^ providing ^ java ^ create ^ array </pattern>
		<template>
			
			According to the reference, arrays are created in the following way:

For Java's primitive types there are distinct types IntArray, DoubleArray etc.
			<delay>2</delay>
			which store unboxed values.

			<delay>2</delay>
			They are created with the corresponding constructors and factory functions:
val arrayOfZeros = IntArray(size) //equivalent in Java: new int[size]
val numbersFromOne = IntArray(size) { it + 1 }
val myInts = intArrayOf(1, 1, 2, 3, 5, 8, 13, 21)


			<delay>2</delay>
			The first one is simillar to that in Java, it just creates a primitive array filled with the default value, e.g. zero for Int, false for Boolean.


			<delay>2</delay>
			Non primitive-arrays are represented by Array&lt;T&gt; class, where T is the items type.

			<delay>2</delay>
			T can still be one of types primitive in Java (IntArray0, IntArray1,...), but the values inside will be boxed equivalently to Java's IntArray2, IntArray3 and so on.

			<delay>2</delay>
			Also, IntArray4 can be both nullable and non-null like IntArray5 and IntArray6.

			<delay>2</delay>
			These are created in a similar way:

			<delay>2</delay>
			IntArray7



			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ create biginteger array ^ int array </pattern>
		<template>
			
			This should do the job if you're using java-8

int[] ints = new int[]{1,2,3};

System.out.println(Arrays.toString(ints)); // [1, 2, 3]

BigInteger[] bigs = Arrays.stream(ints)
                          .mapToObj(BigInteger::valueOf)
                          .toArray(BigInteger[]::new);

System.out.println(Arrays.toString(bigs)); // [1, 2, 3]


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ sort ^ points ^ mergesort ^ java ^ array </pattern>
		<template>
			
			Assuming you are talking about 2D or 3D points, you would have to think about defining a metric such that they are orderable. 


			<delay>2</delay>
			Consider the exampe points (1,0) and (0,1) in 2D space.
			<delay>2</delay>
			Is (1,0) &gt; (0,1) ? Or (1,0) &lt; (0,1) ?
			<delay>2</delay>
			It really depends on the application.


			<delay>2</delay>
			You could e.g. take just the first component as metric, then it would be (1,0) &gt; (0,1).
			<delay>2</delay>
			Or you could take the distance from a specific point, e.g. the origin (0,0), in which case they would be equal.


			<delay>2</delay>
			Anyways, after you have decided on that, you can look up existing implementations of sorting algorithms (you seem to be determined about MergeSort though), on the internet.
			<delay>2</delay>
			Here is one example.


			<delay>2</delay>
			Most interfaces to sort function in various programming languages require either a key function (e.g. "get first component" or "distance from origin"), or a custom comparison operator.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ uses 2d array ^ method ^ java ^ create </pattern>
		<template>
			
			2D arrays can be declared like int[][] matrix = new int[10][10];
			<delay>2</delay>
			If you need 2D array with different number of values in rows, than you have to create each row by yourself:

int [][] matrix = new int[10][];
matrix[0] = new int[10];
matrix[1] = new int[20];
//...



			<delay>2</delay>
			To iterate over $
			<delay>2</delay>
			code_placeholder_3
			<delay>2</delay>
			you need

for (int[] row : matrix) {
    for (int value : row) {
        sum += value;
    }
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ eight booleans ^ convert ^ byte ^ array </pattern>
		<template>
			
			Try using BitSet to get the representation of the byte number...

			<delay>2</delay>
			Example:
independently of the signed or not....
public static void main(String[] args) {
    byte b1 = (byte) 129;
    BitSet bits = BitSet.valueOf(new byte[]{b1});
    System.out.println(bits); //
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ whats wrong ^ following code </pattern>
		<template>
			
			Strings are immutable so you can't change them, and you shouldn't expect this to do anything.


			<delay>2</delay>
			What you might have intended is

String s = "fecbda"; 
char[] chars = s.toCharArray();
Arrays.sort(chars); 
String s2 = new String(chars);
System.out.println(s2);


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ create 2d array containing 2d arraylist ^ java </pattern>
		<template>
			
			You should use:

List&lt;List&lt;String&gt;&gt; example = new ArrayList&lt;List&lt;String&gt;&gt;();


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ array types cannot ^ arraylist collection ^ supplied ^ constructing </pattern>
		<template>
			
			All array types are subclasses of Object so you can use any array type in a generic which extends Object as T does by default, even arrays of primitive.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ 2d array ^ java ^ declare ^ call </pattern>
		<template>
			
			int [][] arr = new int[height][width];


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ printed text ^ text ^ store ^ punctuations ^ new ^ lowcase ^ java ^ get ^ array </pattern>
		<template>
			
			public static char[]
			<delay>2</delay>
			normalisieren(char[] text) throws IOException {

    BufferedReader keyboard = new BufferedReader(new 


FileReader("c:/readIt.txt"));

    String texte;

     ArrayList&lt;String&gt; reText = new ArrayList&lt;String&gt;();

        while((texte = keyboard.readLine()) != null){
            reText.add(texte);
        }

        String[] stringArr = reText.toArray(new String[0]);
        for(int i = 0; i &lt; stringArr.length; i++){
      //  System.out.println(stringArr[i]);
        String str = stringArr[i].toLowerCase();
        System.out.println(str);
        }
        return text;
}

public static void main(String[] args) throws IOException {
    normalisieren(null);
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ winner tic tac toe game java ^ check </pattern>
		<template>
			
			The problem is this expression in the if statement:

GameBoard[0][0] == player &amp;&amp; GameBoard[0][1] == player &amp;&amp; GameBoard[0][2] == player &amp;&amp;
                    GameBoard[1][0] == player &amp;&amp; GameBoard[1][1] == player &amp;&amp; GameBoard[1][2] == player &amp;&amp;
                    GameBoard[2][0] == player &amp;&amp; GameBoard[2][1] == player &amp;&amp; GameBoard[2][2] == player



			<delay>2</delay>
			You're checking to see if the player is in every board position.


			<delay>2</delay>
			You want to determine that there wasn't a winner.  
			<delay>2</delay>
			That means checking that none of the the rows, columns and diagonals have the same player.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ efficient way ^ store ^ java ^ array ^ 1s ^ 0s </pattern>
		<template>
			
			I hope you have gone through BitSet.
			<delay>2</delay>
			I think thats the efficient way of storing Bits. 

			<delay>2</delay>
			https://docs.oracle.com/javase/7/docs/api/java/util/BitSet.html


			<delay>2</delay>
			but you should treat 0 as false and 1 as true

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ inventory program java help needed </pattern>
		<template>
			
			This is the easiest method yet!
			<delay>2</delay>
			If you simply want to retireve the item by position, then ArrayList#get is your method.
			<delay>2</delay>
			Per the Oracle docs,


  Returns the element at the specified position in this list.



			<delay>2</delay>
			public StockItem getItem(int index) {
    return this.stock.get(index);
}



			<delay>2</delay>
			However, you have to add in the special case for the null return specified by your JavaDocs.
			<delay>2</delay>
			There are two ways to do this

First way

public StockItem getItem(int index) {
    if (index &lt; 0 || index &gt;= this.stock.size()){
        return null;
    }
    return this.stock.get(index);
}


Second way


			<delay>2</delay>
			public StockItem getItem(int index) {
    try{
        return this.stock.get(index);
    }catch(IndexOutOfBoundsException e){
        return null;
    }
}



			<delay>2</delay>
			I'd suggest the first way because, although there is additional logic, using Exceptions as regular control flow in your code is not good practice.
			<delay>2</delay>
			See this and this for more discussion.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java print (); method ^ different class ^ getters </pattern>
		<template>
			
			This is the important error message. 


  
			<delay>2</delay>
			Cannot make a static reference to the non-static method
  getStudentID(); from the type Student.



			<delay>2</delay>
			You need to call getStudentID() on an instance of the class, and not the class itself.
			<delay>2</delay>
			You can try something like this. 


			<delay>2</delay>
			public static void print_all() {

    System.out.println("Student ID\tRecent Grades\tName\t\tE-Mail\t\t\tAge");
    for (Student w : studentlist) {
        System.out.print(w.getStudentID() + "\t\t");
        System.out.print(w.getGrades() + "\t");
        System.out.print(w.getFirstname()+ " ");
        System.out.print(w.getLastname()+ "\t");
        System.out.print(w.getEmail()+ "\t");
        System.out.print(w.getAge()+ "\t");
        System.out.println(" ");
    }
}


Calling Student.getStudentID() would only work if there was a static (shared) ID for all the students.
			<delay>2</delay>
			This is not the case here.
			<delay>2</delay>
			You can look at this post for a more complete explanation of the static keyword in java. 

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ get value ^ given matrix ^ matrix </pattern>
		<template>
			
			To my understanding, the problem can be solved with the following helper function which calculates the indices of the next entry.
			<delay>2</delay>
			The syntax is C#, but should work similar in Java, where m and n are supposed to be the respective matrix dimensions.
			<delay>2</delay>
			The idea is to check whether the desired main direction is down-left or up-right; if the edge of the matrix is reached, which has to be checked beforehand, this is modified to right and down, respectively.
			<delay>2</delay>
			The implementation assumes zero-based indexing of the rows and columns.


			<delay>2</delay>
			public struct Cell
{
    public int Row;
    public int Col;
}

public static Cell GetNext(Cell iCell)
{
    Cell Result;
    if (( iCell.Row + iCell.Col ) % 2 == 0)
    {
        if (iCell.Col == n - 1)
            Result = new Cell { Row = iCell.Row + 1, Col = n - 1 };
        else if (iCell.Row == 0)                    
            Result = new Cell { Row = 0, Col = iCell.Col + 1 };
        else
            Result = new Cell { Row = iCell.Row - 1, Col = iCell.Col + 1 };
    }
    else
    {
        if (iCell.Row == m - 1)
            Result = new Cell { Row = m - 1, Col = iCell.Col + 1 };
        else if (iCell.Col == 0)
            Result = new Cell { Row = iCell.Row + 1, Col = 0 };
        else
            Result = new Cell { Row = iCell.Row + 1, Col = iCell.Col - 1 };
    }
    return Result;
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ different column count ^ rows </pattern>
		<template>
			
			Yes, you can have different column count for each row.


			<delay>2</delay>
			data_type [][] array = new data_type[row][]

array[0] = new data_type[size1]

array[1] = new data_type[size2]

P.S
			<delay>2</delay>
			: Why don't you try on your system, before asking such questions.


			<delay>2</delay>
			P.P.S : Here i have assumed that row &gt;=2.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ size ^ ones ^ match ^ list </pattern>
		<template>
			
			If you don't want the 'null' image to appear on a list, just do something like:

for each item on a list
    if item == null then continue
    else 
        add an item to &lt;List&gt;Images



			<delay>2</delay>
			If you pass a null object to the List of Images, it still does occupy the place in the list, even though this place is technically uninitialized.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ arraylist element index ^ shuffle ^ java ^ collections </pattern>
		<template>
			
			If you want to hold on to the original position of the object you need to make a copy of the arraylist before you shuffle it.  
			<delay>2</delay>
			And then use indexOf 

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ take input ^ number eg ^ integer array ^ edittext field ^ android studio ^ convert ^ 5 ^ 4 ^ 2 ^ 1452 ^ 1 </pattern>
		<template>
			
			well first do 

String s = yourEditText.toString();
Integer digitNumber = s.length();
Integer i = Integer.valueOf(s);


then ull have to read single digits u do this by using the Mod operator so

new Integer[] I = new Integer[digitNumber];
for(int i=0; i&lt;digitNumber;i++){
    I[i] = i % 10;
    i = i/10;
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ display numbers ^ integers ^ characters </pattern>
		<template>
			
			public static void main(String[] args) {
    int value = 1234;
    List&lt;Integer&gt; output = new ArrayList&lt;Integer&gt;();
    while (value &gt; 0) {
        output.add(value % 10);
        value /= 10;
    }
    Collections.sort(output);
    System.out.println("Min:" + output.get(0));
    System.out.println("Max:" + output.get(output.size() - 1));
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ foreach arraylist ^ way ^ put ^ inside ^ continue </pattern>
		<template>
			
			You can't do that in Java 8.
			<delay>2</delay>
			You could use an Exception to break from code.
			<delay>2</delay>
			It's not pretty, but it's doable if you need to.


			<delay>2</delay>
			Like this:

try {
    Array.forEach((x) -&gt; {
       if (condition) {
          throw new MyException();
       }
    });
} catch (MyException e) {
    // broke from loop
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ user inputted integers ^ save ^ line ^ array </pattern>
		<template>
			
			You can let the user input the data as a String delimited by space (or other delimiters)


			<delay>2</delay>
			After you receive the string of input, tokenized the data into tokens where you can store them into a data structure of your choice (array, array list..etc).


			<delay>2</delay>
			You may use String.split() when tokenizing them.


			<delay>2</delay>
			For example:

String input = sc.nextLine();
String[] tokens = input.split(" ");
int[] data = new int[tokens.length];

for(int x=0; x&lt;tokens.length; x++)
    data[x] = Integer.parseInt(tokens[x]);

//Input: 11 22 33 44
//data[0] will be 11
//data[1] will be 22
//data[2] will be 33 and so on


;

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ loop ^ create </pattern>
		<template>
			
			I am going to walk you through what I corrected and changed in your code to make it work in order to make it quick and easy for you to comprehend why your code doesn't work and why my answer fixes it.


			<delay>2</delay>
			The mistakes you made are basic ones and frankly you shouldn't have to much of a hard time correcting them yourself if you would use a debugger that walks you step by step in how your code works.
			<delay>2</delay>
			You should look on how to use a debugger (for example the debugger used in Eclipse, hopefully you are using an IDE to make your life easier).


			<delay>2</delay>
			Firstly, when you are looking for a consonant in your code, you are only walking through the half of it because of your condition for(int x = 0; x&lt;20; x++) since your string holding the consonants if of a length of 40 characters.
			<delay>2</delay>
			This means you are missing consonants like the letter
			<delay>2</delay>
			s.


			<delay>2</delay>
			Then you are correctly the consonants you find according to your Swedish language game.
			<delay>2</delay>
			But you are never handling characters that are not of these found consonants.
			<delay>2</delay>
			You should make a case where you handle these "non consonant" letters, may they be vowels or any kind of character (like punctuation marks and so on).
			<delay>2</delay>
			I am fixing this with the use of a simple boolean here.


			<delay>2</delay>
			Keep in mind that my goal here is to change your code as little as I can, thus I went for adding a boolean to handle your cases (checking the presence of a consonant).
			<delay>2</delay>
			There are, obviously, many other ways to implement what you are trying to do.


			<delay>2</delay>
			Here come the changes you should add to your code:

    /*This comes after your print "På rövarspråk:"*/
    boolean isConsonant = false; //Boolean to check wether there is a consonant or not
    for(int i = 0; i&lt;length; i++) {
        //You didn't go through the whole consonants list you made with your prevision condition
        for(int x = 0; x&lt;consonants.length; x++){
            if(array[i] == consonants[x])
            {
                isConsonant = true; //Set the boolean accordingly
                String add = array[i]+"o"+array[i];
                slang = slang + add;
                break;
            }
        }
        if(!isConsonant){ //If we don't have a consonant, add the char to the result string
            slang += array[i];
        }
        isConsonant = false; //Reset the boolean for the next character
    }
    /*Here you can print the result (slang) if you want, as you did*/


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ another array recursive ^ new array ^ create </pattern>
		<template>
			
			the problem is you are initializing your return array at the same size of the input x array.
			<delay>2</delay>
			int[] will default its values to 0. 


			<delay>2</delay>
			What you should do is if you find an odd, then subtract the size by one, then initialize the array, this way you wont have "empty" bins that are defaulted to 0

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ string array ^ jpanel ^ display </pattern>
		<template>
			
			I would display your list using a JList.


			<delay>2</delay>
			Read the section from the Swing tutorial on How to Use List for working examples that show how to add data to the ListModel of the JList.


			<delay>2</delay>
			Basically instead of adding the strings to a List you add them to a DefaultListModel and add the model to the JList.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ display string array </pattern>
		<template>
			
			JList provides a constructor JList(Object[]) which you can call after unpacking your ArrayList&lt;String&gt; using toArray()

list = new JList(arr.toArray())


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ integers using comparable ^ sort ^ possible ^ comparator ^ arraylist </pattern>
		<template>
			
			You're able to sort an ArrayList if the elements implement Comparable.
			<delay>2</delay>
			For example, Integers can be sorted with sort():
Collections.sort(arrayList)


Lists (and arrays) of objects that implement this interface can be
sorted automatically by Collections.sort (and Arrays.sort).
from https://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ return true ^ empty ^ arraylist </pattern>
		<template>
			
			There is already a method provided by java.


			<delay>2</delay>
			return list.isEmpty();


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ google maps android store list ^ list ^ routes </pattern>
		<template>
			
			Check out this answer which adds the route to the ArrayList.
			<delay>2</delay>
			This way you can add all routes to an ArrayList - https://stackoverflow.com/a/17007360/1649353

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ byte array ^ base class </pattern>
		<template>
			
			The answer is byte[].class.


			<delay>2</delay>
			Example:

byte[] receivedMessage = consumer.receiveBody(byte[].class, 15000); // in ms or 15 seconds


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ indexed linked list ^ array list ^ difference </pattern>
		<template>
			
			ArrayList is continuous representation of the data . 


			<delay>2</delay>
			So if base addr is lets say 64
			<delay>2</delay>
			and you want a element at 4th index and size of each element
			<delay>2</delay>
			is 4 bytes so by doing the math we can say at what memory addr to look for 4th index element .
			<delay>2</delay>
			So we can land at up at the element directly


			<delay>2</delay>
			On the other hand Linked List we have to traverse node by node and by counting the numbers of node traversed . 


			<delay>2</delay>
			SO index works for both of them.
			<delay>2</delay>
			For arraylist we can access it directly but in Linked list we have to traverse the intermediate nodes  

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ linked list ^ inserting ^ faster ^ end ^ element ^ array </pattern>
		<template>
			
			I assume you meant ArrayList when you said "array", since in Java you can't "add" to a full array.


			<delay>2</delay>
			Firstly if you're "inserting at the end" you're actually appending to the end not, "inserting".
			<delay>2</delay>
			This distinction is important because inserting into an ArrayList at an arbitrary position is an O(n) operation, because all elements to the right must be "shifted" along by one position to make room for the element being inserted.


			<delay>2</delay>
			Adding to (the tail of) a LinkedList is always a O(1)
			<delay>2</delay>
			(constant time) operation.


			<delay>2</delay>
			Adding to an ArrayList is usually a O(1) operation, but may be a O(n) operation if the backing array is full, because a new array must be allocated and every element copied across.
			<delay>2</delay>
			In the general case of the array not being full, the performance of ArrayList is (slightly) faster than LinkedList, but the difference is very small.


			<delay>2</delay>
			The amortised cost of both is the same, but if constant time is required every time, only a LinkedList can do it.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ largest increasing sequence ^ array </pattern>
		<template>
			
			You can find the solution here

Longest Increasing Subsequence

http://www.geeksforgeeks.org/dynamic-programming-set-3-longest-increasing-subsequence/

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ equal arraylists ^ java </pattern>
		<template>
			
			You are adding the numbers everytime.
			<delay>2</delay>
			You should use local variables or local initialization.
			<delay>2</delay>
			Else your passcode list gets 5 more numbers everytime
			<delay>2</delay>
			you call your function.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ contains numbers ^ create ^ char ^ array </pattern>
		<template>
			
			An array can contain only a single type of value, but you can create array of object.


			<delay>2</delay>
			this might help you - http://www.javawithus.com/tutorial/array-of-objects

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ j ]= c ^ ]+ b ^ 3 arrays ^ result ^ n ^ k ^ gives ^ find ^ combinations ^ 2 </pattern>
		<template>
			
			There is a simpler problem: given two arrays and a number find all combinations from the arrays which give sum=number.
			<delay>2</delay>
			It can be solved in O(n).


			<delay>2</delay>
			We can use its solution as part of solution for the larger one:


			<delay>2</delay>
			(I'm assuming that all elements are different - it simplifies things a bit)

sort(A)
sort(B)
sort(C)
for(int indexC=0;indexC&lt;N;++indexC)
    int indexA=0
    int indexB=N-1
    while(indexA&lt;0)
        //find all combinations in A,B with sum=C[indexC]
        int sum=A[indexA]+B[indexB]
        if(sum==C[indexC])
            OutputCombination(indexA,indexB,indexC)
        if(sum&lt;C[indexC])
            ++indexA
        else if(sum&gt;C[indexC])
            --indexB
        else
            ++indexA
            --indexB


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ use rotation ^ avl tree ^ insert </pattern>
		<template>
			
			If the tree is balanced even after insertion of the new element, there is no need for rotation in AVL tree.
			<delay>2</delay>
			However, if the tree is not balanced after insertion of new elements, then rotation is required.


			<delay>2</delay>
			That is, if the Balance Factor is not violated after insertion, then rotation of any type is not required and insertion is possible without rotation in this scenario.


			<delay>2</delay>
			Note that balance factor in AVL tree refers to calculation of difference between the height of the left and the right sub-trees and it must not be more than 1 to avoid rotation.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ reverse ^ elements ^ array </pattern>
		<template>
			
			Change,

System.out.println(arr[n]);


to:

System.out.println(Arrays.toString(arr));


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ square brackets ^ put ^ matters ^ creating ^ array </pattern>
		<template>
			
			No, int[] i is the same as int i[], but the latter one is discouraged.


			<delay>2</delay>
			See the official documentation on Arrays:


  However, convention discourages this form; the brackets identify the array type and should appear with the type designation.


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ 1 )? ^ length ^ java ^ getting ^ array </pattern>
		<template>
			
			No, Java arrays have a length property that stores their length (i.e. every arrays knows its own length).
			<delay>2</delay>
			No counting is necessary.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ convert string [][] ^ arraylist </pattern>
		<template>
			
			How about this?


			<delay>2</delay>
			ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();
String[][] list = new String[3][2];
list[0][0] = "a";
list[0][1] = "b";
list[1][0] = "c";
list[1][1] = "d";
list[2][0] = "e";
list[2][1] = "f";

for (String[] sublist : list) {
    for (String string : sublist) {
        arrayList.add(string);
    }
}
System.out.println(arrayList);



			<delay>2</delay>
			This might not be the best way, but it works.


			<delay>2</delay>
			Good luck.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ array index ^ array ^ see ^ range ^ accessing </pattern>
		<template>
			
			The correct boolean expression to check if an index is out of bounds for array array is:

index &lt; 0 || index &gt;= array.length



			<delay>2</delay>
			As in:

if (index &lt; 0 || index &gt;= array.length) {
    System.out.println("Index is out of bounds");
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ remove duplicated elements ^ list </pattern>
		<template>
			
			May this can help you:

import java.util.ArrayList;
import java.util.Arrays;

public class RemoveDuplicateElement {

    public static void main(String[] args) {
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(1,2,1,3,5));
        ArrayList&lt;Integer&gt; duplicateElementsRemovedList = new ArrayList&lt;Integer&gt;();
        for (Integer elementToSearch :list) {
            int found=0;
            for (Integer element :list) {
                if(elementToSearch.equals(element)) {
                    found++;
                }
            }
            if(found==1)
            {
                duplicateElementsRemovedList.add(elementToSearch);
            }
        }
        for (Integer element :duplicateElementsRemovedList) {
            System.out.println(element);
        }

    }

}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java arrays ^ whats ^ go ^ equivalent ^ copyofrange </pattern>
		<template>
			
			A simple one-liner would be (index check omitted):

func copyOfRange(src []byte, from, to int) []byte {
    return append([]byte(nil), src[from:to]...)
}



			<delay>2</delay>
			A simple slice expression "almost" does the job, but since Java's Arrays.copyOfRange() returns a copy independent from the source, we need to copy the slicing result to a new slice (because the result of slicing will share the backing array).


			<delay>2</delay>
			We can do that by allocating one with make(), and use the builtin copy(), or simply use append() to append it to an empty or nil slice, which will take care of the allocation and copying.


			<delay>2</delay>
			Example using the above function:

src := []byte{0, 1, 2, 3, 4, 5}
dst := copyOfRange(src, 2, 4)
fmt.Println(dst)


Output (try it on the Go Playground):

[2 3]



			<delay>2</delay>
			For completeness, this is how it would look like with make() and func copyOfRange(src []byte, from, to int) []byte {
    return append([]byte(nil), src[from:to]...)
}
0:

func copyOfRange(src []byte, from, to int) []byte {
    return append([]byte(nil), src[from:to]...)
}
1

One thing to note here:
			<delay>2</delay>
			the builtin func copyOfRange(src []byte, from, to int) []byte {
    return append([]byte(nil), src[from:to]...)
}
2 allocates more space than needed, thinking of future growth.
			<delay>2</delay>
			So if you don't plan to "grow" the returned slice, func copyOfRange(src []byte, from, to int) []byte {
    return append([]byte(nil), src[from:to]...)
}
3 is a better option.


			<delay>2</delay>
			See this comparison:

func copyOfRange(src []byte, from, to int) []byte {
    return append([]byte(nil), src[from:to]...)
}
4

Output (try it on the Go Playground):

func copyOfRange(src []byte, from, to int) []byte {
    return append([]byte(nil), src[from:to]...)
}
5

As you can see, func copyOfRange(src []byte, from, to int) []byte {
    return append([]byte(nil), src[from:to]...)
}
6 (inside func copyOfRange(src []byte, from, to int) []byte {
    return append([]byte(nil), src[from:to]...)
}
7) allocated a backing array with a size of func copyOfRange(src []byte, from, to int) []byte {
    return append([]byte(nil), src[from:to]...)
}
8, while in our func copyOfRange(src []byte, from, to int) []byte {
    return append([]byte(nil), src[from:to]...)
}
9 we explicitly allocated a slice (and backing array) of size Arrays.copyOfRange()0.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ double array ^ store ^ split ^ space ^ java </pattern>
		<template>
			
			You should read the line of from the file as a String, split that and convert to double.
			<delay>2</delay>
			Try this:

    try {
        Scanner scan = new Scanner(new File("path/to/file"));

        String str = scan.nextLine();

        String[] split = str.split("\\s+");

        // remove first element
        String[] x = new String[split.length-1];
        for (int i = 0; i &lt; x.length; i++) {
            x[i] = split[i+1];
        }

        double[] numbers = new double[x.length];
        for (int i = 0; i &lt; x.length; i++) {
            numbers[i] = Double.parseDouble(x[i]);
        }


    } catch (FileNotFoundException e) {
        e.printStackTrace();
    }



			<delay>2</delay>
			I also added a bit to remove the first element since is not a double.
			<delay>2</delay>
			You could condense the two for-loops together, avoiding having a separate x-array.
			<delay>2</delay>
			This can be done as follows:

        String[] split = str.split("\\s+");

        // create double array while ignoring the first element 
        double[] numbers = new double[split.length-1];
        for (int i = 0; i &lt; numbers .length; i++) {
            numbers[i] = Double.parseDouble(split[i+1]);
        }


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java generic matrix creation </pattern>
		<template>
			
			Creating matrices in Java is not as friendly as say R, or Matlab, or even C.  
			<delay>2</delay>
			The very strong Typing paradigm of Java means that everything has to be defined or initialized.  
			<delay>2</delay>
			So you cant simply do Integers[x][y][z].  
			<delay>2</delay>
			Beyond an array of arrays, things get hairy.


			<delay>2</delay>
			The difference is in a regular matrix moving in +x, -x, +y, -y, +z, -z are all essentially equivalent.  
			<delay>2</delay>
			However in Java, if you want to think of three dimensions of a matrix, they are directional.  
			<delay>2</delay>
			Meaning you have to traverse X, then traverse Y, then traverse Z, always in that order.  
			<delay>2</delay>
			And to move say x+1, you have to go back down z, back down y, and then move your x position, then turn around and traverse y again and z again. 

			<delay>2</delay>
			I am not sure that made sense.
			<delay>2</delay>
			but that is how I have to think about matrices in Java or else
			<delay>2</delay>
			I start making coding errors.


			<delay>2</delay>
			There are libraries for java that focus on creating a matrix.  
			<delay>2</delay>
			You could look there.  
			<delay>2</delay>
			http://ejml.org/wiki/index.php?title=Main_Page


			<delay>2</delay>
			Just creating a random array of arrays (a psuedomatrix as described above) doesn't seem hard overall.


			<delay>2</delay>
			import java.util.Random;

public class Rand
{
   public static void main(String[] args)
   {
      Random random = new Random();
     int dim1 = random.nextInt( 10 );
      int dim2 = random.nextInt( 10 );
      int dim3 = random.nextInt( 10 );

      int[][][] matrix = new int[dim1][dim2][];

      //use dim 3 when you do the specific the declaration for the 3rd dimension

   }

}


Running quickly through some examples- 
      Int myIntArray = new int[15]; 
Creates a 15 member int array, initialized to the Default value for that type, which is 0 for 
      //--Assigning
			<delay>2</delay>
			values
      myIntArray[2] =
			<delay>2</delay>
			5; 
      //=  0 0 5 0 0
      
			<delay>2</delay>
			myInt = myIntArray[2];
      
			<delay>2</delay>
			myInt = 5;

// @Initializing with values

   int[5] myIntArray = { 5, 10, 15, 20, 25 };
   int[] myIntArray = { 5, 10, 15, 20, 25 };


Multidimensional array are not like a matrix in C.
			<delay>2</delay>
			All dimensions are the same type.
			<delay>2</delay>
			Each element is an independent array.
			<delay>2</delay>
			Each array element of an earlier dimension is an array.
			<delay>2</delay>
			All dimensions are of the same type and each element is an independent array.

			<delay>2</delay>
			In Java, each array element of a multidimensional array except the
last dimension is an array, not an individual element
       //    
			<delay>2</delay>
			Two dim array

  int[][] myIntArray2;
  //Or
  int myIntArray[][];


Use the new operator to allocate.
			<delay>2</delay>
			Allocation initializes to the DEFault
type.
			<delay>2</delay>
			In this case you are initializing an array of arrays, so the DEFault
type is null.


			<delay>2</delay>
			  int[][] myIntArray2d = new int[5][];
  myIntArray2d[3] = new int[5];


So assigning the array above, you get

  null Null 0 Null Null
  []    []  0 []   [] 
  []    []  0 []   [] 
  []    []  0 []   [] 
  []    []  0 []   [] 



			<delay>2</delay>
			The empty, Defaults in the 1st dim are null - the Default array type.
			<delay>2</delay>
			The second dimension has to be initialized before accessing.


			<delay>2</delay>
			  char[][] charArray = new char[36][];

  //But I cant save anything into  

 charArray[4][0]; 

  //because it has not been initialized with a separate new statement.
  //This is why you leave the 3rd dim off until later.

 char[5]  = new char[5]; // WRONG
  char[] f = new char[5];
  //Now I can follow that with
  charArray[5][5] = 'a';  
  //or from about
  intArray[5][5][5]= 3;
  // But you cant declare the final dimension until later.

  int[3][] arr =  ( { 1, 2, 3 }, { 1, 2 }, { 5, 10, 15, 20 });
  //is an array[2] with 3 arrays
  int[][] arr =   { 1, 2, 3 }, { 1, 2 }, { 5, 10, 15, 20 }; 
  //is an array[2] with 3 arrays



			<delay>2</delay>
			This is why you cant really do matrixes in Java.  
			<delay>2</delay>
			Because each final dimension can technically vary.


			<delay>2</delay>
			When copying an array into a variable - i.e.

  charArrayvars = charArray[5]
  int[] Copies= { 0, 0, 0, 0, 0  } //as a pointer not the data.

  // This means that
  int[3] ArrayA = { 1, 2, 3 };
  Int[3] ArrayB = { 4, 5, 6 };
  ArrayB = Array A;

  //So ArrayB now references Array A.
   //Now if I set

  ArrayA[0] = 0; //then
   if( ArrayB[0] = 0 &amp;&amp;  ArrayA==ArrayB.){}
  //  The logic comparator really just shows they use the same reference.



			<delay>2</delay>
			I  think though I would evaluate your objectives and see if there is another way.  
			<delay>2</delay>
			Or maybe use a library.  
			<delay>2</delay>
			Because a matrix like you are thinking is not native to Java.  
			<delay>2</delay>
			There are lots of strange behaviors which I have done a terrible job explaining.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ hashcode () returns ^ long ^ integer </pattern>
		<template>
			
			Well, one good reason is that the hashCode based data structures (HashSet, HashMap) use an array to store the bins, and arrays are limited to int indices.
			<delay>2</delay>
			You will gain nothing by a long hashCode() if you must map it to an int array index.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ convert java list ^ scala ^ array </pattern>
		<template>
			
			You have to create the target array first, and provide it as input for the toArray method:

list.toArray(Array.ofDim[POJO](list.size))



			<delay>2</delay>
			This API shifts all the problems with array instantiation from the toArray method to you, so it is your responsibility to make sure that POJO is either something concrete, or to provide a ClassTag.




			<delay>2</delay>
			You could also do the conversion in two steps, first using asScala from JavaConverters:

import scala.collection.JavaConverters._


and then invoking .toArray from the Scala API (unlike Java's API, it preserves the type):

toArray0

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ remove duplicate numbers ^ without using ^ util ^ java ^ collections ^ array </pattern>
		<template>
			
			public class UniqueElementinAnArray 
{
    public static void main(String[] args) 
    {
        int[] a = {10,10,10,10,10,100};
        int[] output = new int[a.length];
        int count = 0;
        int num = 0;

        //Iterate over an array
        for(int i=0; i&lt;a.length; i++)
        {
            num=a[i];
            boolean flag = check(output,num);
            if(flag==false)
            {
                output[count]=num;
                ++count;
            }

        }

        //print the all the elements from an array except zero's (0)
        for (int i : output) 
        {
            if(i!=0 )
                System.out.print(i+"  ");
        }

    }

    /***
     * If a next number from an array is already exists in unique array then return true else false
     * @param arr   Unique number array. Initially this array is an empty.
     * @param num   Number to be search in unique array. Whether it is duplicate or unique.
     * @return  true: If a number is already exists in an array else false 
     */
    public static boolean check(int[] arr, int num)
    {
        boolean flag = false;
        for(int i=0;i&lt;arr.length; i++)
        {
            if(arr[i]==num)
            {
                flag = true;
                break;
            }
        }
        return flag;
    }

}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ insert arithmetic operator (+ ^ possible ^ java ^ array </pattern>
		<template>
			
			Yes, you can store them in a char[] or String[]:

char[] chars = new char[10];
chars[0] = '+';

String[] array = new String[10];
array[0] = "+";



			<delay>2</delay>
			A better way is use some kind of Collection, for example, java.util.List:

List&lt;String&gt; list = new ArrayList&lt;&gt;();
list.add("+");
list.add("-");
list.add("*");
list.add("/");


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ url ^ image ^ convert </pattern>
		<template>
			
			Just use them in Glide like this:

GlideApp.with(this).load(ENTER_YOUR_URL_HERE).into(imageView);


don't forget to implement it first.
			<delay>2</delay>
			For more information just follow this link

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ byte array java ^ replace ^ r ^ n </pattern>
		<template>
			
			If you are talking about 0x0D 0x0A characters  you can use intermediate String and replaceAll method to do that:

byte[] result = new String(myByteArray).replaceAll("\r\r\n", "\n").getBytes();


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ override next () ^ jagged array java </pattern>
		<template>
			
			This might be a wrong answer to your question.
			<delay>2</delay>
			I'll remove it in that case, but maybe you can use it for what you want to achieve:

int[][] it = {{1,2}, {3,4,5}};

OfInt iterator = Arrays.stream(it).flatMapToInt(x -&gt; IntStream.of(x)).iterator();
iterator.forEachRemaining((IntConsumer) System.out::print);


Stream the jagged array, flatmap it into one single IntStream and then do what you want with it.
			<delay>2</delay>
			In this example I fetched the iterator but you might only want:

Arrays.stream(it).flatMapToInt(x -&gt; IntStream.of(x)).forEach((IntConsumer) System.out::print); 



			<delay>2</delay>
			In forEach you can do what you need, or use some other method of IntStream

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java lists ^ java collections ^ convert oracle ^ sql ^ example ^ array </pattern>
		<template>
			
			You could try this: 

oracle.sql.ARRAY a = ...
String[] strArray = (String[])a.getArray();
List lstArray = java.util.Arrays.asList(strArray);


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ chess co ^ 2d array ^ row ^ ordinate ^ convert ^ column </pattern>
		<template>
			
			The below code shows you how to do the transformation you need:

String str = "g3";
System.out.println(str.charAt(0) - 'a');
System.out.println(str.charAt(1) - '1');


will print

6
2


so 
str.charAt(0) - 'a' to transform the letter 
str.charAt(1) - '1' to transform the number

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ one line ^ java 8 ^ initialize list ^ list </pattern>
		<template>
			
			List&lt;List&lt;Integer&gt;&gt; list = Arrays.asList(Arrays.asList(1,2), Arrays.asList(3,4));



			<delay>2</delay>
			In Java 9+ you can replace Arrays.asList() with List.of().

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ add elements ^ use ^ loop ^ enhanced ^ array </pattern>
		<template>
			
			You can never "add" an element to an array.
			<delay>2</delay>
			It is a fixed-size data structure, with or without an enhanced for loop.
			<delay>2</delay>
			All you can do is to allocate an array, and then set its elements.


			<delay>2</delay>
			It doesn't make sense to allocate the array you are iterating in the enhanced for loop - what then are you iterating?
			<delay>2</delay>
			- and as you have stated in the question, you cannot set array elements (directly) in a for loop.


			<delay>2</delay>
			So, no.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ subclasses ^ java ^ collection </pattern>
		<template>
			
			Collection us an interface,  not a class, so pedantically it has no sub classes.
			<delay>2</delay>
			Rather, it has classes that implement it, and interfaces that extend it.
			<delay>2</delay>
			As it is a public interface,  anyone could,  in principle, write a class that implements it.
			<delay>2</delay>
			So it is impossible to list all those classes. 

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ array index ^ possible ^ char </pattern>
		<template>
			
			YES!
			<delay>2</delay>
			It is possible.

			<delay>2</delay>
			It is a basic rule of java.

			<delay>2</delay>
			We can assign char value to int type of variable.
			<delay>2</delay>
			Now that int type variable will not store a character but its ASCII value.
			<delay>2</delay>
			See the example

class Test{
    public static void main(String[] args){
        int num='a';
        System.out.println(num);//97
    }
}



			<delay>2</delay>
			you can see i've assigned 'a' into int type of variable.


			<delay>2</delay>
			In same case, whenever we pass char as index value, always ASCII value will be passed.
			<delay>2</delay>
			As we know, 97 is the ASCII value of a.


			<delay>2</delay>
			So if we access an array by passing 'a', internally 97th index of array will be called.


			<delay>2</delay>
			int num='a';
System.out.println(args[num]);//AIOOBE 



			<delay>2</delay>
			Here we got Exception like

Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 97
        at Test.main(Test.java:4)


			<delay>2</delay>
			Program is compiled fine, but we got exception at runtime because args is empty array right now.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ remove duplicate elements ^ list </pattern>
		<template>
			
			Using an additional class:

    static class Pair {
    String a, b;

    Pair(String s) {
        String[] arr = s.split(",");
        this.a = arr[0];
        this.b = arr[1];
    }

    static String pairToString(Pair p) {
        return p.a + "," + p.b;
    }

    @Override
    public int hashCode() {
        return Objects.hash(a, b) + Objects.hash(b, a);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Pair p = (Pair) o;
        return (p.a.equals(a) &amp;&amp; p.b.equals(b)) || (p.b.equals(a) &amp;&amp; p.a.equals(b));
    }


}


			<delay>2</delay>
			Now you can use:

 public static void main(String[] args) {
        List&lt;String&gt; list = Arrays.asList("f1,f2", "f2,f3", "f4,f5", "f2,f1", "f5,f4");
        List&lt;String&gt; strings = list
                .stream()
                .map(Pair::new)
                .distinct()
                .map(Pair::pairToString)
                .collect(Collectors.toList());
    }


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ array initializer ^ problem ^ allowed </pattern>
		<template>
			
			    public static void main(String[] args) {


            int[] array = new int[] {1,2,3,4,5};

        }
}



			<delay>2</delay>
			You are currently declaring the size of the array twice, the above will work. 

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ use arraylist ^ value pair ^ value ^ key ^ hashmap ^ datatype </pattern>
		<template>
			
			Little test with jshell (comes with OpenJDK 13):

var map = new HashMap&lt;String, List&lt;String&gt;&gt;();
map.put("first", new ArrayList&lt;String&gt;());
map.get("first").add("one");


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ new string value ^ execution </pattern>
		<template>
			
			The way you ask the question doesn't really fit to stackoverflow, as you are asking for a rather basic technique and do not provide at all what you have tried so far.
			<delay>2</delay>
			I'll answer you nonetheless.


			<delay>2</delay>
			You'd need to save the last picked String (or its index, a hash, some representation of your choice, ...) to a file, then when executing the code again you'd pick a random int, check if the File exists and if yes pick a new random Int until !
			<delay>2</delay>
			list[random].equals(lastString).
			<delay>2</delay>
			Again, save that string to said file.


			<delay>2</delay>
			Plus, you need to specify what exactly you mean by code being executed again.
			<delay>2</delay>
			Are we speaking about persistent or temporal memory?

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ without using arraylist ^ array without copy ^ array size dynamically ^ way ^ increase ^ extend </pattern>
		<template>
			
			
  I should not increase the array size by using Array copy or I should not use Arraylist


If you can't use Arrays.copy() and you can't use ArrayList, then just do the resize yourself, e.g.:

public static String[] increaseSize(String[] array, int newLength) {
    if (array.length &gt;= newLength)
        return array;
    String[] newArray = new String[newLength];
    for (int i = 0; i &lt; array.length; i++)
        newArray[i] = array[i];
    return newArray;
}



			<delay>2</delay>
			Since Java arrays are fixed-size, the only way to change the size is to create a new array and copy the elements.
			<delay>2</delay>
			Whether doing it yourself, or using some API methods to help you, that's what has to happen.


			<delay>2</delay>
			There is no such thing as a dynamically-sized array in Java.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ two dimensional array ^ pass size ^ array ^ swift </pattern>
		<template>
			
			You can initiate and reserve capacity of an array in swift as follows.


			<delay>2</delay>
			var tempArray: [Span] = []
tempArray.reserveCapacity(count)


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ int [] aa ={' 12 ',' 2 '}; ^ int [] aa ={' 1 ',' 2 '}; ^ invalid character constant ^ error showing ^ invalid ^ valid </pattern>
		<template>
			
			'1' and '2' are chars, which can be promoted to int, so they can be assigned to an int array.
			<delay>2</delay>
			Note that the numeric values of '1' and '2' is not equal to the numbers 1 and 2.
			<delay>2</delay>
			They are actually 49 and 50.


			<delay>2</delay>
			i.e. 

int[] aa={'1','2'}; 


will result in the same array as:

int[] aa={49,50}; 


'12' is not a valid constant in Java.


			<delay>2</delay>
			If you want a String, it should be "12" (but in that case, you can't assign it to an int array).
			<delay>2</delay>
			If you want an int, it should be 12 (i.e. without any quotes).

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ given string ^ z ^ numbers ^ get ^ character ^ array </pattern>
		<template>
			
			First replace non-letter characters with blank space, then convert String to char array:

char[] onlyLetters = "regex".replaceAll("[^A-Za-z]+", "").toCharArray(); 


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ two value ^ get list ^ year ^ java </pattern>
		<template>
			
			You can use LocalDate or LocalDateTime (jdk 8+):

LocalDate fromDate =  LocalDate.of(2018, 3, 11);
LocalDate toDate = LocalDate.now(); // 2020-03-11
long yearsD = fromDate.until(toDate, ChronoUnit.YEARS); // 2 years

LocalDateTime fromDateTime =  LocalDateTime.of(2018, 3, 11, 5, 45, 30);
LocalDateTime toDateTime = LocalDateTime.now(); // 2020-01-11T10:00:00.0000
long yearsDT = fromDateTime.until(toDateTime, ChronoUnit.YEARS); // 2 years


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java without ^ import statement ^ import java ^ arrays ), ^ arrays ^ work ^ util ^ little </pattern>
		<template>
			
			No, java.util.Arrays is not imported by default.


			<delay>2</delay>
			class Test {
    public static void main(String[] args) {
        int[] a = {1,2};
        int[] b = {1,3};

        System.out.println(Arrays.equals(a,b));
    }
}


Trying to compile this class will fail, due to Arrays being unknown.
			<delay>2</delay>
			You will need to prepend the file with import java.util.Arrays; for it to compile.


			<delay>2</delay>
			If you're talking about arrays generally, as in how int[] is supported by default, that's a different question, and you'll need to clarify and reword what you mean.
			<delay>2</delay>
			Simply, arrays are supported in C, the language Java is built upon.


			<delay>2</delay>
			EDIT:
			<delay>2</delay>
			Further reading here

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ write 2d arraylists ^ java </pattern>
		<template>
			
			SomeObject[] is array and SomeObject[][] is 2D array.
			<delay>2</delay>
			Below you can see example integer 2D array.


			<delay>2</delay>
			int[][] array2d = new int[][] {
  {1,2,3},
  {4,5,6},
  {7,8,9}
};

array2d[1][1] == 5; // this is true



			<delay>2</delay>
			There are no 2D ArrayLists, you can fake it by making normal array of ArrayLists or ArrayList containing multiple ArrayLists.


			<delay>2</delay>
			// Array of ArrayLists
ArrayList[] arr = new ArrayList[arraysize];

// ArrayList containing another ArrayList
ArrayList a = new ArrayList();
ArrayList b = new ArrayList();
a.add(b);


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ array index value increment ^ understand ^ trying ^ str ^ count ^ charat ^ )]++ </pattern>
		<template>
			
			Is count an array of a numeric type (int, long)?


			<delay>2</delay>
			You're indexing into a string, getting the ASCII character value blindly, and using it to index into another array. 


			<delay>2</delay>
			Then incrementing?
			<delay>2</delay>
			You may find that you aren't incrementing what you think you are.
			<delay>2</delay>
			What are you trying to do?
			<delay>2</delay>
			Hmm.


			<delay>2</delay>
			So, like "1" is 31, which is I think perhaps not what you wanted.


			<delay>2</delay>
			Perhaps something more like

Int idx = Integer.parseInt(are.charAt(t))
			<delay>2</delay>
			; //gives you 1 instead of 31
count [idx]++

Also -

YOUR ARRAY SIZE
			<delay>2</delay>
			WON'T CHANGE
			<delay>2</delay>
			BUT YOU ARE HIGHLY LIKELY TO THROW AN EXCEPTION

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ variable list like ^ list listobject ^ add element ^ java </pattern>
		<template>
			
			If you want to add element in List then simply do:

listObject.add(new Object[]{});



			<delay>2</delay>
			Or if you want to add to Object array inside list then use (Which is quite a long root due to restrictive behavior of array data structure,
			<delay>2</delay>
			Thats why ArrayList is alternative to achieve this. ):


			<delay>2</delay>
			    @Test
    public void testArray()  {


        List&lt;Object[]&gt; listObjects =  new ArrayList&lt;&gt;();
        listObjects.add(new Object[]{1,2});
         addX( listObjects.get(0).length , listObjects.get(0) , 3);

        listObjects.set(0,addX( listObjects.get(0).length , listObjects.get(0) , 3));

        System.out.println(listObjects.get(0));
    }

    public Object[] addX(int n, Object arr[], Object x)
    {
        int i;

        // create a new array of size n+1
        Object newarr[] = new Object[n + 1];

        // insert the elements from
        // the old array into the new array
        // insert all elements till n
        // then insert x at n+1
        for (i = 0; i &lt; n; i++)
            newarr[i] = arr[i];

        newarr[n] = x;

        return newarr;


    }


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ directly print arrays ^ java </pattern>
		<template>
			
			Because in Java, arrays are treated like Objects and not as a primitive type.
			<delay>2</delay>
			By default, when printing any object, the object's toString() method is called.
			<delay>2</delay>
			Arrays do not override the default toString method and such do not provide useful information about the contents of the array, so you should call Arrays.toString() instead. 

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java sorting algorithm problems </pattern>
		<template>
			
			Problem with this code is that it doesn't swap numbers.
			<delay>2</delay>
			Instead, it replaces array[i] with the minimum number found.
			<delay>2</delay>
			You can modify your loop like this to do the swapping.


			<delay>2</delay>
			        for (int i = 0; i &lt; array.length; i++) {

          int minIndex = i;
          for (int j = i; j &lt; array.length; j++) {

              if (array[j] &lt; array[minIndex]) {
                  minIndex = j;
              }

          }
          if (array[minIndex] != array[i]) {
            int wert = array[minIndex];
            array[minIndex] = array[i];
            array[i] = wert;

          }
        }


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ ** numbers ** ^ array list ^ strings ^ create </pattern>
		<template>
			
			List&lt;Number&gt; someList = new ArrayList&lt;&gt;();
someList.add(1);
someList.add(5.5);


Java has List interface.
			<delay>2</delay>
			And Number - like it says, accepts numbers only.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ java really support rectangular arrays ^ jagged arrays called ^ java ^ non </pattern>
		<template>
			
			A rectangular 2-dimensional array is just a special case of a jagged array.
			<delay>2</delay>
			Therefore, any language that supports jagged arrays will also support rectangular arrays, while the inverse is not necessarily true.

			<delay>2</delay>
			The expression int[][] numbers = new int[3][5]; is just syntactic sugar, and actually boils down to something like:
int[][] numbers = new int[3][];
numbers[0] = new int[5];
numbers[1] = new int[5];
numbers[2] = new int[5];

Nothing prevents you from turning a rectangular array into a jagged array after declaration:
int[][] numbers = new int[3][5];
numbers[0] = new int[10]; // works


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ remove () ^ pop () ^ material difference ^ java arraydeque </pattern>
		<template>
			
			There is no difference.
			<delay>2</delay>
			In fact, pop() and remove() methods both call removeFirst.
			<delay>2</delay>
			See https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/ArrayDeque.java
public E remove() {
    return removeFirst();
}

public E pop() {
    return removeFirst();
}


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ less elements ^ happens ^ capacity ^ arraylist </pattern>
		<template>
			
			The javadoc states:

Each ArrayList instance has a capacity.
			<delay>2</delay>
			The capacity is the size of the array used to store the elements in the list.
			<delay>2</delay>
			It is always at least as large as the list size.
			<delay>2</delay>
			As elements are added to an ArrayList, its capacity grows automatically.
			<delay>2</delay>
			The details of the growth policy are not specified beyond the fact that adding an element has constant amortized time cost.


			<delay>2</delay>
			Based on the above:


			<delay>2</delay>
			What happens when there are less elements in ArrayList than its capacity?


			<delay>2</delay>
			Given that the backing array's size is the &quot;capacity&quot;, there will be unused slots in the array.

			<delay>2</delay>
			(The implementation ensures that those unused slots contain null to avoid any memory leaks.)


			<delay>2</delay>
			Say capacity is 10, I add 5 elements to ArrayList.
			<delay>2</delay>
			Would they take 5 or 10 elements size in memory?


			<delay>2</delay>
			The size would be the size of 10 object references, since an ArrayList holds references to objects ... not the actual element objects themselves.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ convertion array [' xx ^ yy '] ^ xx ^ yy ^ map </pattern>
		<template>
			
			In Java you can use stream to convert your array to map.
			<delay>2</delay>
			I think below code snippet might help you:
Map&lt;String,String&gt; resultMap =  Arrays.stream(arr)
    .map(elem-&gt; elem.split(&quot;=&quot;))
    .collect(Collectors.toMap(val-&gt; val[0], val-&gt; val[1]));


			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ storing multiple objects ^ single array element ^ java </pattern>
		<template>
			
			No.
			<delay>2</delay>
			Any given element of an array is just that, one element.
			<delay>2</delay>
			The type of element does matter, though.

			<delay>2</delay>
			Consider an array of integers:

			<delay>2</delay>
			int[] x = {1, 4, 7, 10};


			<delay>2</delay>
			One element cannot 'hold' multiple elements.

			<delay>2</delay>
			But now consider an array of arrays of integers:

			<delay>2</delay>
			int[][] x = {
    {1},
    {2, 3},
    {4, 5, 6},
    {7, 8, 9, 10}
};


			<delay>2</delay>
			Each element is still just a single element.
			<delay>2</delay>
			There are four elements each of type int[].
			<delay>2</delay>
			Then, each of those has one element per element.
			<delay>2</delay>
			You can theoretically have as many layers of this as you want.
			<delay>2</delay>
			It can get confusing very quickly.

			<delay>2</delay>
			Another way to fit 'multiple elements into one element' would be to write your own class that holds multiple elements in whatever way is most useful to you, and make an array of those.


			<delay>2</delay>
			Note: above, I've used primitive arrays to demonstrate.
			<delay>2</delay>
			However, this also works with Java List objects:
ArrayList&lt;Integer&gt; x;  // list of integers

ArrayList&lt;ArrayList&lt;Integer&gt;&gt; x;  // list of ArrayList&lt;Integer&gt; objects, each of which is itself a list of integers

ArrayList&lt;Integer&gt;[] x;  // primitive array of ArrayList&lt;Integer&gt; objects
                         // (I recommend not doing this, it can get confusing)



			<delay>2</delay>
			If your question is about putting multiple types of objects in a single element, then you have to figure out what superclass encompasses both types (usually Object, if the types are remotely different), and make your list that type:
Object[] x = {Integer.valueOf(5), Double.valueOf(3.14), &quot;some_string&quot;};

Getting those objects back out again and putting them into their correct type, is difficult, so I don't recommend this.

			<delay>2</delay>
			You can also try building your own Union type, and making the list be that type.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ new class []{} ^ new class ^ 0 ]? ^ difference </pattern>
		<template>
			
			No difference.

			<delay>2</delay>
			Decompiling this:
final class Foo {
  Class[] a = new Class[]{};
  Class[] b = new Class[0];
}

yields
$
			<delay>2</delay>
			code_placeholder_2
That is, the two forms yield identical bytecode.

			<delay>2</delay>
		</template>
	</category>
	<category>
		
		<pattern>^ array form ^ create ^ code </pattern>
		<template>
			
			Create a Strint array with all weekdays ({&quot;Sunday&quot;, &quot;Monday&quot;...}) and than get the name by index like this:
int day = 2;
System.out.println(weekdays[day - 1]);//output Monday


			<delay>2</delay>
		</template>
	</category>
</aiml>
