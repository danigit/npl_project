<?xml version="1.0" ?>
<aiml>
	<category>
		
		<pattern>
			<!-- How do I remove repeated elements from ArrayList? -->
			^ remove repeated elements ^ arraylist 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					If you don't want duplicates in a Collection, you should consider why you're using a Collection that allows duplicates.
					<delay>2</delay>
					The easiest way to remove repeated elements is to add the contents to a Set (which will not allow duplicates) and then add the Set back to the ArrayList:

					<delay>2</delay>
					Set&lt;String&gt; set = new HashSet&lt;&gt;(yourList);<break/>yourList.clear();<break/>yourList.addAll(set);<break/>

					<delay>2</delay>
					Of course, this destroys the ordering of the elements in the ArrayList.

					<delay>2</delay>
				</li>
				<li>
					
					If you don't want duplicates, use a Set instead of a List.
					<delay>2</delay>
					To convert a List to a Set you can use the following code:
// list is some List of Strings<break/>Set&lt;String&gt; s = new HashSet&lt;String&gt;(list);<break/>
If really necessary you can use the same construction to convert a Set back into a List.

					<delay>2</delay>
				</li>
				<li>
					
					Although converting the ArrayList to a HashSet effectively removes duplicates, if you need to preserve insertion order, I'd rather suggest you to use this variant

					<delay>2</delay>
					// list is some List of Strings<break/>Set&lt;String&gt; s = new LinkedHashSet&lt;&gt;(list);<break/>
Then, if you need to get back a List reference, you can use again the conversion constructor.

					<delay>2</delay>
				</li>
				<li>
					
					As said before, you should use a class implementing the Set interface instead of List to be sure of the unicity of elements.
					<delay>2</delay>
					If you have to keep the order of elements, the SortedSet interface can then be used; the TreeSet class implements that interface.

					<delay>2</delay>
				</li>
				<li>
					
					Probably a bit overkill, but I enjoy this kind of isolated problem.
					<delay>2</delay>
					:)

					<delay>2</delay>
					This code uses a temporary Set (for the uniqueness check) but removes elements directly inside the original list.
					<delay>2</delay>
					Since element removal inside an ArrayList can induce a huge amount of array copying, the remove(int)-method is avoided.

					<delay>2</delay>
					public static &lt;T&gt; void removeDuplicates(ArrayList&lt;T&gt; list) {<break/>    int size = list.size();<break/>    int out = 0;<break/>    {<break/>        final Set&lt;T&gt; encountered = new HashSet&lt;T&gt;();<break/>        for (int in = 0; in &lt; size; in++) {<break/>            final T t = list.get(in);<break/>            final boolean first = encountered.add(t);<break/>            if (first) {<break/>                list.set(out++, t);<break/>            }<break/>        }<break/>    }<break/>    while (out &lt; size) {<break/>        list.remove(--size);<break/>    }<break/>}<break/>

					<delay>2</delay>
					While we're at it, here's a version for LinkedList (a lot nicer!):

					<delay>2</delay>
					public static &lt;T&gt; void removeDuplicates(LinkedList&lt;T&gt; list) {<break/>    final Set&lt;T&gt; encountered = new HashSet&lt;T&gt;();<break/>    for (Iterator&lt;T&gt; iter = list.iterator(); iter.hasNext(); ) {<break/>        final T t = iter.next();<break/>        final boolean first = encountered.add(t);<break/>        if (!first) {<break/>            iter.remove();<break/>        }<break/>    }<break/>}<break/>
Use the marker interface to present a unified solution for List:

					<delay>2</delay>
					public static &lt;T&gt; void removeDuplicates(List&lt;T&gt; list) {<break/>    if (list instanceof RandomAccess) {<break/>        // use first version here<break/>    } else {<break/>        // use other version here<break/>    }<break/>}<break/>
EDIT: I guess the generics-stuff doesn't really add any value here..
					<delay>2</delay>
					Oh well. :)

					<delay>2</delay>
				</li>
				<li>
					
					Here's a way that doesn't affect your list ordering:
ArrayList l1 = new ArrayList();<break/>ArrayList l2 = new ArrayList();<break/>Iterator iterator = l1.iterator();<break/>while (iterator.hasNext()) {<break/>    YourClass o = (YourClass) iterator.next();<break/>    if(!l2.contains(o)) l2.add(o);<break/>}<break/>
l1 is the original list, and l2 is the list without repeated items
(Make sure YourClass has the equals method according to what you want to stand for equality)

					<delay>2</delay>
				</li>
				<li>
					
					When you are filling the ArrayList, use a condition for each element.
					<delay>2</delay>
					For example:
    ArrayList&lt; Integer &gt; al = new ArrayList&lt; Integer &gt;(); <break/>    // fill 1 <break/>    for ( int i = 0; i &lt;= 5; i++ ) <break/>        if ( !al.contains( i ) ) <break/>            al.add( i ); <break/>    // fill 2 <break/>    for (int i = 0; i &lt;= 10; i++ ) <break/>        if ( !al.contains( i ) ) <break/>            al.add( i ); <break/>    for( Integer i: al )<break/>    {<break/>        System.out.print( i + " ");     <break/>    }<break/>

					<delay>2</delay>
					We will get an array {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

					<delay>2</delay>
				</li>
				<li>
					
					There is also ImmutableSet from Guava as an option (here is the documentation):
ImmutableSet.copyOf(list);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					for(int a=0;a&lt;myArray.size();a++){<break/>        for(int b=a+1;b&lt;myArray.size();b++){<break/>            if(myArray.get(a).equalsIgnoreCase(myArray.get(b))){<break/>                myArray.remove(b); <break/>                dups++;<break/>                b--;<break/>            }<break/>        }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					import java.util.*;<break/>class RemoveDupFrmString<break/>{<break/>    public static void main(String[] args)<break/>    {<break/>        String s="appsc";<break/>        Set&lt;Character&gt; unique = new LinkedHashSet&lt;Character&gt; ();<break/>        for(char c : s.toCharArray()) {<break/>            System.out.println(unique.add(c));<break/>        }<break/>        for(char dis:unique){<break/>            System.out.println(dis);<break/>        }<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					LinkedHashSet will do the trick.

					<delay>2</delay>
					String[] arr2 = {"5","1","2","3","3","4","1","2"};<break/>Set&lt;String&gt; set = new LinkedHashSet&lt;String&gt;(Arrays.asList(arr2));<break/>for(String s1 : set)<break/>    System.out.println(s1);<break/>System.out.println( "------------------------" );<break/>String[] arr3 = set.toArray(new String[0]);<break/>for(int i = 0; i &lt; arr3.length; i++)<break/>     System.out.println(arr3[i].toString());<break/>
//output: 5,1,2,3,4

					<delay>2</delay>
				</li>
				<li>
					
					public Set&lt;Object&gt; findDuplicates(List&lt;Object&gt; list) {<break/>        Set&lt;Object&gt; items = new HashSet&lt;Object&gt;();<break/>        Set&lt;Object&gt; duplicates = new HashSet&lt;Object&gt;();<break/>        for (Object item : list) {<break/>            if (items.contains(item)) {<break/>                duplicates.add(item);<break/>                } else { <break/>                    items.add(item);<break/>                    } <break/>            } <break/>        return duplicates;<break/>        }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					this can solve the problem:
private List&lt;SomeClass&gt; clearListFromDuplicateFirstName(List&lt;SomeClass&gt; list1) {<break/>     Map&lt;String, SomeClass&gt; cleanMap = new LinkedHashMap&lt;String, SomeClass&gt;();<break/>     for (int i = 0; i &lt; list1.size(); i++) {<break/>         cleanMap.put(list1.get(i).getFirstName(), list1.get(i));<break/>     }<break/>     List&lt;SomeClass&gt; list = new ArrayList&lt;SomeClass&gt;(cleanMap.values());<break/>     return list;<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you want to preserve your Order then it is best to use LinkedHashSet.

					<delay>2</delay>
					Because if you want to pass this List to an Insert Query by Iterating it, the order would be preserved.

					<delay>2</delay>
					Try this
LinkedHashSet link=new LinkedHashSet();<break/>List listOfValues=new ArrayList();<break/>listOfValues.add(link);<break/>

					<delay>2</delay>
					This conversion will be very helpful when you want to return a List but not a Set.

					<delay>2</delay>
				</li>
				<li>
					
					It is possible to remove duplicates from arraylist without using HashSet or one more arraylist. 

					<delay>2</delay>
					Try this code..

					<delay>2</delay>
					    ArrayList&lt;String&gt; lst = new ArrayList&lt;String&gt;();<break/>    lst.add("ABC");<break/>    lst.add("ABC");<break/>    lst.add("ABCD");<break/>    lst.add("ABCD");<break/>    lst.add("ABCE");<break/>    System.out.println("Duplicates List "+lst);<break/>    Object[] st = lst.toArray();<break/>      for (Object s : st) {<break/>        if (lst.indexOf(s) != lst.lastIndexOf(s)) {<break/>            lst.remove(lst.lastIndexOf(s));<break/>         }<break/>      }<break/>    System.out.println("Distinct List "+lst);<break/>
Output is
Duplicates List [ABC, ABC, ABCD, ABCD, ABCE]<break/>Distinct List [ABC, ABCD, ABCE]<break/>

					<delay>2</delay>
				</li>
				<li>
					
					In Java 8:
List&lt;String&gt; deduped = list.stream().distinct().collect(Collectors.toList());<break/>
Please note that the hashCode-equals contract for list members should be respected for the filtering to work properly.

					<delay>2</delay>
				</li>
				<li>
					
					    ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();<break/>    HashSet&lt;String&gt; unique = new LinkedHashSet&lt;String&gt;();<break/>    HashSet&lt;String&gt; dup = new LinkedHashSet&lt;String&gt;();<break/>    boolean b = false;<break/>    list.add("Hello");<break/>    list.add("Hello");<break/>    list.add("how");<break/>    list.add("are");<break/>    list.add("u");<break/>    list.add("u");<break/>    for(Iterator iterator= list.iterator();iterator.hasNext();)<break/>    {<break/>        String value = (String)iterator.next();<break/>        System.out.println(value);<break/>        if(b==unique.add(value))<break/>            dup.add(value);<break/>        else<break/>            unique.add(value);<break/>    }<break/>    System.out.println(unique);<break/>    System.out.println(dup);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you want to remove duplicates from ArrayList means find the below logic,
public static Object[] removeDuplicate(Object[] inputArray)<break/>{<break/>    long startTime = System.nanoTime();<break/>    int totalSize = inputArray.length;<break/>    Object[] resultArray = new Object[totalSize];<break/>    int newSize = 0;<break/>    for(int i=0; i&lt;totalSize; i++)<break/>    {<break/>        Object value = inputArray[i];<break/>        if(value == null)<break/>        {<break/>            continue;<break/>        }<break/>        for(int j=i+1; j&lt;totalSize; j++)<break/>        {<break/>            if(value.equals(inputArray[j]))<break/>            {<break/>                inputArray[j] = null;<break/>            }<break/>        }<break/>        resultArray[newSize++] = value;<break/>    }<break/>    long endTime = System.nanoTime()-startTime;<break/>    System.out.println("Total Time-B:"+endTime);<break/>    return resultArray;<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					This three lines of code can remove the duplicated element from ArrayList or any collection.

					<delay>2</delay>
					List&lt;Entity&gt; entities = repository.findByUserId(userId);<break/>Set&lt;Entity&gt; s = new LinkedHashSet&lt;Entity&gt;(entities);<break/>entities.clear();<break/>entities.addAll(s);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Code:
List&lt;String&gt; duplicatList = new ArrayList&lt;String&gt;();<break/>duplicatList = Arrays.asList("AA","BB","CC","DD","DD","EE","AA","FF");<break/>//above AA and DD are duplicate<break/>Set&lt;String&gt; uniqueList = new HashSet&lt;String&gt;(duplicatList);<break/>duplicatList = new ArrayList&lt;String&gt;(uniqueList); //let GC will doing free memory<break/>System.out.println("Removed Duplicate : "+duplicatList);<break/>

					<delay>2</delay>
					Note: Definitely, there will be memory overhead.

					<delay>2</delay>
				</li>
				<li>
					
					The @jonathan-stafford solution is OK.
					<delay>2</delay>
					But this don't preserve the list order.

					<delay>2</delay>
					If you want preserve the list order you have to use this:
public static &lt;T&gt; void removeDuplicate(List &lt;T&gt; list) {<break/>Set &lt;T&gt; set = new HashSet &lt;T&gt;();<break/>List &lt;T&gt; newList = new ArrayList &lt;T&gt;();<break/>for (Iterator &lt;T&gt;iter = list.iterator();    iter.hasNext(); ) {<break/>   Object element = iter.next();<break/>   if (set.add((T) element))<break/>      newList.add((T) element);<break/>   }<break/>   list.clear();<break/>   list.addAll(newList);<break/>}<break/>

					<delay>2</delay>
					It's only to complete the answer.
					<delay>2</delay>
					Very good!

					<delay>2</delay>
				</li>
				<li>
					
					        List&lt;String&gt; result = new ArrayList&lt;String&gt;();<break/>        Set&lt;String&gt; set = new LinkedHashSet&lt;String&gt;();<break/>        String s = "ravi is a good!boy. But ravi is very nasty fellow.";<break/>        StringTokenizer st = new StringTokenizer(s, " ,. ,!");<break/>        while (st.hasMoreTokens()) {<break/>            result.add(st.nextToken());<break/>        }<break/>         System.out.println(result);<break/>         set.addAll(result);<break/>        result.clear();<break/>        result.addAll(set);<break/>        System.out.println(result);<break/>output:<break/>[ravi, is, a, good, boy, But, ravi, is, very, nasty, fellow]<break/>[ravi, is, a, good, boy, But, very, nasty, fellow]<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Java 8 streams provide a very simple way to remove duplicate elements from a list.
					<delay>2</delay>
					Using the distinct method.

					<delay>2</delay>
					If we have a list of cities and we want to remove duplicates from that list it can be done in a single line - 
 List&lt;String&gt; cityList = new ArrayList&lt;&gt;();<break/> cityList.add("Delhi");<break/> cityList.add("Mumbai");<break/> cityList.add("Bangalore");<break/> cityList.add("Chennai");<break/> cityList.add("Kolkata");<break/> cityList.add("Mumbai");<break/> cityList = cityList.stream().distinct().collect(Collectors.toList());<break/>
How to remove duplicate elements from an arraylist

					<delay>2</delay>
				</li>
				<li>
					
					public static void main(String[] args){<break/>    ArrayList&lt;Object&gt; al = new ArrayList&lt;Object&gt;();<break/>    al.add("abc");<break/>    al.add('a');<break/>    al.add('b');<break/>    al.add('a');<break/>    al.add("abc");<break/>    al.add(10.3);<break/>    al.add('c');<break/>    al.add(10);<break/>    al.add("abc");<break/>    al.add(10);<break/>    System.out.println("Before Duplicate Remove:"+al);<break/>    for(int i=0;i&lt;al.size();i++){<break/>        for(int j=i+1;j&lt;al.size();j++){<break/>            if(al.get(i).equals(al.get(j))){<break/>                al.remove(j);<break/>                j--;<break/>            }<break/>        }<break/>    }<break/>    System.out.println("After Removing duplicate:"+al);<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Here is my answer without using any other data structure like set or hashmap etc.

					<delay>2</delay>
					public static &lt;T&gt; ArrayList&lt;T&gt; uniquefy(ArrayList&lt;T&gt; myList) {<break/>    ArrayList &lt;T&gt; uniqueArrayList = new ArrayList&lt;T&gt;();<break/>    for (int i = 0; i &lt; myList.size(); i++){<break/>        if (!uniqueArrayList.contains(myList.get(i))){<break/>            uniqueArrayList.add(myList.get(i));<break/>        }<break/>    }<break/>    return uniqueArrayList;<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					In Java, List permits ordered access of their elements.
					<delay>2</delay>
					They can have duplicates because their lookup key is the position not some hash code, every element can be modified while they remain in the list where as Set represents a collection of unique elements and while elements are in set, they must not be modified.
					<delay>2</delay>
					While there is no restriction preventing you from modifying elements in a set, if an element is modified, then it could become forever lost in the set.

					<delay>2</delay>
					public static void main(String[] args) {  <break/>           List&lt;String&gt; l = new ArrayList&lt;String&gt;();  <break/>           l.add("A");  <break/>           l.add("B");  <break/>           l.add("C");  <break/>           l.add("A");  <break/>           System.out.println("Before removing duplicates: ");  <break/>           for (String s : l) {  <break/>                System.out.println(s);  <break/>           }  <break/>           Set&lt;String&gt; set = new HashSet&lt;String&gt;(l);  <break/>           List&lt;String&gt; newlist = new ArrayList&lt;String&gt;(set);  <break/>           System.out.println("after removing duplicates: ");  <break/>           for (String s : newlist) {  <break/>                System.out.println(s);  <break/>           }  <break/>      }  <break/>
for reference , refer this link How to remove duplicates from ArrayList 

					<delay>2</delay>
				</li>
				<li>
					
					Would something like this work better ? 

					<delay>2</delay>
					public static void removeDuplicates(ArrayList&lt;String&gt; list) {<break/>Arraylist&lt;Object&gt; ar     = new Arraylist&lt;Object&gt;();<break/>Arraylist&lt;Object&gt; tempAR = new Arraylist&lt;Object&gt;();<break/>while (list.size()&gt;0){<break/>    ar.add(list(0));<break/>    list.removeall(Collections.singleton(list(0)));<break/>}<break/>list.addAll(ar);<break/>
}
That should maintain the order and also not be quadratic in run time.

					<delay>2</delay>
				</li>
				<li>
					
					If you're willing to use a third-party library, you can use the method distinct() in Eclipse Collections (formerly GS Collections).

					<delay>2</delay>
					ListIterable&lt;Integer&gt; integers = FastList.newListWith(1, 3, 1, 2, 2, 1);<break/>Assert.assertEquals(<break/>    FastList.newListWith(1, 3, 2),<break/>    integers.distinct());<break/>

					<delay>2</delay>
					The advantage of using distinct() instead of converting to a Set and then back to a List is that distinct() preserves the order of the original List, retaining the first occurrence of each element.
					<delay>2</delay>
					It's implemented by using both a Set and a List.

					<delay>2</delay>
					MutableSet&lt;T&gt; seenSoFar = UnifiedSet.newSet();<break/>int size = list.size();<break/>for (int i = 0; i &lt; size; i++)<break/>{<break/>    T item = list.get(i);<break/>    if (seenSoFar.add(item))<break/>    {<break/>        targetCollection.add(item);<break/>    }<break/>}<break/>return targetCollection;<break/>

					<delay>2</delay>
					If you cannot convert your original List into an Eclipse Collections type, you can use ListAdapter to get the same API.

					<delay>2</delay>
					MutableList&lt;Integer&gt; distinct = ListAdapter.adapt(integers).distinct();<break/>
Note: I am a committer for Eclipse Collections.

					<delay>2</delay>
				</li>
				<li>
					
					ArrayList&lt;String&gt; city=new ArrayList&lt;String&gt;();<break/>city.add("rajkot");<break/>city.add("gondal");<break/>city.add("rajkot");<break/>city.add("gova");<break/>city.add("baroda");<break/>city.add("morbi");<break/>city.add("gova");<break/>HashSet&lt;String&gt; hashSet = new HashSet&lt;String&gt;();<break/>hashSet.addAll(city);<break/>city.clear();<break/>city.addAll(hashSet);<break/>Toast.makeText(getActivity(),"" + city.toString(),Toast.LENGTH_SHORT).show();<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Suppose we have a list of String like:
List&lt;String&gt; strList = new ArrayList&lt;&gt;(5);<break/>// insert up to five items to list.        <break/>

					<delay>2</delay>
					Then we can remove duplicate elements in multiple ways.

					<delay>2</delay>
					Prior to Java 8
List&lt;String&gt; deDupStringList = new ArrayList&lt;&gt;(new HashSet&lt;&gt;(strList));<break/>
Note: If we want to maintain the insertion order then we need to use LinkedHashSet in place of HashSet

					<delay>2</delay>
					Using Guava

					<delay>2</delay>
					List&lt;String&gt; deDupStringList2 = Lists.newArrayList(Sets.newHashSet(strList));<break/>
Using Java 8
List&lt;String&gt; deDupStringList3 = strList.stream().distinct().collect(Collectors.toList());<break/>
Note:  
					<delay>2</delay>
					In case we want to collect the result in a specific list implementation e.g. LinkedList then we can modify the above example as:
List&lt;String&gt; deDupStringList3 = strList.stream().distinct()<break/>                 .collect(Collectors.toCollection(LinkedList::new));<break/>

					<delay>2</delay>
					We can use String0 also in the above code but it may not give expected performace benefits.
					<delay>2</delay>
					Check this question for more.

					<delay>2</delay>
				</li>
				<li>
					
					You can also do it this way, and preserve order:
// delete duplicates (if any) from 'myArrayList'<break/>myArrayList = new ArrayList&lt;String&gt;(new LinkedHashSet&lt;String&gt;(myArrayList));<break/>

					<delay>2</delay>
				</li>
				<li>
					
					This is used for your Custom Objects list 
   public List&lt;Contact&gt; removeDuplicates(List&lt;Contact&gt; list) {<break/>    // Set set1 = new LinkedHashSet(list);<break/>    Set set = new TreeSet(new Comparator() {<break/>        @Override<break/>        public int compare(Object o1, Object o2) {<break/>            if (((Contact) o1).getId().equalsIgnoreCase(((Contact) o2).getId()) /*&amp;&amp;<break/>                    ((Contact)o1).getName().equalsIgnoreCase(((Contact)o2).getName())*/) {<break/>                return 0;<break/>            }<break/>            return 1;<break/>        }<break/>    });<break/>    set.addAll(list);<break/>    final List newList = new ArrayList(set);<break/>    return newList;<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					you can use nested loop in follow :
ArrayList&lt;Class1&gt; l1 = new ArrayList&lt;Class1&gt;();<break/>ArrayList&lt;Class1&gt; l2 = new ArrayList&lt;Class1&gt;();<break/>        Iterator iterator1 = l1.iterator();<break/>        boolean repeated = false;<break/>        while (iterator1.hasNext())<break/>        {<break/>            Class1 c1 = (Class1) iterator1.next();<break/>            for (Class1 _c: l2) {<break/>                if(_c.getId() == c1.getId())<break/>                    repeated = true;<break/>            }<break/>            if(!repeated)<break/>                l2.add(c1);<break/>        }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you are using model type List&lt; T>/ArrayList&lt; T> .
					<delay>2</delay>
					Hope,it's help you.

					<delay>2</delay>
					Here is my code without using any other data structure like set or hashmap
for (int i = 0; i &lt; Models.size(); i++){<break/>for (int j = i + 1; j &lt; Models.size(); j++) {       <break/> if (Models.get(i).getName().equals(Models.get(j).getName())) {    <break/> Models.remove(j);<break/>   j--;<break/>  }<break/> }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Time Complexity : O(n) : Without Set
private static void removeDup(ArrayList&lt;String&gt; listWithDuplicateElements) {<break/>    System.out.println(" Original Duplicate List :" + listWithDuplicateElements);<break/>    List&lt;String&gt; listWithoutDuplicateElements = new ArrayList&lt;&gt;(listWithDuplicateElements.size());<break/>    listWithDuplicateElements.stream().forEach(str -&gt; {<break/>        if (listWithoutDuplicateElements.indexOf(str) == -1) {<break/>            listWithoutDuplicateElements.add(str);<break/>        }<break/>    });     <break/>    System.out.println(" Without Duplicate List :" + listWithoutDuplicateElements);<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					This is the right one (if you are concerned about the overhead of HashSet.

					<delay>2</delay>
					 public static ArrayList&lt;String&gt; removeDuplicates (ArrayList&lt;String&gt; arrayList){<break/>    if (arrayList.isEmpty()) return null;  //return what makes sense for your app<break/>    Collections.sort(arrayList, String.CASE_INSENSITIVE_ORDER);<break/>    //remove duplicates<break/>    ArrayList &lt;String&gt; arrayList_mod = new ArrayList&lt;&gt;();<break/>    arrayList_mod.add(arrayList.get(0));<break/>    for (int i=1; i&lt;arrayList.size(); i++){<break/>        if (!arrayList.get(i).equals(arrayList.get(i-1))) arrayList_mod.add(arrayList.get(i));<break/>    }<break/>    return arrayList_mod;<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Set&lt;String&gt; strSet = strList.stream().collect(Collectors.toSet());<break/>
Is the easiest way to remove your duplicates.

					<delay>2</delay>
				</li>
				<li>
					
					If you want your list to automatically ignore duplicates and preserve its order, you could create a HashList(a HashMap embedded List).

					<delay>2</delay>
					public static class HashList&lt;T&gt; extends ArrayList&lt;T&gt;{<break/>        private HashMap &lt;T,T&gt; hashMap;<break/>        public HashList(){<break/>            hashMap=new HashMap&lt;&gt;();<break/>        }<break/>        @Override<break/>        public boolean add(T t){<break/>            if(hashMap.get(t)==null){<break/>                hashMap.put(t,t);<break/>                return super.add(t);<break/>            }else return false;<break/>        }<break/>        @Override<break/>        public boolean addAll(Collection&lt;? extends T&gt; c){<break/>            HashList&lt;T&gt; addup=(HashList&lt;T&gt;)c;<break/>            for(int i=0;i&lt;addup.size();i++){<break/>                add(addup.get(i));<break/>            }return true;<break/>        }<break/>    }<break/>
Usage Example:
HashList&lt;String&gt; hashlist=new HashList&lt;&gt;();<break/>hashList.add("hello");<break/>hashList.add("hello");<break/>System.out.println(" HashList: "+hashlist);<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ remove repeated elements ^ arraylist </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How can I see if an element in an int array is empty? -->
			^ see ^ element ^ int array ^ empty 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					There is no such thing as an "empty" element in a Java array.
					<delay>2</delay>
					If the array's length is at least six, then element 5 exists and it has a value.
					<delay>2</delay>
					If you have not assigned anything else to that location, then it will have the value zero, just like an object's uninitialized field would have.

					<delay>2</delay>
					If it is an array of Object descendants, then you can check whether the element is equal to null.

					<delay>2</delay>
				</li>
				<li>
					
					Elements in primitive arrays can't be empty.  
					<delay>2</delay>
					They'll always get initialized to something (usually 0 for int arrays, but depends on how you declare the array).

					<delay>2</delay>
					If you declare the array like so (for example):
int [] myArray ;<break/>myArray = new int[7] ;<break/>
then all of the elements will default to 0.

					<delay>2</delay>
					An alternative syntax for declaring arrays is
int[] myArray = { 12, 7, 32, 15, 113, 0, 7 };<break/>
where the initial values for an array (of size seven in this case) are given in the curly braces {}.

					<delay>2</delay>
				</li>
				<li>
					
					You have to define what you mean by empty.
					<delay>2</delay>
					Depending on the datatype of the array you can decide on the semantics of empty.
					<delay>2</delay>
					For example, if you have an array of ints you can decide that 0 is empty.
					<delay>2</delay>
					Or if the array is of reference types then you can decide that null is empty.
					<delay>2</delay>
					Then you simply check by comparing array[5] ==
					<delay>2</delay>
					null or array[5] =
					<delay>2</delay>
					= 0
					<delay>2</delay>
					etc.

					<delay>2</delay>
				</li>
				<li>
					
					Primitive arrays (int, float, char, etc) are never "empty" (by which I assume you mean "null"), because primitive array elements can never be null.

					<delay>2</delay>
					By default, an int array usually contains 0 when allocated.  
					<delay>2</delay>
					However, I never rely on this (spent too much time writing C code, I guess).

					<delay>2</delay>
					One way is to pick a value that you want to treat as "uninitialized".  
					<delay>2</delay>
					It could be 0, or -1, or some other value that you're not going to use as a valid value.  
					<delay>2</delay>
					Initialize your array to that value after allocating it.

					<delay>2</delay>
					Object arrays (String[] and any array of objects that extend Object), can have null elements, so you could create an Integer[] array and initialize it to nulls.
					<delay>2</delay>
					I think I like that idea better than using a magic value as described above.

					<delay>2</delay>
				</li>
				<li>
					
					Create a constant to define the empty value, eg:
private static final int EMPTY = -1;<break/>
then create the array like this:

					<delay>2</delay>
					int[] myArray = new int[size];<break/>Arrays.fill(myArray, EMPTY);<break/>
then to check if an element is 'empty', do this:
if (myArray[i] == EMPTY)<break/>{<break/>   //element i is empty<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ see ^ element ^ int array ^ empty </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java Arrays & Generics : Java Equivalent to C# IEnumerable -->
			^ java arrays ^ generics ^ java equivalent ^ c ^ ienumerable 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Iterable &lt;T&gt;

					<delay>2</delay>
				</li>
				<li>
					
					Are you looking for Iterable&lt;String&gt;?

					<delay>2</delay>
					Iterable&lt;T&gt; &lt;=&gt; IEnumerable&lt;T&gt;<break/>Iterator&lt;T&gt; &lt;=&gt; IEnumerator&lt;T&gt;<break/>

					<delay>2</delay>
				</li>
				<li>
					
					I believe the Java equivalent is Iterable&lt;String&gt;.
					<delay>2</delay>
					Although String[] doesn't implement it, you can loop over the elements anyway:

					<delay>2</delay>
					String[] strings = new String[]{"this", "that"};<break/>for (String s : strings) {<break/>    // do something<break/>}<break/>

					<delay>2</delay>
					If you really need something that implements Iterable&lt;String&gt;, you can do this:
String[] strings = new String[]{"this", "that"};<break/>Iterable&lt;String&gt; stringIterable = Arrays.asList(strings);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Iterable&lt;String&gt; is the equivalent of IEnumerable&lt;string&gt;.

					<delay>2</delay>
					It would be an odditity in the type system if arrays implemented Iterable.
					<delay>2</delay>
					String[] is an instance of Object[], but Iterable&lt;String&gt; is not an Iterable&lt;Object&gt;.
					<delay>2</delay>
					Classes and interfaces cannot multiply implement the same generic interface with different generic arguments.

					<delay>2</delay>
					String[] will work just like an Iterable in the enhanced for loop.

					<delay>2</delay>
					Iterable&lt;String&gt;0 can easily be turned into an Iterable&lt;String&gt;1:

					<delay>2</delay>
					Iterable&lt;String&gt;2
Prefer collections over arrays (for non-primitives anyway).
					<delay>2</delay>
					Arrays of reference types are a bit odd, and are rarely needed since Java 1.5.

					<delay>2</delay>
				</li>
				<li>
					
					Iterable&lt;T&gt; is OK, but there is a small problem.
					<delay>2</delay>
					It cannot be used easily in stream() i.e lambda expressions.

					<delay>2</delay>
					If you want so, you should get it's spliterator, and use the class StreamSupport(). 

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java arrays ^ generics ^ java equivalent ^ c ^ ienumerable </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Is there a Java array/list which is statically typed AND variable length -->
			^ java array ^ list ^ statically typed ^ variable length 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					If by "variable length" you mean that the size will change over time, then you probably want a LinkedList rather than an ArrayList:

					<delay>2</delay>
					print("List&lt;Foo&gt; fooList = new LinkedList&lt;Foo&gt;();");<break/>

					<delay>2</delay>
					That way you get better performance when adding a bunch of elements.

					<delay>2</delay>
				</li>
				<li>
					
					I don't understand, what's so hard about:

					<delay>2</delay>
					List&lt;Foo&gt; fooList = new ArrayList&lt;Foo&gt;();<break/>

					<delay>2</delay>
					I guess you could define a class:

					<delay>2</delay>
					public class FooList extends ArrayList&lt;Foo&gt; {<break/>    ...<break/>}<break/>
if you want to avoid the angle brackets...

					<delay>2</delay>
				</li>
				<li>
					
					If you use generics (java 5), you can avoid all casting with
 List&lt;String&gt; myList = new ArrayList&lt;String&gt;();<break/> myList.add(" a test");<break/> String temp = myList.get(0);<break/>
Unless I am missing something in your question that should cover both needs.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java array ^ list ^ statically typed ^ variable length </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java sort String array of file names by their extension -->
			^ java sort string array ^ file names ^ extension 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					If I remember correctly, the Arrays.sort(...) takes a Comparator&lt;> that it will use to do the sorting.  
					<delay>2</delay>
					You can provide an implementation of it that looks at the extension part of the string.

					<delay>2</delay>
				</li>
				<li>
					
					You can implement a custom Comparator of Strings.  
					<delay>2</delay>
					Make it sort them by the substring after the last index of '.'.  
					<delay>2</delay>
					Then pass in the comparator and your array into 
Arrays.sort(stringArray, yourComparator);<break/>//  An implementation of the compare method<break/>public int compare(String o1, String o2) {<break/>    return o1.substring(o1.lastIndexOf('.')).compareTo(o2.substring(o2.lastIndexOf('.'));<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Create a Comparator and compare the string extensions.
					<delay>2</delay>
					Take a look at the following
http://java.sun.com/j2se/1.4.2/docs/api/java/util/Comparator.html

					<delay>2</delay>
					Then pass in your List of strings to Arrays.sort(List, Comparator)

					<delay>2</delay>
				</li>
				<li>
					
					Create your own Comparator that treats the strings as filenames and compares them based on the extensions.  
					<delay>2</delay>
					Then use Arrays.sort with the Comparator argument.

					<delay>2</delay>
				</li>
				<li>
					
					Arrays.sort(filenames, new Comparator&lt;String&gt;() {<break/>    @Override<break/>    public int compare(String s1, String s2) {<break/>        // the +1 is to avoid including the '.' in the extension and to avoid exceptions<break/>        // EDIT:<break/>        // We first need to make sure that either both files or neither file<break/>        // has an extension (otherwise we'll end up comparing the extension of one<break/>        // to the start of the other, or else throwing an exception)<break/>        final int s1Dot = s1.lastIndexOf('.');<break/>        final int s2Dot = s2.lastIndexOf('.');<break/>        if ((s1Dot == -1) == (s2Dot == -1)) { // both or neither<break/>            s1 = s1.substring(s1Dot + 1);<break/>            s2 = s2.substring(s2Dot + 1);<break/>            return s1.compareTo(s2);<break/>        } else if (s1Dot == -1) { // only s2 has an extension, so s1 goes first<break/>            return -1;<break/>        } else { // only s1 has an extension, so s1 goes second<break/>            return 1;<break/>        }<break/>    }<break/>});<break/>

					<delay>2</delay>
					For completeness: java.util.Arrays and java.util.Comparator.

					<delay>2</delay>
				</li>
				<li>
					
					If you just want to group the files by their extension and do not care about the actual alphabetical order, you can use this:

					<delay>2</delay>
					I think the simplest thing you can do that also works when the filenname does not have a ".
					<delay>2</delay>
					" is to just reverse the names and compare them.

					<delay>2</delay>
					Arrays.sort(ary, new Comparator&lt;String&gt;() {<break/>    @Override<break/>    public int compare(String o1, String o2) {<break/>        String r1 = new StringBuffer(o1).reverse().toString();<break/>        String r2 = new StringBuffer(o2).reverse().toString();<break/>        return r1.compareTo(r2);<break/>    }<break/>});<break/>

					<delay>2</delay>
					Its a shame that java's string does not even have a reverse().

					<delay>2</delay>
				</li>
				<li>
					
					Comparators are often hard to get exactly right, and the comparison key has to be generated for every comparison which for most sorting algorithms mean O(n log n).  
					<delay>2</delay>
					Another approach is to create (key, value) pairs for each item you need to sort, put them in a TreeMap, and then ask for the values as these are sorted according to the key.

					<delay>2</delay>
					For instance 
import java.util.Arrays;<break/>import java.util.TreeMap;<break/>public class Bar {<break/>    public static void main(String[] args) {<break/>        TreeMap&lt;String, String&gt; m2 = new TreeMap&lt;String, String&gt;();<break/>        for (String string : Arrays.asList(new String[] { "#3", "#2", "#1" })) {<break/>            String key = string.substring(string.length() - 1);<break/>            String value = string;<break/>            m2.put(key, value);<break/>        }<break/>        System.out.println(m2.values());<break/>    }<break/>}<break/>
prints out 
[#1, #2, #3]

					<delay>2</delay>
					You should easily be able to adapt the key calculation to your problem.

					<delay>2</delay>
					This only calculates the key once per entry, hence O(n) -
					<delay>2</delay>
					(but the sort is still O(n log n)).  
					<delay>2</delay>
					If the key calculation is expensive or n is large this might be quite measurable.

					<delay>2</delay>
				</li>
				<li>
					
					    String DELIMETER = File.separator + ".";<break/>    List&lt;String&gt; orginalList = new CopyOnWriteArrayList&lt;&gt;(Arrays.asList(listOfFileNames));<break/>    Set&lt;String&gt; setOfuniqueExtension = new TreeSet&lt;&gt;();<break/>    for (String item : listOfFileNames) {<break/>        if (item.contains(".")) {<break/>            String[] split = item.split(DELIMETER);<break/>            String temp = "." + split[split.length - 1];<break/>            setOfuniqueExtension.add(temp);<break/>        }<break/>    }<break/>    List&lt;String&gt; finalListOfAllFiles = new LinkedList&lt;&gt;();<break/>    setOfuniqueExtension.stream().forEach((s1) -&gt; {<break/>        for (int i = 0; i &lt; orginalList.size(); i++) {<break/>            if (orginalList.get(i).contains(s1)) {<break/>                finalListOfAllFiles.add(orginalList.get(i));<break/>                orginalList.remove(orginalList.get(i));<break/>                i--;<break/>            }<break/>        }<break/>    });<break/>    orginalList.stream().filter((s1) -&gt; (!finalListOfAllFiles.contains(s1))).forEach((s1) -&gt; {<break/>        finalListOfAllFiles.add(s1);<break/>    });<break/>    return finalListOfAllFiles;<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java sort string array ^ file names ^ extension </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Do 2D arrays use more resources than 1D arrays in Java? -->
			^ 2d arrays use ^ resources ^ 1d arrays ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					int[50][8] is 50 arrays of length 8
int[8][50] is 8 arrays of length 50
int[400]
					<delay>2</delay>
					is one array 400.

					<delay>2</delay>
					Each array has an overhead of about 16 bytes.

					<delay>2</delay>
					However, for the sizes you have here, it really doesn't matter.
					<delay>2</delay>
					You are not going to be saving much either way.

					<delay>2</delay>
				</li>
				<li>
					
					I suggest writing a small performance test for this with very large arrays to see the actual difference.
					<delay>2</delay>
					In reality I don't think this would make the slightest difference.

					<delay>2</delay>
				</li>
				<li>
					
					One additional useage point (came from a reference I unfortunately can't find now, but fairly commonsensical)-
The authors of this paper were testing various ways of compressing sparse arrays into mutidimensional arrays.
					<delay>2</delay>
					One thing they noticed is that it makes a  difference in terms of speed which way you iterate -

					<delay>2</delay>
					The idea was that if you have int[i][j] it was faster to do
for (i) { <break/>     for (j)<break/>
than to do 
for (j) { <break/>     for (i)<break/>
because in the first instance you're iterating through elements stored contiguously.

					<delay>2</delay>
				</li>
				<li>
					
					you could tweak a tiny amout of memory by using an int[]
					<delay>2</delay>
					myInt = int[400] array, and manually accessing an int at position (x,y)  with myInt[x+y*50]
that would save you 50 32-bit pieces of memory.
					<delay>2</delay>
					accessing it that way will maybe (who knows exactly what the hotspot compiler does to this..) take one more instruction for the multiplication.

					<delay>2</delay>
					that kind of micro-optimisation will most likely not make your app perform better, and it will decrease readability.

					<delay>2</delay>
				</li>
				<li>
					
					There appears to be three things to compare here.

					<delay>2</delay>
					new int[50][8]

					<delay>2</delay>
					new int[8][50]

					<delay>2</delay>
					new int[400]

					<delay>2</delay>
					Now, I get this confused, but the way to remember is to think of new int[50][] which is valid.

					<delay>2</delay>
					So new int[50][8] is an array of 50 arrays of size 8 (51 objects).
					<delay>2</delay>
					new int[8][50] is an array of 8 arrays of size 50 (9 objects).
					<delay>2</delay>
					9 objects will have a lower overhead than 51.
					<delay>2</delay>
					new int[400] is just one object.

					<delay>2</delay>
					However, it at this size it probably doesn't make any measurable difference to the performance of your program.
					<delay>2</delay>
					You might want to encapsulate the array(s) within an object that will allow you to change the implementation and provide a more natural interface to client code.

					<delay>2</delay>
				</li>
				<li>
					
					In the first case you have one array object pointing to fifty array objects holding 8 int's.

					<delay>2</delay>
					So 1 + 50 array objects + fifty pointers in the first array object.

					<delay>2</delay>
					In the second case you have one array object pointing to 8 array objects holding 50 int's.

					<delay>2</delay>
					So 1 + 8 array objects + eight pointers in the first array object.  
					<delay>2</delay>
					Holding the int's is a wash. 

					<delay>2</delay>
					There is not a good way to evaluate CPU usage for this.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ 2d arrays use ^ resources ^ 1d arrays ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Removing an element from an Array (Java) -->
			^ removing ^ element ^ array ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You can't remove an element from the basic Java array.
					<delay>2</delay>
					Take a look at various Collections and ArrayList instead.

					<delay>2</delay>
				</li>
				<li>
					
					Sure, create another array :)

					<delay>2</delay>
				</li>
				<li>
					
					Nice looking solution would be to use a List instead of array in the first place.

					<delay>2</delay>
					List.remove(index)<break/>

					<delay>2</delay>
					If you have to use arrays, two calls to System.arraycopy will most likely be the fastest.

					<delay>2</delay>
					Foo[] result = new Foo[source.length - 1];<break/>System.arraycopy(source, 0, result, 0, index);<break/>if (source.length != index) {<break/>    System.arraycopy(source, index + 1, result, index, source.length - index - 1);<break/>}<break/>
(Arrays.asList is also a good candidate for working with arrays, but it doesn't seem to support remove.)

					<delay>2</delay>
				</li>
				<li>
					
					Use an ArrayList:
alist.remove(1); //removes the element at position 1<break/>

					<delay>2</delay>
				</li>
				<li>
					
					I hope you use the java collection / java commons collections!

					<delay>2</delay>
					With an java.util.ArrayList you can do things like the following: 
yourArrayList.remove(someObject);<break/>yourArrayList.add(someObject);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Copy your original array into another array, without the element to be removed.

					<delay>2</delay>
					A simplier way to do that is to use a List, Set... and use the remove() method.

					<delay>2</delay>
				</li>
				<li>
					
					Swap the item to be removed with the last item, if resizing the array down is not an interest.

					<delay>2</delay>
				</li>
				<li>
					
					okay, thx a lot
now i use sth like this:
public static String[] removeElements(String[] input, String deleteMe) {<break/>    if (input != null) {<break/>        List&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(input));<break/>        for (int i = 0; i &lt; list.size(); i++) {<break/>            if (list.get(i).equals(deleteMe)) {<break/>                list.remove(i);<break/>            }<break/>        }<break/>        return list.toArray(new String[0]);<break/>    } else {<break/>        return new String[0];<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You could use commons lang's ArrayUtils.

					<delay>2</delay>
					array = ArrayUtils.removeElement(array, element)<break/>
commons.apache.org library:Javadocs

					<delay>2</delay>
				</li>
				<li>
					
					The best choice would be to use a collection, but if that is out for some reason, use arraycopy.
					<delay>2</delay>
					You can use it to copy from and to the same array at a slightly different offset.

					<delay>2</delay>
					For example:
public void removeElement(Object[] arr, int removedIdx) {<break/>    System.arraycopy(arr, removedIdx + 1, arr, removedIdx, arr.length - 1 - removedIdx);<break/>}<break/>
Edit in response to comment:
It's not another good way, it's really the only acceptable way--any tools that allow this functionality (like Java.
					<delay>2</delay>
					ArrayList or the apache utils) will use this method under the covers.  
					<delay>2</delay>
					Also, you REALLY should be using ArrayList (or linked list if you delete from the middle a lot)
					<delay>2</delay>
					so this shouldn't even be an issue unless you are doing it as homework.

					<delay>2</delay>
					To allocate a collection (creates a new array), then delete an element (which the collection will do using arraycopy) then call toArray on it (creates a SECOND new array) for every delete brings us to the point where it's not an optimizing issue, it's criminally bad programming.

					<delay>2</delay>
					Suppose you had an array taking up, say, 100mb of ram.
					<delay>2</delay>
					Now  you want to iterate over it and delete 20 elements.

					<delay>2</delay>
					Give it a try...  

					<delay>2</delay>
					I know you ASSUME that it's not going to be that big, or that if you were deleting that many at once you'd code it differently, but I've fixed an awful lot of code where someone made assumptions like that.

					<delay>2</delay>
				</li>
				<li>
					
					Your question isn't very clear.
					<delay>2</delay>
					From your own answer, I can tell better what you are trying to do:
public static String[] removeElements(String[] input, String deleteMe) {<break/>    List result = new LinkedList();<break/>    for(String item : input)<break/>        if(!deleteMe.equals(item))<break/>            result.add(item);<break/>    return result.toArray(input);<break/>}<break/>
NB: This is untested.
					<delay>2</delay>
					Error checking is left as an exercise to the reader (I'd throw IllegalArgumentException if either input or deleteMe is null; an empty list on null list input doesn't make sense.
					<delay>2</delay>
					Removing null Strings from the array might make sense, but I'll leave that as an exercise too; currently, it will throw an NPE when it tries to call equals on deleteMe if deleteMe is null.)

					<delay>2</delay>
					Choices I made here:

					<delay>2</delay>
					I used a LinkedList.
					<delay>2</delay>
					Iteration should be just as fast, and you avoid any resizes, or allocating too big of a list if you end up deleting lots of elements.
					<delay>2</delay>
					You could use an ArrayList, and set the initial size to the length of input.
					<delay>2</delay>
					It likely wouldn't make much of a difference.

					<delay>2</delay>
				</li>
				<li>
					
					You could use the ArrayUtils API to remove it in a "nice looking way".
					<delay>2</delay>
					It implements many operations (remove, find, add, contains,etc) on Arrays.

					<delay>2</delay>
					Take a look.
					<delay>2</delay>
					It has made my life simpler.

					<delay>2</delay>
				</li>
				<li>
					
					I think the question was asking for a solution without the use of the Collections API.
					<delay>2</delay>
					One uses arrays either for low level details, where performance matters, or for a loosely coupled SOA integration.
					<delay>2</delay>
					In the later, it is OK to convert them to Collections and pass them to the business logic as that.

					<delay>2</delay>
					For the low level performance stuff, it is usually already obfuscated by the quick-and-dirty imperative state-mingling by for loops, etc.
					<delay>2</delay>
					In that case converting back and forth between Collections and arrays is cumbersome, unreadable, and even resource intensive.

					<delay>2</delay>
					By the way, TopCoder, anyone?
					<delay>2</delay>
					Always those array parameters!
					<delay>2</delay>
					So be prepared to be able to handle them when in the Arena.

					<delay>2</delay>
					Below is my interpretation of the problem, and a solution.
					<delay>2</delay>
					It is different in functionality from both of the one given by Bill K and jelovirt.
					<delay>2</delay>
					Also, it handles gracefully the case  when the element is not in the array.

					<delay>2</delay>
					Hope that helps!

					<delay>2</delay>
					public char[] remove(char[] symbols, char c)<break/>{<break/>    for (int i = 0; i &lt; symbols.length; i++)<break/>    {<break/>        if (symbols[i] == c)<break/>        {<break/>            char[] copy = new char[symbols.length-1];<break/>            System.arraycopy(symbols, 0, copy, 0, i);<break/>            System.arraycopy(symbols, i+1, copy, i, symbols.length-i-1);<break/>            return copy;<break/>        }<break/>    }<break/>    return symbols;<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Some more pre-conditions are needed for the ones written by Bill K and dadinn
Object[] newArray = new Object[src.length - 1];<break/>if (i &gt; 0){<break/>    System.arraycopy(src, 0, newArray, 0, i);<break/>}<break/>if (newArray.length &gt; i){<break/>    System.arraycopy(src, i + 1, newArray, i, newArray.length - i);<break/>}<break/>return newArray;<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can not change the length of an array, but you can change the values the index holds by copying new values and store them to a existing index number.

					<delay>2</delay>
					1=mike , 2=
					<delay>2</delay>
					jeff //
					<delay>2</delay>
					10 = george 11 goes to 1 overwriting mike .

					<delay>2</delay>
					Object[] array = new Object[10];<break/>int count = -1;<break/>public void myFunction(String string) {<break/>    count++;<break/>    if(count == array.length) { <break/>        count = 0;  // overwrite first<break/>    }<break/>    array[count] = string;    <break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ removing ^ element ^ array ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Converting a Bidimensional Array (Numbers) Into A Dimensional Array and Viceversa on Java -->
			^ converting ^ bidimensional array ^ numbers ^ dimensional array ^ viceversa ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Do you mean something like this?

					<delay>2</delay>
					import java.util.*; <break/>public class Test {<break/>    public static void main(String[] args) {<break/>        String[][] data = new String[][] {<break/>            { "Foo", "Bar" },<break/>            { "A", "B" }<break/>        };<break/>        String[] flattened = flatten(data);<break/>        for (String x : flattened) {<break/>            System.out.println(x);<break/>        }<break/>    }<break/>    public static &lt;T&gt; T[] flatten(T[][] source) {<break/>        int size = 0;<break/>        for (int i=0; i &lt; source.length; i++) {<break/>            size += source[i].length;<break/>        }<break/>        // Use the first subarray to create the new big one<break/>        T[] ret = Arrays.copyOf(source[0], size);<break/>        int index = source[0].length;<break/>        for (int i=1; i &lt; source.length; i++) {<break/>            System.arraycopy(source[i], 0, ret, index, source[i].length);<break/>            index += source[i].length;<break/>        }<break/>        return ret;<break/>    }<break/>}<break/>

					<delay>2</delay>
					If you want it for primitive types, you'll have to write an overload for each primitive type, but you can use new int[size] instead of Arrays.copyOf at that point.

					<delay>2</delay>
				</li>
				<li>
					
					A Java 8 solution could look something like this:
import java.util.stream.Stream;<break/>public class ArrayConverter {<break/>public static String[] flatten(String[][] array) {<break/>    // Create a stream of the given array<break/>    return Stream.of(array)<break/>            // Map each of its elements to a stream (thus creating a<break/>            // one-dim-array inside the stream, so to say)<break/>            .flatMap(Stream::of)<break/>            // Retrieve the stream as array, explicitly calling String to<break/>            // keep the type<break/>            .toArray(size -&gt; new String[size]);<break/>}<break/>}<break/>

					<delay>2</delay>
					I consciously left out generic types in this example since it makes the Array Initialization somewhat confusing.
					<delay>2</delay>
					Let me know if you need it tho.

					<delay>2</delay>
					Notably; if you want to use this conversion for Arrays of primitive types you should use the corresponding flat Methods of the Stream Class.

					<delay>2</delay>
					E.g. if you're using int-Arrays use:
Stream.flatMapToInt(...)<break/>
to retrieve an IntStream with actual primitive int-Values thus dodging autoboxing into Integer Objects.

					<delay>2</delay>
					JavaDoc of Stream for reference

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ converting ^ bidimensional array ^ numbers ^ dimensional array ^ viceversa ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to get the last value of an ArrayList -->
			^ get ^ last value ^ arraylist 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					this should do it:
if (arrayList != null &amp;&amp; !arrayList.isEmpty()) {<break/>  T item = arrayList.get(arrayList.size()-1);<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					The following is part of the List interface (which ArrayList implements):

					<delay>2</delay>
					E e = list.get(list.size() - 1);<break/>
E is the element type.
					<delay>2</delay>
					If the list is empty, get throws an IndexOutOfBoundsException.
					<delay>2</delay>
					You can find the whole API documentation here.

					<delay>2</delay>
				</li>
				<li>
					
					The size() method returns the number of elements in the ArrayList.  
					<delay>2</delay>
					The index values of the elements are 0 through (size()-1), so you would use myArrayList.get(myArrayList.size()-1) to retrieve the last element.

					<delay>2</delay>
				</li>
				<li>
					
					If you modify your list, then use listIterator() and iterate from last index (that is size()-1 respectively).

					<delay>2</delay>
					If you fail again, check your list structure.

					<delay>2</delay>
				</li>
				<li>
					
					There isn't an elegant way in vanilla Java.

					<delay>2</delay>
					Google Guava

					<delay>2</delay>
					The Google Guava library is great - check out their Iterables class.
					<delay>2</delay>
					This method will throw a NoSuchElementException if the list is empty, as opposed to an IndexOutOfBoundsException, as with the typical size()-1 approach - I find a NoSuchElementException much nicer, or the ability to specify a default:
lastElement = Iterables.getLast(iterableList);<break/>

					<delay>2</delay>
					You can also provide a default value if the list is empty, instead of an exception:
lastElement = Iterables.getLast(iterableList, null);<break/>
or, if you're using Options:
lastElementRaw = Iterables.getLast(iterableList, null);<break/>lastElement = (lastElementRaw == null) ? Option.none() : Option.some(lastElementRaw);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					I use micro-util class for getting last (and first) element of list:
public final class Lists {<break/>    private Lists() {<break/>    }<break/>    public static &lt;T&gt; T getFirst(List&lt;T&gt; list) {<break/>        return list != null &amp;&amp; !list.isEmpty() ? list.get(0) : null;<break/>    }<break/>    public static &lt;T&gt; T getLast(List&lt;T&gt; list) {<break/>        return list != null &amp;&amp; !list.isEmpty() ? list.get(list.size() - 1) : null;<break/>    }<break/>}<break/>
Slightly more flexible:
import java.util.List;<break/>/**<break/> * Convenience class that provides a clearer API for obtaining list elements.<break/> */<break/>public final class Lists {<break/>  private Lists() {<break/>  }<break/>  /**<break/>   * Returns the first item in the given list, or null if not found.<break/>   *<break/>   * @param &lt;T&gt; The generic list type.<break/>   * @param list The list that may have a first item.<break/>   *<break/>   * @return null if the list is null or there is no first item.<break/>   */<break/>  public static &lt;T&gt; T getFirst( final List&lt;T&gt; list ) {<break/>    return getFirst( list, null );<break/>  }<break/>  /**<break/>   * Returns the last item in the given list, or null if not found.<break/>   *<break/>   * @param &lt;T&gt; The generic list type.<break/>   * @param list The list that may have a last item.<break/>   *<break/>   * @return null if the list is null or there is no last item.<break/>   */<break/>  public static &lt;T&gt; T getLast( final List&lt;T&gt; list ) {<break/>    return getLast( list, null );<break/>  }<break/>  /**<break/>   * Returns the first item in the given list, or t if not found.<break/>   *<break/>   * @param &lt;T&gt; The generic list type.<break/>   * @param list The list that may have a first item.<break/>   * @param t The default return value.<break/>   *<break/>   * @return null if the list is null or there is no first item.<break/>   */<break/>  public static &lt;T&gt; T getFirst( final List&lt;T&gt; list, final T t ) {<break/>    return isEmpty( list ) ? t : list.get( 0 );<break/>  }<break/>  /**<break/>   * Returns the last item in the given list, or t if not found.<break/>   *<break/>   * @param &lt;T&gt; The generic list type.<break/>   * @param list The list that may have a last item.<break/>   * @param t The default return value.<break/>   *<break/>   * @return null if the list is null or there is no last item.<break/>   */<break/>  public static &lt;T&gt; T getLast( final List&lt;T&gt; list, final T t ) {<break/>    return isEmpty( list ) ? t : list.get( list.size() - 1 );<break/>  }<break/>  /**<break/>   * Returns true if the given list is null or empty.<break/>   *<break/>   * @param &lt;T&gt; The generic list type.<break/>   * @param list The list that has a last item.<break/>   *<break/>   * @return true The list is empty.<break/>   */<break/>  public static &lt;T&gt; boolean isEmpty( final List&lt;T&gt; list ) {<break/>    return list == null || list.isEmpty();<break/>  }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you can, swap out the ArrayList for an ArrayDeque, which has convenient methods like removeLast.

					<delay>2</delay>
				</li>
				<li>
					
					How about this..

					<delay>2</delay>
					Somewhere in your class...
List&lt;E&gt; list = new ArrayList&lt;E&gt;();<break/>private int i = -1;<break/>    public void addObjToList(E elt){<break/>        i++;<break/>        list.add(elt);<break/>    }<break/>    public E getObjFromList(){<break/>        if(i == -1){ <break/>            //If list is empty handle the way you would like to... I am returning a null object<break/>            return null; // or throw an exception<break/>        }<break/>        E object = list.get(i);<break/>        list.remove(i); //Optional - makes list work like a stack<break/>        i--;            //Optional - makes list work like a stack<break/>        return object;<break/>    }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					The last item in the list is list.size() - 1.
					<delay>2</delay>
					The collection is backed by an array and arrays start at index 0.

					<delay>2</delay>
					So element 1 in the list is at index 0 in the array 
Element 2 in the list is at index 1 in the array
Element 3 in the list is at index 2 in the array 
and so on..

					<delay>2</delay>
				</li>
				<li>
					
					All you need to do is use size() to get the last value of the Arraylist. 

					<delay>2</delay>
					For ex.
					<delay>2</delay>
					if you ArrayList of integers, then to get last value you will have to
int lastValue = arrList.get(arrList.size()-1);<break/>
Remember, elements in an Arraylist can be accessed using index values.
					<delay>2</delay>
					Therefore, ArrayLists are generally used to search items.

					<delay>2</delay>
				</li>
				<li>
					
					arrays store their size in a local variable called 'length'.  
					<delay>2</delay>
					Given an array named "a" you could use the following to reference the last index without knowing the index value
a[a.length-1]
to assign a value of 5 to this last index you would use:
a[a.length-1]=5;

					<delay>2</delay>
				</li>
				<li>
					
					Using lambdas:
Function&lt;ArrayList&lt;T&gt;, T&gt; getLast = a -&gt; a.get(a.size() - 1);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you use a LinkedList instead , you can access the first element and the last one with just getFirst() and getLast() (if you want a cleaner way than size() -1
					<delay>2</delay>
					and get(0))

					<delay>2</delay>
					Implementation
Declare a LinkedList
LinkedList&lt;Object&gt; mLinkedList = new LinkedList&lt;&gt;();<break/>

					<delay>2</delay>
					Then this are the methods you can use to get what you want, in this case we are talking about FIRST and LAST element of a list

					<delay>2</delay>
					/**<break/>     * Returns the first element in this list.<break/>     *<break/>     * @return the first element in this list<break/>     * @throws NoSuchElementException if this list is empty<break/>     */<break/>    public E getFirst() {<break/>        final Node&lt;E&gt; f = first;<break/>        if (f == null)<break/>            throw new NoSuchElementException();<break/>        return f.item;<break/>    }<break/>    /**<break/>     * Returns the last element in this list.<break/>     *<break/>     * @return the last element in this list<break/>     * @throws NoSuchElementException if this list is empty<break/>     */<break/>    public E getLast() {<break/>        final Node&lt;E&gt; l = last;<break/>        if (l == null)<break/>            throw new NoSuchElementException();<break/>        return l.item;<break/>    }<break/>    /**<break/>     * Removes and returns the first element from this list.<break/>     *<break/>     * @return the first element from this list<break/>     * @throws NoSuchElementException if this list is empty<break/>     */<break/>    public E removeFirst() {<break/>        final Node&lt;E&gt; f = first;<break/>        if (f == null)<break/>            throw new NoSuchElementException();<break/>        return unlinkFirst(f);<break/>    }<break/>    /**<break/>     * Removes and returns the last element from this list.<break/>     *<break/>     * @return the last element from this list<break/>     * @throws NoSuchElementException if this list is empty<break/>     */<break/>    public E removeLast() {<break/>        final Node&lt;E&gt; l = last;<break/>        if (l == null)<break/>            throw new NoSuchElementException();<break/>        return unlinkLast(l);<break/>    }<break/>    /**<break/>     * Inserts the specified element at the beginning of this list.<break/>     *<break/>     * @param e the element to add<break/>     */<break/>    public void addFirst(E e) {<break/>        linkFirst(e);<break/>    }<break/>    /**<break/>     * Appends the specified element to the end of this list.<break/>     *<break/>     * &lt;p&gt;This method is equivalent to {@link #add}.<break/>     *<break/>     * @param e the element to add<break/>     */<break/>    public void addLast(E e) {<break/>        linkLast(e);<break/>    }<break/>
So , then you can use 
mLinkedList.getLast(); <break/>
to get the last element of the list.

					<delay>2</delay>
				</li>
				<li>
					
					Alternative using the Stream API:

					<delay>2</delay>
					list.stream().reduce((first, second) -&gt; second)<break/>
Results in an Optional of the last element.

					<delay>2</delay>
				</li>
				<li>
					
					As stated in the solution, if the List is empty then an IndexOutOfBoundsException is thrown.  
					<delay>2</delay>
					A better solution is to use the Optional type:
public class ListUtils {<break/>    public static &lt;T&gt; Optional&lt;T&gt; last(List&lt;T&gt; list) {<break/>        return list.isEmpty() ? Optional.empty() : Optional.of(list.get(list.size() - 1));<break/>    }<break/>}<break/>
As you'd expect, the last element of the list is returned as an Optional:
var list = List.of(10, 20, 30);<break/>assert ListUtils.last(list).orElse(-1) == 30;<break/>

					<delay>2</delay>
					It also deals gracefully with empty lists as well:
var emptyList = List.&lt;Integer&gt;of();<break/>assert ListUtils.last(emptyList).orElse(-1) == -1;<break/>

					<delay>2</delay>
				</li>
				<li>
					
					There is no elegant way of getting the last element of a list in Java (compared to e.g. items[-1] in Python).

					<delay>2</delay>
					You have to use list.get(list.size()-1).

					<delay>2</delay>
					When working with lists obtained by complicated method calls, the workaround lies in temporary variable:

					<delay>2</delay>
					List&lt;E&gt; list = someObject.someMethod(someArgument, anotherObject.anotherMethod());<break/>return list.get(list.size()-1);<break/>
This is the only option to avoid ugly and often expensive or even not working version:

					<delay>2</delay>
					return someObject.someMethod(someArgument, anotherObject.anotherMethod()).get(<break/>    someObject.someMethod(someArgument, anotherObject.anotherMethod()).size() - 1<break/>);<break/>
It would be nice if fix for this design flaw was introduced to Java API.

					<delay>2</delay>
				</li>
				<li>
					
					In Kotlin, you can use the method last: 
val lastItem = list.last()<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Since the indexing in ArrayList starts from 0 and ends one place before the actual size hence the correct statement to return the last arraylist element would be:
int last =
					<delay>2</delay>
					mylist.get(mylist.size()-1);
For example:
if size of array list is 5, then size-1 = 4 would return the last array element.

					<delay>2</delay>
				</li>
				<li>
					
					guava provides another way to obtain the last element from a List:
last = Lists.reverse(list).get(0)
if the provided list is empty it throws an IndexOutOfBoundsException

					<delay>2</delay>
				</li>
				<li>
					
					In case you have a spring project, you can also use the CollectionUtils.lastElement from Spring (javadoc) and you don't need to add an extra dependency like Google Guave if you didn't need to before.

					<delay>2</delay>
					It is null-safe so if you pass null, you will simply receive null in return.
					<delay>2</delay>
					Be careful when handling the response though.

					<delay>2</delay>
					Here are somes unit test to demonstrate them:

					<delay>2</delay>
					@Test<break/>void lastElementOfList() {<break/>    var names = List.of(&quot;John&quot;, &quot;Jane&quot;);<break/>    var lastName = CollectionUtils.lastElement(names);<break/>    then(lastName)<break/>        .as(&quot;Expected Jane to be the last name in the list&quot;)<break/>        .isEqualTo(&quot;Jane&quot;);<break/>}<break/>@Test<break/>void lastElementOfSet() {<break/>    var names = new TreeSet&lt;&gt;(Set.of(&quot;Jane&quot;, &quot;John&quot;, &quot;James&quot;));<break/>    var lastName = CollectionUtils.lastElement(names);<break/>    then(lastName)<break/>        .as(&quot;Expected John to be the last name in the list&quot;)<break/>        .isEqualTo(&quot;John&quot;);<break/>}<break/>
Note: org.assertj.core.api.BDDAssertions#then(java.lang.String) is used for assertions.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ get ^ last value ^ arraylist </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java array: direct access to component in array -->
			^ java array ^ array ^ direct access ^ component 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Yes, you can access an array component directly.

					<delay>2</delay>
					For example:
String[] test = new String[] { "first", "second" };<break/>System.out.println(test[1]); // Prints second<break/>
(EDIT: For some reason I was sure this was about JavaScript not Java.
					<delay>2</delay>
					Bizarre.)

					<delay>2</delay>
				</li>
				<li>
					
					Surely you can use args[1] too.

					<delay>2</delay>
				</li>
				<li>
					
					yes.
					<delay>2</delay>
					You can do that, assuming args[1]
					<delay>2</delay>
					exists, otherwise you'll get an ArrayIndexOutOfBoundsException.

					<delay>2</delay>
				</li>
				<li>
					
					What makes you think you can not?

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java array ^ array ^ direct access ^ component </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to check whether the elements of an ArrayList are all contained in another ArrayList -->
			^ check whether ^ elements ^ arraylist ^ contained ^ another arraylist 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Use Collection.containsAll():
boolean isSubset = listA.containsAll(listB);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					There is a containsAll method in all collections.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ check whether ^ elements ^ arraylist ^ contained ^ another arraylist </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java Iterate Bits in Byte Array -->
			^ java iterate bits ^ byte array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You'd have to write your own implementation of Iterable&lt;Boolean&gt; which took an array of bytes, and then created Iterator&lt;Boolean&gt; values which remembered the current index into the byte array and the current index within the current byte.
					<delay>2</delay>
					Then a utility method like this would come in handy:

					<delay>2</delay>
					private static Boolean isBitSet(byte b, int bit)<break/>{<break/>    return (b &amp; (1 &lt;&lt; bit)) != 0;<break/>}<break/>
(where bit ranges from 0 to 7).
					<delay>2</delay>
					Each time next() was called you'd have to increment your bit index within the current byte, and increment the byte index within byte array if you reached "the 9th bit".

					<delay>2</delay>
					It's not really hard - but a bit of a pain.
					<delay>2</delay>
					Let me know if you'd like a sample implementation...

					<delay>2</delay>
				</li>
				<li>
					
					You can iterate through the byte array, and for each byte use the bitwise operators to iterate though its bits.

					<delay>2</delay>
				</li>
				<li>
					
					Original:
for (int i = 0; i &lt; byteArray.Length; i++)<break/>{<break/>   byte b = byteArray[i];<break/>   byte mask = 0x01;<break/>   for (int j = 0; j &lt; 8; j++)<break/>   {<break/>      bool value = b &amp; mask;<break/>      mask &lt;&lt; 1;<break/>   }<break/>}<break/>
Or using Java idioms
for (byte b : byteArray ) {<break/>  for ( int mask = 0x01; mask != 0x100; mask &lt;&lt;= 1 ) {<break/>      boolean value = ( b &amp; mask ) != 0;<break/>  }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					I needed some bit streaming in my application.
					<delay>2</delay>
					Here you can find my BitArray implementation.
					<delay>2</delay>
					It is not a real iterator pattern but you can ask for 1-32 bits from the array in a streaming way.
					<delay>2</delay>
					There is also an alternate implementation called BitReader later in the file.

					<delay>2</delay>
				</li>
				<li>
					
					An alternative would be to use a BitInputStream like the one you can find here and write code like this:
BitInputStream bin = new BitInputStream(new ByteArrayInputStream(bytes));<break/>    while(true){<break/>        int bit = bin.readBit();<break/>        // do something<break/>    }<break/>bin.close();<break/>

					<delay>2</delay>
					(Note: Code doesn't contain EOFException or IOException handling for brevity.)

					<delay>2</delay>
					But I'd go with Jon Skeets variant and do it on my own.

					<delay>2</delay>
				</li>
				<li>
					
					I know, probably not the "coolest" way to do it, but you can extract each bit with the following code.

					<delay>2</delay>
					    int n = 156;<break/>String bin = Integer.toBinaryString(n);<break/>System.out.println(bin);<break/>char arr[] = bin.toCharArray();<break/>for(int i = 0; i &lt; arr.length; ++i) {<break/>    System.out.println("Bit number " + (i + 1) + " = " + arr[i]);<break/>}<break/>
10011100
Bit number 1 = 1
Bit number 2 = 0
Bit number 3 = 0
Bit number 4 = 1
Bit number 5 = 1
Bit number 6 = 1
Bit number 7 = 0
Bit number 8 = 0

					<delay>2</delay>
				</li>
				<li>
					
					public class ByteArrayBitIterable implements Iterable&lt;Boolean&gt; {<break/>    private final byte[] array;<break/>    public ByteArrayBitIterable(byte[] array) {<break/>        this.array = array;<break/>    }<break/>    public Iterator&lt;Boolean&gt; iterator() {<break/>        return new Iterator&lt;Boolean&gt;() {<break/>            private int bitIndex = 0;<break/>            private int arrayIndex = 0;<break/>            public boolean hasNext() {<break/>                return (arrayIndex &lt; array.length) &amp;&amp; (bitIndex &lt; 8);<break/>            }<break/>            public Boolean next() {<break/>                Boolean val = (array[arrayIndex] &gt;&gt; (7 - bitIndex) &amp; 1) == 1;<break/>                bitIndex++;<break/>                if (bitIndex == 8) {<break/>                    bitIndex = 0;<break/>                    arrayIndex++;<break/>                }<break/>                return val;<break/>            }<break/>            public void remove() {<break/>                throw new UnsupportedOperationException();<break/>            }<break/>        };<break/>    }<break/>    public static void main(String[] a) {<break/>        ByteArrayBitIterable test = new ByteArrayBitIterable(<break/>                   new byte[]{(byte)0xAA, (byte)0xAA});<break/>        for (boolean b : test)<break/>            System.out.println(b);<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java iterate bits ^ byte array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Is it more efficient to remove elements from an ArrayList or a LinkedList? -->
			^ efficient ^ remove elements ^ arraylist ^ linkedlist 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					It is "easier" (that is, more efficient) to remove them from a LinkedList, because removal from an ArrayList requires moving all subsequent elements to a new position in the list&mdash;all subsequent elements of the array must be assigned a new value.
					<delay>2</delay>
					With a linked list, only one pointer (or two, with a doubly-linked list) must be re-assigned.

					<delay>2</delay>
				</li>
				<li>
					
					Well, removal of an element from a (doubly-linked-)list is O(1).
					<delay>2</delay>
					But removal from an array will require that the remaining elements are shifted down one space in the array, which is O(n).

					<delay>2</delay>
					That said, getting a specific element in a list by index is O(n), while getting a specific element in an array by index is O(1).

					<delay>2</delay>
					So, the for actual removal, LinkedList will be better.
					<delay>2</delay>
					There is more info on Array's versus LinkedList here.

					<delay>2</delay>
				</li>
				<li>
					
					ArrayList internally uses a dynamic array to store the elements so manipulation with 
  ArrayList is slow because it internally uses an array.

					<delay>2</delay>
					If any element is removed from the array, all the bits are shifted in memory while LinkedList internally uses a doubly linked list to store the elements.

					<delay>2</delay>
					Manipulation with LinkedList is faster than ArrayList because it uses a doubly linked list, so no bit shifting is required in memory.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ efficient ^ remove elements ^ arraylist ^ linkedlist </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- double type array use in J2ME -->
			^ double type array use ^ j2me 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					make sure the handset that you have provisioned to is capable of cldc 1.1 which is needed for floating point numbers, you can change how the emulator behaves in its settings to represent a cldc 1.0 device if that is what you are building for

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ double type array use ^ j2me </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java: how to convert HashMap to array -->
			^ java ^ convert hashmap ^ array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					hashMap.keySet().toArray(); // returns an array of keys<break/>hashMap.values().toArray(); // returns an array of values<break/>
Edit

					<delay>2</delay>
					It should be noted that the ordering of both arrays may not be the same,
See oxbow_lakes answer for a better approach for iteration when the pair key/values are needed.

					<delay>2</delay>
				</li>
				<li>
					
					If you want the keys and values, you can always do this via the entrySet:
hashMap.entrySet().toArray(); // returns a Map.Entry&lt;K,V&gt;[]<break/>
From each entry you can (of course) get both the key and value via the getKey and getValue methods

					<delay>2</delay>
				</li>
				<li>
					
					Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();<break/>map.put("key1", "value1");<break/>map.put("key2", "value2");<break/>Object[][] twoDarray = new Object[map.size()][2];<break/>Object[] keys = map.keySet().toArray();<break/>Object[] values = map.values().toArray();<break/>for (int row = 0; row &lt; twoDarray.length; row++) {<break/>    twoDarray[row][0] = keys[row];<break/>    twoDarray[row][1] = values[row];<break/>}<break/>// Print out the new 2D array<break/>for (int i = 0; i &lt; twoDarray.length; i++) {<break/>    for (int j = 0; j &lt; twoDarray[i].length; j++) {<break/>        System.out.println(twoDarray[i][j]);<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you have HashMap&lt;String, SomeObject&gt; hashMap then:
hashMap.values().toArray();<break/>
Will return an Object[].
					<delay>2</delay>
					If instead you want an array of the type SomeObject, you could use:
hashMap.values().toArray(new SomeObject[0]);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					To guarantee the correct order for each array of Keys and Values, use this (the other answers use individual Sets which offer no guarantee as to order.

					<delay>2</delay>
					Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();<break/>String[] keys = new String[map.size()];<break/>Object[] values = new Object[map.size()];<break/>int index = 0;<break/>for (Map.Entry&lt;String, Object&gt; mapEntry : map.entrySet()) {<break/>    keys[index] = mapEntry.getKey();<break/>    values[index] = mapEntry.getValue();<break/>    index++;<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					An alternative to CrackerJacks suggestion, if you want the HashMap to maintain order you could consider using a LinkedHashMap instead.
					<delay>2</delay>
					As far as im aware
					<delay>2</delay>
					it's functionality
					<delay>2</delay>
					is identical to a HashMap
					<delay>2</delay>
					but it is FIFO
					<delay>2</delay>
					so it maintains the order in which items were added.

					<delay>2</delay>
				</li>
				<li>
					
					You may try this too.

					<delay>2</delay>
					public static String[][] getArrayFromHash(Hashtable&lt;String,String&gt; data){<break/>        String[][] str = null;<break/>        {<break/>            Object[] keys = data.keySet().toArray();<break/>            Object[] values = data.values().toArray();<break/>            str = new String[keys.length][values.length];<break/>            for(int i=0;i&lt;keys.length;i++) {<break/>                str[0][i] = (String)keys[i];<break/>                str[1][i] = (String)values[i];<break/>            }<break/>        }<break/>        return str;<break/>    }<break/>

					<delay>2</delay>
					Here I am using String as return type.
					<delay>2</delay>
					You may change it to required return type by you.

					<delay>2</delay>
				</li>
				<li>
					
					To Get in One Dimension Array. 

					<delay>2</delay>
					    String[] arr1 = new String[hashmap.size()];<break/>    String[] arr2 = new String[hashmap.size()];<break/>    Set entries = hashmap.entrySet();<break/>    Iterator entriesIterator = entries.iterator();<break/>    int i = 0;<break/>    while(entriesIterator.hasNext()){<break/>        Map.Entry mapping = (Map.Entry) entriesIterator.next();<break/>        arr1[i] = mapping.getKey().toString();<break/>        arr2[i] = mapping.getValue().toString();<break/>        i++;<break/>    }<break/>

					<delay>2</delay>
					To Get in two Dimension Array.   

					<delay>2</delay>
					   String[][] arr = new String[hashmap.size()][2];<break/>   Set entries = hashmap.entrySet();<break/>   Iterator entriesIterator = entries.iterator();<break/>   int i = 0;<break/>   while(entriesIterator.hasNext()){<break/>    Map.Entry mapping = (Map.Entry) entriesIterator.next();<break/>    arr[i][0] = mapping.getKey().toString();<break/>    arr[i][1] = mapping.getValue().toString();<break/>    i++;<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					I used almost the same as @kmccoy, but instead of a keySet()
					<delay>2</delay>
					I did this
hashMap.values().toArray(new MyObject[0]);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					@SuppressWarnings("unchecked")<break/>    public static &lt;E,T&gt; E[] hashMapKeysToArray(HashMap&lt;E,T&gt; map)<break/>    {<break/>        int s;<break/>        if(map == null || (s = map.size())&lt;1)<break/>            return null;<break/>        E[] temp;<break/>        E typeHelper;<break/>        try<break/>        {<break/>            Iterator&lt;Entry&lt;E, T&gt;&gt; iterator = map.entrySet().iterator();<break/>            Entry&lt;E, T&gt; iK = iterator.next();<break/>            typeHelper = iK.getKey();<break/>            Object o = Array.newInstance(typeHelper.getClass(), s);<break/>            temp = (E[]) o;<break/>            int index = 0;<break/>            for (Map.Entry&lt;E,T&gt; mapEntry : map.entrySet())<break/>            {<break/>                temp[index++] = mapEntry.getKey();<break/>            }<break/>        }<break/>        catch (Exception e)<break/>        {<break/>            return null;<break/>        }<break/>        return temp;<break/>    }<break/>//--------------------------------------------------------<break/>    @SuppressWarnings("unchecked")<break/>    public static &lt;E,T&gt; T[] hashMapValuesToArray(HashMap&lt;E,T&gt; map)<break/>    {<break/>        int s;<break/>        if(map == null || (s = map.size())&lt;1)<break/>            return null;<break/>        T[] temp;<break/>        T typeHelper;<break/>        try<break/>        {<break/>            Iterator&lt;Entry&lt;E, T&gt;&gt; iterator = map.entrySet().iterator();<break/>            Entry&lt;E, T&gt; iK = iterator.next();<break/>            typeHelper = iK.getValue();<break/>            Object o = Array.newInstance(typeHelper.getClass(), s);<break/>            temp = (T[]) o;<break/>            int index = 0;<break/>            for (Map.Entry&lt;E,T&gt; mapEntry : map.entrySet())<break/>            {<break/>                temp[index++] = mapEntry.getValue();<break/>            }<break/>        }<break/>        catch (Exception e)<break/>        {return null;}<break/>        return temp;<break/>    }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();<break/>String[] stringValues= new String[hashMap.values().size()];<break/>hashMap.values().toArray(stringValues);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you are using Java 8+ and need a 2 dimensional Array, perhaps for TestNG data providers, you can try:
map.entrySet()<break/>    .stream()<break/>    .map(e -&gt; new Object[]{e.getKey(), e.getValue()})<break/>    .toArray(Object[][]::new);<break/>

					<delay>2</delay>
					If your Objects are Strings and you need a String[][], try:
map.entrySet()<break/>    .stream()<break/>    .map(e -&gt; new String[]{e.getKey(), e.getValue().toString()})<break/>    .toArray(String[][]::new);<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java ^ convert hashmap ^ array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Using generics for arrays -->
			^ using generics ^ arrays 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					I don't think this is possible because an array is a basic datatype. 

					<delay>2</delay>
					But you can use a ArrayList to have something similar.
					<delay>2</delay>
					In most of the cases using a collection of some kind pays of very well.

					<delay>2</delay>
				</li>
				<li>
					
					Have a look at this site.
					<delay>2</delay>
					It should contain all generics related FAQs.

					<delay>2</delay>
					On a sidenote:

					<delay>2</delay>
					class IntArrayList extends ArrayList&lt;Integer&gt; { }<break/>IntArrayList[] iarray = new IntArrayList[5];<break/>

					<delay>2</delay>
					If you subclass a generic object with a concrete type, that new class can be used
as array type.

					<delay>2</delay>
				</li>
				<li>
					
					No.
					<delay>2</delay>
					Arrays must have a compile-time type.

					<delay>2</delay>
				</li>
				<li>
					
					Arrays are already basic objects types, that is to say they're not a class that describes a collection of other objects like ArrayList or HashMap.

					<delay>2</delay>
					You cannot have an array of generified types either.
					<delay>2</delay>
					The following is illegal in Java:

					<delay>2</delay>
					List&lt;String&gt;[] lists = new List&lt;String&gt;[ 10 ];<break/>

					<delay>2</delay>
					This is because arrays must be typed properly by the compiler, and since Java's generics are subject to type erasure you cannot satisfy the compiler this way.

					<delay>2</delay>
				</li>
				<li>
					
					It's possible, but far from pretty.
					<delay>2</delay>
					In general, you're better of using the Collections framework instead.

					<delay>2</delay>
					See Sun's Generics tutorial, page 15, for a detailed explanation.

					<delay>2</delay>
				</li>
				<li>
					
					Can you use it?
					<delay>2</delay>
					Ofc.

					<delay>2</delay>
					Example:

					<delay>2</delay>
					public static &lt;T&gt; T[] mergeArrays(T[]... arrays) {<break/>    ArrayList&lt;T&gt; arrayList = new ArrayList&lt;T&gt;();<break/>    for (T[] array : arrays) {<break/>        arrayList.addAll(Arrays.asList(array)); //we steal the reflection from core libs<break/>    }<break/>    return arrayList.toArray(arrays[0]);//we steal the reflection from core libs<break/>}<break/>
Is it a good idea?
					<delay>2</delay>
					No.
					<delay>2</delay>
					This code is just me playing around with generics.
					<delay>2</delay>
					It led to a dark ally.
					<delay>2</delay>
					You are better of using collections.
					<delay>2</delay>
					They do what you want, and the syntax is prettier in the long run.

					<delay>2</delay>
				</li>
				<li>
					
					If I ever want to, say, refactor the elements of an array to a better type, like from String to MyPairClass&lt;String, Integer&gt;, I tend to avoid the unchecked cast problem by making an empty subclass that "bakes in" the generic parameters, e.g. 
class Maguffin {<break/>    private static class StringIntegerPair extends MyPairClass&lt;String, Integer&gt; {<break/>        private static final long serialVersionUID = 1L;<break/>    };<break/>    ...<break/>    private final StringIntegerPair[] horribleOldArray;<break/>    ...<break/>

					<delay>2</delay>
					This nested class will probably also need constructors that delegate up to the generic type's constructors, depending on what you do when adding new array elements.
					<delay>2</delay>
					When passing the elements out of the enclosing class, just cast them up to the generic type:
    ...<break/>    MyPairClass&lt;String, Integer&gt; getSomethingFromTheArray(int index) {<break/>        return horribleOldArray[index];<break/>    }<break/>    ...<break/>}<break/>
All this being said, there should rarely be a need to do something like this if you are writing something new from scratch.
					<delay>2</delay>
					The only real benefit of arrays over the Collections framework classes is that you can write them out as literals, and this will no longer be an advantage come next year when Java 8 is released.

					<delay>2</delay>
				</li>
				<li>
					
					Excerpt from Java Generics and collections.
  
					<delay>2</delay>
					Arrays reify their component types, meaning that they carry run-time information about the type of their components.
					<delay>2</delay>
					This reified type information is used in instance tests and casts, and also used to check whether assignments into array components are permitted.

					<delay>2</delay>
					Therefore one is not allowed to have the suntax
new List&lt;Integer&gt;[10] ;  <break/>

					<delay>2</delay>
					However the following is allowed
List&lt;String&gt;[] stringListArray=(List&lt;String&gt;[])new List[10];<break/>

					<delay>2</delay>
					Now this is not a really good practice.
					<delay>2</delay>
					Such casts are not safe and should be avoided.

					<delay>2</delay>
					Which in general points to the fact that we should avoid using arrays of generic type.

					<delay>2</delay>
				</li>
				<li>
					
					If you mean having an array of List then the answer is no.
					<delay>2</delay>
					new List&lt;Number&gt;[10] is illegal in java.
					<delay>2</delay>
					questions like these could be answerable by searching it in Google alone or checking out the official Generics tutorial

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ using generics ^ arrays </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How do I declare and initialize an array in Java? -->
			^ declare ^ initialize ^ array ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You can either use array declaration or array literal (but only when you declare and affect the variable right away, array literals cannot be used for re-assigning an array). 

					<delay>2</delay>
					For primitive types: 
int[] myIntArray = new int[3];<break/>int[] myIntArray = {1, 2, 3};<break/>int[] myIntArray = new int[]{1, 2, 3};<break/>// Since Java 8. Doc of IntStream: https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html<break/>int [] myIntArray = IntStream.range(0, 100).toArray(); // From 0 to 99<break/>int [] myIntArray = IntStream.rangeClosed(0, 100).toArray(); // From 0 to 100<break/>int [] myIntArray = IntStream.of(12,25,36,85,28,96,47).toArray(); // The order is preserved.<break/>int [] myIntArray = IntStream.of(12,25,36,85,28,96,47).sorted().toArray(); // Sort <break/>
For classes, for example String, it's the same:

					<delay>2</delay>
					String[] myStringArray = new String[3];<break/>String[] myStringArray = {"a", "b", "c"};<break/>String[] myStringArray = new String[]{"a", "b", "c"};<break/>

					<delay>2</delay>
					The third way of initializing is useful when you declare the array first and then initialize it.
					<delay>2</delay>
					The cast is necessary here.

					<delay>2</delay>
					String[] myStringArray;<break/>myStringArray = new String[]{"a", "b", "c"};<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Alternatively,
// Either method works<break/>String arrayName[] = new String[10];<break/>String[] arrayName = new String[10];<break/>

					<delay>2</delay>
					That declares an array called arrayName of size 10 (you have elements 0 through 9 to use).

					<delay>2</delay>
				</li>
				<li>
					
					There are various ways in which you can declare an array in Java:
float floatArray[]; // Initialize later<break/>int[] integerArray = new int[10];<break/>String[] array = new String[] {"a", "b"};<break/>

					<delay>2</delay>
					You can find more information in the Sun tutorial site and the JavaDoc.

					<delay>2</delay>
				</li>
				<li>
					
					Type[] variableName = new Type[capacity];<break/>Type[] variableName = {comma-delimited values};<break/>Type variableName[] = new Type[capacity]; <break/>Type variableName[] = {comma-delimited values};<break/>
is also valid, but I prefer the brackets after the type, because it's easier to see that the variable's type is actually an array.

					<delay>2</delay>
				</li>
				<li>
					
					I find it is helpful if you understand each part:
Type[] name = new Type[5];<break/>
Type[] is the type of the variable called name ("name" is called the identifier).  
					<delay>2</delay>
					The literal "Type" is the base type, and the brackets mean this is the array type of that base.
					<delay>2</delay>
					Array types are in turn types of their own, which allows you to make multidimensional arrays like Type[][] (the array type of Type[]).
					<delay>2</delay>
					The keyword new says to allocate memory for the new array.  
					<delay>2</delay>
					The number between the bracket says how large the new array will be and how much memory to allocate.
					<delay>2</delay>
					For instance, if Java knows that the base type Type takes 32 bytes, and you want an array of size 5, it needs to internally allocate 32 * 5 = 160 bytes.

					<delay>2</delay>
					You can also create arrays with the values already there, such as
int[] name = {1, 2, 3, 4, 5};<break/>
which not only creates the empty space but fills it with those values.
					<delay>2</delay>
					Java can tell that the primitives are integers and that there are 5 of them, so the size of the array can be determined implicitly.

					<delay>2</delay>
				</li>
				<li>
					
					Also, in case you want something more dynamic there is the List interface.  
					<delay>2</delay>
					This will not perform as well, but is more flexible:
List&lt;String&gt; listOfString = new ArrayList&lt;String&gt;();<break/>listOfString.add("foo");<break/>listOfString.add("bar");<break/>String value = listOfString.get(0);<break/>assertEquals( value, "foo" );<break/>

					<delay>2</delay>
				</li>
				<li>
					
					The following shows the declaration of an array, but the array is not initialized:
 int[] myIntArray = new int[3];<break/>

					<delay>2</delay>
					The following shows the declaration as well as initialization of the array:

					<delay>2</delay>
					int[] myIntArray = {1,2,3};<break/>

					<delay>2</delay>
					Now, the following also shows the declaration as well as initialization of the array:
int[] myIntArray = new int[]{1,2,3};<break/>

					<delay>2</delay>
					But this third one shows the property of anonymous array-object creation which is pointed by a reference variable "myIntArray",
					<delay>2</delay>
					so if we write just "new int[]{1,2,3};" then this is how anonymous array-object can be created.

					<delay>2</delay>
					If we just write:
int[] myIntArray;<break/>
this is not declaration of array, but the following statement makes the above declaration complete:
myIntArray=new int[3];<break/>

					<delay>2</delay>
				</li>
				<li>
					
					There are two types of array. 

					<delay>2</delay>
					One Dimensional Array
Syntax for default values:
int[] num = new int[5];<break/>

					<delay>2</delay>
					Or (less preferred)
int num[] = new int[5];<break/>
Syntax with values given (variable/field initialization):
int[] num = {1,2,3,4,5};<break/>
Or (less preferred
					<delay>2</delay>
					)
int num[] = {1, 2, 3, 4, 5};<break/>
Note: For convenience  int[] num is preferable because it clearly tells that you are talking here about array.
					<delay>2</delay>
					Otherwise no difference.
					<delay>2</delay>
					Not at all.

					<delay>2</delay>
					Multidimensional array
Declaration

					<delay>2</delay>
					int[][] num = new int[5][2];<break/>
Or
int num[][] = new int[5][2];<break/>
Or
int[] num[] = new int[5][2];<break/>
Initialization
 num[0][0]=1;<break/> num[0][1]=2;<break/> num[1][0]=1;<break/> num[1][1]=2;<break/> num[2][0]=1;<break/> num[2][1]=2;<break/> num[3][0]=1;<break/> num[3][1]=2;<break/> num[4][0]=1;<break/> num[4][1]=2;<break/>
Or
 int[][] num={ {1,2}, {1,2}, {1,2}, {1,2}, {1,2} };<break/>
Ragged Array (or Non-rectangular Array)
int[] num = new int[5];<break/>0

					<delay>2</delay>
					So here we are defining columns explicitly.

					<delay>2</delay>
					Another Way:  

					<delay>2</delay>
					int[] num = new int[5];<break/>1

					<delay>2</delay>
					For Accessing:
int[] num = new int[5];<break/>2
Alternatively:
int[] num = new int[5];<break/>3
Ragged arrays are multidimensional arrays.

					<delay>2</delay>
					For explanation see multidimensional array detail at the official java tutorials

					<delay>2</delay>
				</li>
				<li>
					
					If you want to create arrays using reflections then you can do like this:
 int size = 3;<break/> int[] intArray = (int[]) Array.newInstance(int.class, size ); <break/>

					<delay>2</delay>
				</li>
				<li>
					
					Take the primitive type int for example.
					<delay>2</delay>
					There are several ways to declare and int array:
int[] i = new int[capacity];<break/>int[] i = new int[] {value1, value2, value3, etc};<break/>int[] i = {value1, value2, value3, etc};<break/>
where in all of these, you can use int i[] instead of int[] i.

					<delay>2</delay>
					With reflection, you can use (Type[]) Array.newInstance(Type.class, capacity);
Note that in method parameters, ... indicates variable arguments.
					<delay>2</delay>
					Essentially, any number of parameters is fine.
					<delay>2</delay>
					It's easier to explain with code:

					<delay>2</delay>
					public static void varargs(int fixed1, String fixed2, int... varargs) {...}<break/>...<break/>varargs(0, "", 100); // fixed1 = 0, fixed2 = "", varargs = {100}<break/>varargs(0, "", 100, 200); // fixed1 = 0, fixed2 = "", varargs = {100, 200};<break/>
Inside the method, int0 is treated as a normal int1.
					<delay>2</delay>
					code_placeholder_12 can only be used in method parameters, so int3 will not compile.

					<delay>2</delay>
					Note that when passing an int4 to a method (or any other int5), you cannot use the third way.
					<delay>2</delay>
					In the statement int6, the compiler assumes that the int7 means an int8.
					<delay>2</delay>
					But that is because you are declaring a variable.
					<delay>2</delay>
					When passing an array to a method, the declaration must either be int9 or int0.

					<delay>2</delay>
					Multidimensional Arrays

					<delay>2</delay>
					Multidimensional arrays are much harder to deal with.
					<delay>2</delay>
					Essentially, a 2D array is an array of arrays.
					<delay>2</delay>
					int1 means an array of int2s.
					<delay>2</delay>
					The key is that if an int3 is declared as int4, the maximum index is int5.
					<delay>2</delay>
					Essentially, a rectangular int6 is:
int7

					<delay>2</delay>
				</li>
				<li>
					
					Declaring an array of object references:
class Animal {}<break/>class Horse extends Animal {<break/>    public static void main(String[] args) {<break/>        /*<break/>         * Array of Animal can hold Animal and Horse (all subtypes of Animal allowed)<break/>         */<break/>        Animal[] a1 = new Animal[10];<break/>        a1[0] = new Animal();<break/>        a1[1] = new Horse();<break/>        /*<break/>         * Array of Animal can hold Animal and Horse and all subtype of Horse<break/>         */<break/>        Animal[] a2 = new Horse[10];<break/>        a2[0] = new Animal();<break/>        a2[1] = new Horse();<break/>        /*<break/>         * Array of Horse can hold only Horse and its subtype (if any) and not<break/>           allowed supertype of Horse nor other subtype of Animal.<break/>         */<break/>        Horse[] h1 = new Horse[10];<break/>        h1[0] = new Animal(); // Not allowed<break/>        h1[1] = new Horse();<break/>        /*<break/>         * This can not be declared.<break/>         */<break/>        Horse[] h2 = new Animal[10]; // Not allowed<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Array is a sequential list of items
int item = value;<break/>int [] one_dimensional_array = { value, value, value, .., value };<break/>int [][] two_dimensional_array =<break/>{<break/>  { value, value, value, .. value },<break/>  { value, value, value, .. value },<break/>    ..     ..     ..        ..<break/>  { value, value, value, .. value }<break/>};<break/>

					<delay>2</delay>
					If it's an object, then it's the same concept
Object item = new Object();<break/>Object [] one_dimensional_array = { new Object(), new Object(), .. new Object() };<break/>Object [][] two_dimensional_array =<break/>{<break/>  { new Object(), new Object(), .. new Object() },<break/>  { new Object(), new Object(), .. new Object() },<break/>    ..            ..               ..<break/>  { new Object(), new Object(), .. new Object() }<break/>};<break/>

					<delay>2</delay>
					In case of objects, you need to either assign it to null to initialize them using new Type(..),
					<delay>2</delay>
					classes like String and Integer are special cases that will be handled as following
String [] a = { "hello", "world" };<break/>// is equivalent to<break/>String [] a = { new String({'h','e','l','l','o'}), new String({'w','o','r','l','d'}) };<break/>Integer [] b = { 1234, 5678 };<break/>// is equivalent to<break/>Integer [] b = { new Integer(1234), new Integer(5678) };<break/>

					<delay>2</delay>
					In general you can create arrays that's M dimensional
int [][]..[] array =<break/>//  ^ M times [] brackets<break/>    {{..{<break/>//  ^ M times { bracket<break/>//            this is array[0][0]..[0]<break/>//                         ^ M times [0]<break/>    }}..}<break/>//  ^ M times } bracket<break/>;<break/>

					<delay>2</delay>
					It's worthy to note that creating an int item = value;<break/>int [] one_dimensional_array = { value, value, value, .., value };<break/>int [][] two_dimensional_array =<break/>{<break/>  { value, value, value, .. value },<break/>  { value, value, value, .. value },<break/>    ..     ..     ..        ..<break/>  { value, value, value, .. value }<break/>};<break/>0 dimensional array is expensive in terms of Space.
					<delay>2</delay>
					Since when you create an int item = value;<break/>int [] one_dimensional_array = { value, value, value, .., value };<break/>int [][] two_dimensional_array =<break/>{<break/>  { value, value, value, .. value },<break/>  { value, value, value, .. value },<break/>    ..     ..     ..        ..<break/>  { value, value, value, .. value }<break/>};<break/>1 dimensional array with int item = value;<break/>int [] one_dimensional_array = { value, value, value, .., value };<break/>int [][] two_dimensional_array =<break/>{<break/>  { value, value, value, .. value },<break/>  { value, value, value, .. value },<break/>    ..     ..     ..        ..<break/>  { value, value, value, .. value }<break/>};<break/>2 on all the dimensions, The total size of the array is bigger than int item = value;<break/>int [] one_dimensional_array = { value, value, value, .., value };<break/>int [][] two_dimensional_array =<break/>{<break/>  { value, value, value, .. value },<break/>  { value, value, value, .. value },<break/>    ..     ..     ..        ..<break/>  { value, value, value, .. value }<break/>};<break/>3, since each array has a reference, and at the M-dimension there is an (M-1)-dimensional array of references.
					<delay>2</delay>
					The total size is as following
int item = value;<break/>int [] one_dimensional_array = { value, value, value, .., value };<break/>int [][] two_dimensional_array =<break/>{<break/>  { value, value, value, .. value },<break/>  { value, value, value, .. value },<break/>    ..     ..     ..        ..<break/>  { value, value, value, .. value }<break/>};<break/>4

					<delay>2</delay>
				</li>
				<li>
					
					int[] SingleDimensionalArray = new int[2]<break/>int[][] MultiDimensionalArray = new int[3][4]<break/>

					<delay>2</delay>
				</li>
				<li>
					
					There are two main ways to make an array:
This one, for an empty array:
int[] array = new int[n]; // "n" being the number of spaces to allocate in the array<break/>
And this one, for an initialized array:
int[] array = {1,2,3,4 ...};<break/>

					<delay>2</delay>
					You can also make multidimensional arrays, like this:
int[][] array2d = new int[x][y]; // "x" and "y" specify the dimensions<break/>int[][] array2d = { {1,2,3 ...}, {4,5,6 ...} ...};<break/>

					<delay>2</delay>
				</li>
				<li>
					
					For creating arrays of class Objects you can use the java.util.ArrayList.
					<delay>2</delay>
					to define an array:
public ArrayList&lt;ClassName&gt; arrayName;<break/>arrayName = new ArrayList&lt;ClassName&gt;();<break/>
Assign values to the array:

					<delay>2</delay>
					arrayName.add(new ClassName(class parameters go here);<break/>
Read from the array:

					<delay>2</delay>
					ClassName variableName = arrayName.get(index);<break/>
Note:

					<delay>2</delay>
					variableName is a reference to the array meaning that manipulating variableName will manipulate arrayName
for loops:
//repeats for every value in the array<break/>for (ClassName variableName : arrayName){<break/>}<break/>//Note that using this for loop prevents you from editing arrayName<break/>
for loop that allows you to edit arrayName (conventional for loop):
java.util.ArrayList0

					<delay>2</delay>
				</li>
				<li>
					
					Another way to declare and initialize ArrayList:
private List&lt;String&gt; list = new ArrayList&lt;String&gt;(){{<break/>    add("e1");<break/>    add("e2");<break/>}};<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Declare and initialize for Java 8 and later.
					<delay>2</delay>
					Create a simple integer array:

					<delay>2</delay>
					int [] a1 = IntStream.range(1, 20).toArray();<break/>System.out.println(Arrays.toString(a1));<break/>// Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]<break/>
Create a random array for integers between [-50, 50] and for doubles [0, 1E17]:
int [] a2 = new Random().ints(15, -50, 50).toArray();<break/>double [] a3 = new Random().doubles(5, 0, 1e17).toArray();<break/>
Power-of-two sequence:
double [] a4 = LongStream.range(0, 7).mapToDouble(i -&gt; Math.pow(2, i)).toArray();<break/>System.out.println(Arrays.toString(a4));<break/>// Output: [1.0, 2.0, 4.0, 8.0, 16.0, 32.0, 64.0]<break/>
For String[
					<delay>2</delay>
					] you must specify a constructor:
String [] a5 = Stream.generate(()-&gt;"I will not squeak chalk").limit(5).toArray(String[]::new);<break/>System.out.println(Arrays.toString(a5));<break/>
Multidimensional arrays:
String [][] a6 = List.of(new String[]{"a", "b", "c"} , new String[]{"d", "e", "f", "g"})<break/>    .toArray(new String[0][]);<break/>System.out.println(Arrays.deepToString(a6));<break/>// Output: [[a, b, c], [d, e, f, g]]<break/>

					<delay>2</delay>
				</li>
				<li>
					
					In Java 9
Using different IntStream.iterate and IntStream.takeWhile methods:
int[] a = IntStream.iterate(10, x -&gt; x &lt;= 100, x -&gt; x + 10).toArray();<break/>Out: [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]<break/>int[] b = IntStream.iterate(0, x -&gt; x + 1).takeWhile(x -&gt; x &lt; 10).toArray();<break/>Out: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<break/>
In Java 10
Using the Local Variable Type Inference:
var letters = new String[]{"A", "B", "C"};<break/>

					<delay>2</delay>
				</li>
				<li>
					
					In Java 8 you can use like this. 

					<delay>2</delay>
					String[] strs = IntStream.range(0, 15)  // 15 is the size<break/>    .mapToObj(i -&gt; Integer.toString(i))<break/>    .toArray(String[]::new);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					With local variable type inference you only have to specify the type once:
var values = new int[] { 1, 2, 3 };<break/>
Or
int[] values = { 1, 2, 3 }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If by &quot;array&quot; you meant using java.util.Arrays, you can do it like that :

					<delay>2</delay>
					List&lt;String&gt; number = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);<break/>Out: [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]<break/>

					<delay>2</delay>
					This one is pretty simple and straightforward.

					<delay>2</delay>
				</li>
				<li>
					
					There are a lot of answers here.
					<delay>2</delay>
					I am adding a few tricky ways to create arrays (from an exam point of view it's good to know this)
Declare and define an array
int intArray[] = new int[3];<break/>

					<delay>2</delay>
					This will create an array of length 3.
					<delay>2</delay>
					As it holds a primitive type, int, all values are set to 0 by default.
					<delay>2</delay>
					For example,
intArray[2]; // Will return 0<break/>
Using box brackets [] before the variable name
int[] intArray = new int[3];<break/>intArray[0] = 1;  // Array content is now {1, 0, 0}<break/>
Initialise and provide data to the array
int[] intArray = new int[]{1, 2, 3};<break/>
This time there isn't any need to mention the size in the box bracket.
					<delay>2</delay>
					Even a simple variant of this is:
$
					<delay>2</delay>
					code_placeholder_5

					<delay>2</delay>
					An array of length 0
int[] intArray = new int[0];<break/>int length = intArray.length; // Will return length 0<break/>
Similar for multi-dimensional arrays
int intArray[][] = new int[2][3];<break/>// This will create an array of length 2 and<break/>//each element contains another array of length 3.<break/>// { {0,0,0},{0,0,0} }<break/>int lenght1 = intArray.length; // Will return 2<break/>int length2 = intArray[0].length; // Will return 3<break/>

					<delay>2</delay>
					Using box brackets before the variable:
    int[][] intArray = new int[2][3];<break/>

					<delay>2</delay>
					It's absolutely fine if you put one box bracket at the end:

					<delay>2</delay>
					    int[] intArray [] = new int[2][4];<break/>    int[] intArray[][] = new int[2][3][4]<break/>

					<delay>2</delay>
					Some examples
int intArray[] = new int[3];<break/>0

					<delay>2</delay>
					It's not mandatory that each inner element is of the same size.

					<delay>2</delay>
					int intArray[] = new int[3];<break/>1

					<delay>2</delay>
					You have to make sure if you are using the above syntax, that the forward direction you have to specify the values in box brackets.
					<delay>2</delay>
					Else it won't compile.
					<delay>2</delay>
					Some examples:
int intArray[] = new int[3];<break/>2

					<delay>2</delay>
					Another important feature is covariant
int intArray[] = new int[3];<break/>3
IMPORTANT:
					<delay>2</delay>
					For referenced types, the default value stored in the array is null.

					<delay>2</delay>
				</li>
				<li>
					
					Declare Array: int[] arr;
Initialize Array: int[] arr = new int[10]; 10
					<delay>2</delay>
					represents the number of elements allowed in the array
Declare Multidimensional Array: int[][] arr;
Initialize Multidimensional Array: int[][] arr = new int[10][17]; 10 rows and 17 columns and 170 elements because 10 times 17 is 170.

					<delay>2</delay>
					Initializing an array means specifying the size of it. 

					<delay>2</delay>
				</li>
				<li>
					
					It's very easy to declare and initialize an array.

					<delay>2</delay>
					For example, you want to save five integer elements which are 1, 2, 3, 4, and 5 in an array.
					<delay>2</delay>
					You can do it in the following way:
a)
int[] a = new int[5];<break/>
or
b)
int[] a = {1, 2, 3, 4, 5};<break/>

					<delay>2</delay>
					so the basic pattern is for initialization and declaration by method a)
					<delay>2</delay>
					is:
datatype[] arrayname = new datatype[requiredarraysize];<break/>
datatype should be in lower case.

					<delay>2</delay>
					So the basic pattern is for initialization and declaration by method
					<delay>2</delay>
					a is:
If it's a string array:
String[] a = {"as", "asd", "ssd"};<break/>
If it's a character array:
char[] a = {'a', 's', 'w'};<break/>
For float double, the format of array will be same as integer.

					<delay>2</delay>
					For example:
double[] a = {1.2, 1.3, 12.3};<break/>

					<delay>2</delay>
					but when you declare and initialize the array by "method a" you will have to enter the values manually or by loop or something.

					<delay>2</delay>
					But when you do it by "method b" you will not have to enter the values manually.

					<delay>2</delay>
				</li>
				<li>
					
					Array can contains primitives data types as well as objects of a class depending on the definition of array.
					<delay>2</delay>
					In case of primitives data types, the actual values are stored in contiguous memory locations.
					<delay>2</delay>
					In case of objects of a class, the actual objects are stored in heap segment.

					<delay>2</delay>
					One-Dimensional Arrays : 

					<delay>2</delay>
					The general form of a one-dimensional array declaration is
type var-name[];<break/>OR<break/>type[] var-name;<break/>
Instantiating an Array in Java

					<delay>2</delay>
					var-name = new type [size];<break/>
For Example 

					<delay>2</delay>
					    int intArray[];    //declaring array<break/>    intArray = new int[20];  // allocating memory to array<break/>    // the below line is equals to line1 + line2<break/>    int[] intArray = new int[20]; // combining both statements in one<break/>     int[] intArray = new int[]{ 1,2,3,4,5,6,7,8,9,10 }; <break/>    // accessing the elements of the specified array<break/>    for (int i = 0; i &lt; intArray.length; i++)<break/>    System.out.println("Element at index " + i + " : "+ intArray[i]);<break/>
Ref: https://www.geeksforgeeks.org/arrays-in-java/

					<delay>2</delay>
				</li>
				<li>
					
					Array has two basic types.
  
					<delay>2</delay>
					Static Array:
					<delay>2</delay>
					Fixed size array (Its size should be declared at start and can not be changed later)
  
  Dynamic Array:
					<delay>2</delay>
					No size limit is considered for this.
					<delay>2</delay>
					(Pure dynamic arrays do not exist in Java.
					<delay>2</delay>
					Instead, List is most encouraged)
To declare a static array of Integer, string, float, etc... use the bellow declaration and initialization statements.

					<delay>2</delay>
					    int[] intArray = new int[10]; <break/>    String[] intArray = new int[10]; <break/>    float[] intArray = new int[10]; <break/>    <break/>   // here you have 10 index starting from 0 to 9

					<delay>2</delay>
					To use dynamic features, you have to use List... 

					<delay>2</delay>
					List is pure dynamic Array and there is no need to declare size at beginning. 

					<delay>2</delay>
					Bellow is the proper way to declare a list in JAVA>
        ArrayList&lt;String&gt; myArray = new ArrayList&lt;String&gt;();<break/>        myArray.add("Value 1: something");<break/>        myArray.add("Value 2: something more");

					<delay>2</delay>
				</li>
				<li>
					
					int[] x=new int[enter the size of array here];<break/>
example:
int[] x=new int[10];<break/>
or
int[] x={enter the elements of array here];<break/>
example:
int[] x={10,65,40,5,48,31};<break/>

					<delay>2</delay>
				</li>
				<li>
					
					one another full example with movies class 😋
public class A {<break/>        public static void main(String[] args) {<break/>                class Movie{<break/>                    String movieName;<break/>                    String genre;<break/>                    String movieType;<break/>                    String year;<break/>                    String ageRating;<break/>                    String rating;<break/>                    public Movie(String [] str)<break/>                    {<break/>                        this.movieName = str[0];<break/>                        this.genre = str[1];<break/>                        this.movieType = str[2];<break/>                        this.year = str[3];<break/>                        this.ageRating = str[4];<break/>                        this.rating = str[5];    <break/>                    }<break/>                }<break/>                String [] movieDetailArr = {"Inception", "Thriller", "MovieType", "2010", "13+", "10/10"};<break/>                Movie mv = new Movie(movieDetailArr);<break/>                System.out.println("Movie Name: "+ mv.movieName);<break/>                System.out.println("Movie genre: "+ mv.genre);<break/>                System.out.println("Movie type: "+ mv.movieType);<break/>                System.out.println("Movie year: "+ mv.year);<break/>                System.out.println("Movie age : "+ mv.ageRating);<break/>                System.out.println("Movie  rating: "+ mv.rating);<break/>            }<break/>        } <break/>

					<delay>2</delay>
				</li>
				<li>
					
					package com.examplehub.basics;<break/>import java.util.Arrays;<break/>public class Array {<break/>    public static void main(String[] args) {<break/>        int[] numbers = {1, 2, 3, 4, 5};<break/>        /*<break/>         * numbers[0] = 1<break/>         * numbers[1] = 2<break/>         * numbers[2] = 3<break/>         * numbers[3] = 4<break/>         * numbers[4] = 5<break/>         */<break/>        System.out.println(&quot;numbers[0] = &quot; + numbers[0]);<break/>        System.out.println(&quot;numbers[1] = &quot; + numbers[1]);<break/>        System.out.println(&quot;numbers[2] = &quot; + numbers[2]);<break/>        System.out.println(&quot;numbers[3] = &quot; + numbers[3]);<break/>        System.out.println(&quot;numbers[4] = &quot; + numbers[4]);<break/>        /*<break/>         * array index is out of bounds<break/>         */<break/>        //System.out.println(numbers[-1]);<break/>        //System.out.println(numbers[5]);<break/>        /*<break/>         * numbers[0] = 1<break/>         * numbers[1] = 2<break/>         * numbers[2] = 3<break/>         * numbers[3] = 4<break/>         * numbers[4] = 5<break/>         */<break/>        for (int i = 0; i &lt; 5; i++) {<break/>            System.out.println(&quot;numbers[&quot; + i + &quot;] = &quot; + numbers[i]);<break/>        }<break/>        /*<break/>         * length of numbers = 5<break/>         */<break/>        System.out.println(&quot;length of numbers = &quot; + numbers.length);<break/>        /*<break/>         * numbers[0] = 1<break/>         * numbers[1] = 2<break/>         * numbers[2] = 3<break/>         * numbers[3] = 4<break/>         * numbers[4] = 5<break/>         */<break/>        for (int i = 0; i &lt; numbers.length; i++) {<break/>            System.out.println(&quot;numbers[&quot; + i + &quot;] = &quot; + numbers[i]);<break/>        }<break/>        /*<break/>         * numbers[4] = 5<break/>         * numbers[3] = 4<break/>         * numbers[2] = 3<break/>         * numbers[1] = 2<break/>         * numbers[0] = 1<break/>         */<break/>        for (int i = numbers.length - 1; i &gt;= 0; i--) {<break/>            System.out.println(&quot;numbers[&quot; + i + &quot;] = &quot; + numbers[i]);<break/>        }<break/>        /*<break/>         * 12345<break/>         */<break/>        for (int number : numbers) {<break/>            System.out.print(number);<break/>        }<break/>        System.out.println();<break/>        /*<break/>         * [1, 2, 3, 4, 5]<break/>         */<break/>        System.out.println(Arrays.toString(numbers));<break/>        String[] company = {&quot;Google&quot;, &quot;Facebook&quot;, &quot;Amazon&quot;, &quot;Microsoft&quot;};<break/>        /*<break/>         * company[0] = Google<break/>         * company[1] = Facebook<break/>         * company[2] = Amazon<break/>         * company[3] = Microsoft<break/>         */<break/>        for (int i = 0; i &lt; company.length; i++) {<break/>            System.out.println(&quot;company[&quot; + i + &quot;] = &quot; + company[i]);<break/>        }<break/>        /*<break/>         * Google<break/>         * Facebook<break/>         * Amazon<break/>         * Microsoft<break/>         */<break/>        for (String c : company) {<break/>            System.out.println(c);<break/>        }<break/>        /*<break/>         * [Google, Facebook, Amazon, Microsoft]<break/>         */<break/>        System.out.println(Arrays.toString(company));<break/>        int[][] twoDimensionalNumbers = {<break/>                {1, 2, 3},<break/>                {4, 5, 6, 7},<break/>                {8, 9},<break/>                {10, 11, 12, 13, 14, 15}<break/>        };<break/>        /*<break/>         * total rows  = 4<break/>         */<break/>        System.out.println(&quot;total rows  = &quot; + twoDimensionalNumbers.length);<break/>        /*<break/>         * row 0 length = 3<break/>         * row 1 length = 4<break/>         * row 2 length = 2<break/>         * row 3 length = 6<break/>         */<break/>        for (int i = 0; i &lt; twoDimensionalNumbers.length; i++) {<break/>            System.out.println(&quot;row &quot; + i + &quot; length = &quot; + twoDimensionalNumbers[i].length);<break/>        }<break/>        /*<break/>         * row 0 = 1 2 3<break/>         * row 1 = 4 5 6 7<break/>         * row 2 = 8 9<break/>         * row 3 = 10 11 12 13 14 15<break/>         */<break/>        for (int i = 0; i &lt; twoDimensionalNumbers.length; i++) {<break/>            System.out.print(&quot;row &quot; + i + &quot; = &quot;);<break/>            for (int j = 0; j &lt; twoDimensionalNumbers[i].length; j++) {<break/>                System.out.print(twoDimensionalNumbers[i][j] + &quot; &quot;);<break/>            }<break/>            System.out.println();<break/>        }<break/>        /*<break/>         * row 0 = [1, 2, 3]<break/>         * row 1 = [4, 5, 6, 7]<break/>         * row 2 = [8, 9]<break/>         * row 3 = [10, 11, 12, 13, 14, 15]<break/>         */<break/>        for (int i = 0; i &lt; twoDimensionalNumbers.length; i++) {<break/>            System.out.println(&quot;row &quot; + i + &quot; = &quot; + Arrays.toString(twoDimensionalNumbers[i]));<break/>        }<break/>        /*<break/>         * 1 2 3<break/>         * 4 5 6 7<break/>         * 8 9<break/>         * 10 11 12 13 14 15<break/>         */<break/>        for (int[] ints : twoDimensionalNumbers) {<break/>            for (int num : ints) {<break/>                System.out.print(num + &quot; &quot;);<break/>            }<break/>            System.out.println();<break/>        }<break/>        /*<break/>         * [1, 2, 3]<break/>         * [4, 5, 6, 7]<break/>         * [8, 9]<break/>         * [10, 11, 12, 13, 14, 15]<break/>         */<break/>        for (int[] ints : twoDimensionalNumbers) {<break/>            System.out.println(Arrays.toString(ints));<break/>        }<break/>        int length = 5;<break/>        int[] array = new int[length];<break/>        for (int i = 0; i &lt; 5; i++) {<break/>            array[i] = i + 1;<break/>        }<break/>        /*<break/>         * [1, 2, 3, 4, 5]<break/>         */<break/>        System.out.println(Arrays.toString(array));<break/>    }<break/>}<break/>
source from examplehub/java

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ declare ^ initialize ^ array ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Convert InputStream to byte array in Java -->
			^ convert inputstream ^ byte array ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You need to read each byte from your InputStream and write it to a ByteArrayOutputStream. 

					<delay>2</delay>
					You can then retrieve the underlying byte array by calling toByteArray():
InputStream is = ...<break/>ByteArrayOutputStream buffer = new ByteArrayOutputStream();<break/>int nRead;<break/>byte[] data = new byte[16384];<break/>while ((nRead = is.read(data, 0, data.length)) != -1) {<break/>  buffer.write(data, 0, nRead);<break/>}<break/>return buffer.toByteArray();<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can use Apache Commons IO to handle this and similar tasks.

					<delay>2</delay>
					The IOUtils type has a static method to read an InputStream and return a byte[].

					<delay>2</delay>
					InputStream is;<break/>byte[] bytes = IOUtils.toByteArray(is);<break/>
Internally this creates a ByteArrayOutputStream and copies the bytes to the output, then calls toByteArray().
					<delay>2</delay>
					It handles large files by copying the bytes in blocks of 4KiB.

					<delay>2</delay>
				</li>
				<li>
					
					Below Codes
public static byte[] serializeObj(Object obj) throws IOException {<break/>  ByteArrayOutputStream baOStream = new ByteArrayOutputStream();<break/>  ObjectOutputStream objOStream = new ObjectOutputStream(baOStream);<break/>  objOStream.writeObject(obj); <break/>  objOStream.flush();<break/>  objOStream.close();<break/>  return baOStream.toByteArray(); <break/>} <break/>
OR
BufferedImage img = ...<break/>ByteArrayOutputStream baos = new ByteArrayOutputStream(1000);<break/>ImageIO.write(img, "jpeg", baos);<break/>baos.flush();<break/>byte[] result = baos.toByteArray();<break/>baos.close();<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Do you really need the image as a byte[]?
					<delay>2</delay>
					What exactly do you expect in the byte[] - the complete content of an image file, encoded in whatever format the image file is in, or RGB pixel values?

					<delay>2</delay>
					Other answers here show you how to read a file into a byte[].
					<delay>2</delay>
					Your byte[] will contain the exact contents of the file, and you'd need to decode that to do anything with the image data.

					<delay>2</delay>
					Java's standard API for reading (and writing) images is the ImageIO API, which you can find in the package javax.imageio.
					<delay>2</delay>
					You can read in an image from a file with just a single line of code:
BufferedImage image = ImageIO.read(new File("image.jpg"));<break/>

					<delay>2</delay>
					This will give you a BufferedImage, not a byte[].
					<delay>2</delay>
					To get at the image data, you can call getRaster() on the byte[]0.
					<delay>2</delay>
					This will give you a byte[]1 object, which has methods to access the pixel data (it has several byte[]2 / byte[]3 methods).

					<delay>2</delay>
					Lookup the API documentation for byte[]4, byte[]5, byte[]6 etc.

					<delay>2</delay>
					ImageIO supports a number of image formats by default: JPEG, PNG, BMP, WBMP and GIF.
					<delay>2</delay>
					It's possible to add support for more formats (you'd need a plug-in that implements the ImageIO service provider interface).

					<delay>2</delay>
					See also the following tutorial: Working with Images

					<delay>2</delay>
				</li>
				<li>
					
					Input Stream is ...<break/>ByteArrayOutputStream bos = new ByteArrayOutputStream();<break/>int next = in.read();<break/>while (next &gt; -1) {<break/>    bos.write(next);<break/>    next = in.read();<break/>}<break/>bos.flush();<break/>byte[] result = bos.toByteArray();<break/>bos.close();<break/>

					<delay>2</delay>
				</li>
				<li>
					
					/*InputStream class_InputStream = null;<break/>I am reading class from DB <break/>class_InputStream = rs.getBinaryStream(1);<break/>Your Input stream could be from any source<break/>*/<break/>int thisLine;<break/>ByteArrayOutputStream bos = new ByteArrayOutputStream();<break/>while ((thisLine = class_InputStream.read()) != -1) {<break/>    bos.write(thisLine);<break/>}<break/>bos.flush();<break/>byte [] yourBytes = bos.toByteArray();<break/>/*Don't forget in the finally block to close ByteArrayOutputStream &amp; InputStream<break/> In my case the IS is from resultset so just closing the rs will do it*/<break/>if (bos != null){<break/>    bos.close();<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					@Adamski
					<delay>2</delay>
					: You can avoid buffer entirely.

					<delay>2</delay>
					Code copied from http://www.exampledepot.com/egs/java.io/File2ByteArray.html
					<delay>2</delay>
					(Yes, it is very verbose, but needs half the size of memory as the other solution.)

					<delay>2</delay>
					// Returns the contents of the file in a byte array.<break/>public static byte[] getBytesFromFile(File file) throws IOException {<break/>    InputStream is = new FileInputStream(file);<break/>    // Get the size of the file<break/>    long length = file.length();<break/>    // You cannot create an array using a long type.<break/>    // It needs to be an int type.<break/>    // Before converting to an int type, check<break/>    // to ensure that file is not larger than Integer.MAX_VALUE.<break/>    if (length &gt; Integer.MAX_VALUE) {<break/>        // File is too large<break/>    }<break/>    // Create the byte array to hold the data<break/>    byte[] bytes = new byte[(int)length];<break/>    // Read in the bytes<break/>    int offset = 0;<break/>    int numRead = 0;<break/>    while (offset &lt; bytes.length<break/>           &amp;&amp; (numRead=is.read(bytes, offset, bytes.length-offset)) &gt;= 0) {<break/>        offset += numRead;<break/>    }<break/>    // Ensure all the bytes have been read in<break/>    if (offset &lt; bytes.length) {<break/>        throw new IOException("Could not completely read file "+file.getName());<break/>    }<break/>    // Close the input stream and return bytes<break/>    is.close();<break/>    return bytes;<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Use vanilla Java's DataInputStream and its readFully Method (exists since at least Java 1.4):
...<break/>byte[] bytes = new byte[(int) file.length()];<break/>DataInputStream dis = new DataInputStream(new FileInputStream(file));<break/>dis.readFully(bytes);<break/>...<break/>

					<delay>2</delay>
					There are some other flavors of this method, but I use this all the time for this use case.

					<delay>2</delay>
				</li>
				<li>
					
					I tried to edit @numan's answer with a fix for writing garbage data but edit was rejected.
					<delay>2</delay>
					While this short piece of code is nothing brilliant I can't see any other better answer.
					<delay>2</delay>
					Here's what makes most sense to me:
ByteArrayOutputStream out = new ByteArrayOutputStream();<break/>byte[] buffer = new byte[1024]; // you can configure the buffer size<break/>int length;<break/>while ((length = in.read(buffer)) != -1) out.write(buffer, 0, length); //copy streams<break/>in.close(); // call this in a finally block<break/>byte[] result = out.toByteArray();<break/>
btw ByteArrayOutputStream need not be closed.
					<delay>2</delay>
					try/finally constructs omitted for readability

					<delay>2</delay>
				</li>
				<li>
					
					public static byte[] getBytesFromInputStream(InputStream is) throws IOException {<break/>    ByteArrayOutputStream os = new ByteArrayOutputStream(); <break/>    byte[] buffer = new byte[0xFFFF];<break/>    for (int len = is.read(buffer); len != -1; len = is.read(buffer)) { <break/>        os.write(buffer, 0, len);<break/>    }<break/>    return os.toByteArray();<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					ByteArrayOutputStream out = new ByteArrayOutputStream();<break/>byte[] buffer = new byte[1024];<break/>while (true) {<break/>    int r = in.read(buffer);<break/>    if (r == -1) break;<break/>    out.write(buffer, 0, r);<break/>}<break/>byte[] ret = out.toByteArray();<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you happen to use google guava, it'll be as simple as :
byte[] bytes = ByteStreams.toByteArray(inputStream);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you don't want to use the Apache commons-io library, this snippet is taken from the sun.misc.IOUtils class.
					<delay>2</delay>
					It's nearly twice as fast as the common implementation using ByteBuffers:
public static byte[] readFully(InputStream is, int length, boolean readAll)<break/>        throws IOException {<break/>    byte[] output = {};<break/>    if (length == -1) length = Integer.MAX_VALUE;<break/>    int pos = 0;<break/>    while (pos &lt; length) {<break/>        int bytesToRead;<break/>        if (pos &gt;= output.length) { // Only expand when there's no room<break/>            bytesToRead = Math.min(length - pos, output.length + 1024);<break/>            if (output.length &lt; pos + bytesToRead) {<break/>                output = Arrays.copyOf(output, pos + bytesToRead);<break/>            }<break/>        } else {<break/>            bytesToRead = output.length - pos;<break/>        }<break/>        int cc = is.read(output, pos, bytesToRead);<break/>        if (cc &lt; 0) {<break/>            if (readAll &amp;&amp; length != Integer.MAX_VALUE) {<break/>                throw new EOFException("Detect premature EOF");<break/>            } else {<break/>                if (output.length != pos) {<break/>                    output = Arrays.copyOf(output, pos);<break/>                }<break/>                break;<break/>            }<break/>        }<break/>        pos += cc;<break/>    }<break/>    return output;<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Here is an optimized version, that tries to avoid copying data bytes as much as possible:
private static byte[] loadStream (InputStream stream) throws IOException {<break/>   int available = stream.available();<break/>   int expectedSize = available &gt; 0 ? available : -1;<break/>   return loadStream(stream, expectedSize);<break/>}<break/>private static byte[] loadStream (InputStream stream, int expectedSize) throws IOException {<break/>   int basicBufferSize = 0x4000;<break/>   int initialBufferSize = (expectedSize &gt;= 0) ? expectedSize : basicBufferSize;<break/>   byte[] buf = new byte[initialBufferSize];<break/>   int pos = 0;<break/>   while (true) {<break/>      if (pos == buf.length) {<break/>         int readAhead = -1;<break/>         if (pos == expectedSize) {<break/>            readAhead = stream.read();       // test whether EOF is at expectedSize<break/>            if (readAhead == -1) {<break/>               return buf;<break/>            }<break/>         }<break/>         int newBufferSize = Math.max(2 * buf.length, basicBufferSize);<break/>         buf = Arrays.copyOf(buf, newBufferSize);<break/>         if (readAhead != -1) {<break/>            buf[pos++] = (byte)readAhead;<break/>         }<break/>      }<break/>      int len = stream.read(buf, pos, buf.length - pos);<break/>      if (len &lt; 0) {<break/>         return Arrays.copyOf(buf, pos);<break/>      }<break/>      pos += len;<break/>   }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					I know it's too late
					<delay>2</delay>
					but here I think is cleaner solution that's more readable...
/**<break/> * method converts {@link InputStream} Object into byte[] array.<break/> * <break/> * @param stream the {@link InputStream} Object.<break/> * @return the byte[] array representation of received {@link InputStream} Object.<break/> * @throws IOException if an error occurs.<break/> */<break/>public static byte[] streamToByteArray(InputStream stream) throws IOException {<break/>    byte[] buffer = new byte[1024];<break/>    ByteArrayOutputStream os = new ByteArrayOutputStream();<break/>    int line = 0;<break/>    // read bytes from stream, and store them in buffer<break/>    while ((line = stream.read(buffer)) != -1) {<break/>        // Writes bytes from byte array (buffer) into output stream.<break/>        os.write(buffer, 0, line);<break/>    }<break/>    stream.close();<break/>    os.flush();<break/>    os.close();<break/>    return os.toByteArray();<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					The other case to get correct byte array via stream, after send request to server and waiting for the response.

					<delay>2</delay>
					/**<break/>         * Begin setup TCP connection to PC app<break/>         * to open integrate connection between mobile app and pc app (or mobile app)<break/>         */<break/>        mSocket = new Socket(IP, port);<break/>       // mSocket.setSoTimeout(30000);<break/>        DataOutputStream mDos = new DataOutputStream(mSocket.getOutputStream());<break/>        String str = "MobileRequest#" + params[0] + "#&lt;EOF&gt;";<break/>        mDos.write(str.getBytes());<break/>        try {<break/>            Thread.sleep(1000);<break/>        } catch (InterruptedException e) {<break/>            e.printStackTrace();<break/>        }<break/>        /* Since data are accepted as byte, all of them will be collected in the<break/>        following byte array which initialised with accepted data length. */<break/>        DataInputStream mDis = new DataInputStream(mSocket.getInputStream());<break/>        byte[] data = new byte[mDis.available()];<break/>        // Collecting data into byte array<break/>        for (int i = 0; i &lt; data.length; i++)<break/>            data[i] = mDis.readByte();<break/>        // Converting collected data in byte array into String.<break/>        String RESPONSE = new String(data);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You're doing an extra copy if you use ByteArrayOutputStream.
					<delay>2</delay>
					If you know the length of the stream before you start reading it (e.g. the InputStream is actually a FileInputStream, and you can call file.length() on the file, or the InputStream is a zipfile entry InputStream, and you can call zipEntry.length
					<delay>2</delay>
					()), then it's far better to write directly into the byte
					<delay>2</delay>
					[] array
					<delay>2</delay>
					-- it uses half the memory, and saves time.

					<delay>2</delay>
					// Read the file contents into a byte[] array<break/>byte[] buf = new byte[inputStreamLength];<break/>int bytesRead = Math.max(0, inputStream.read(buf));<break/>// If needed: for safety, truncate the array if the file may somehow get<break/>// truncated during the read operation<break/>byte[] contents = bytesRead == inputStreamLength ? buf<break/>                  : Arrays.copyOf(buf, bytesRead);<break/>
N.B.
					<delay>2</delay>
					the last line above deals with files getting truncated while the stream is being read, if you need to handle that possibility, but if the file gets longer while the stream is being read, the contents in the byte[] array will not be lengthened to include the new file content, the array will simply be truncated to the old length inputStreamLength.

					<delay>2</delay>
				</li>
				<li>
					
					This works for me,
if(inputStream != null){<break/>                ByteArrayOutputStream contentStream = readSourceContent(inputStream);<break/>                String stringContent = contentStream.toString();<break/>                byte[] byteArr = encodeString(stringContent);<break/>            }<break/>
readSourceContent()
public static ByteArrayOutputStream readSourceContent(InputStream inputStream) throws IOException {<break/>        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();<break/>        int nextChar;<break/>        try {<break/>            while ((nextChar = inputStream.read()) != -1) {<break/>                outputStream.write(nextChar);<break/>            }<break/>            outputStream.flush();<break/>        } catch (IOException e) {<break/>            throw new IOException("Exception occurred while reading content", e);<break/>        }<break/>        return outputStream;<break/>    }<break/>
encodeString()
public static byte[] encodeString(String content) throws UnsupportedEncodingException {<break/>        byte[] bytes;<break/>        try {<break/>            bytes = content.getBytes();<break/>        } catch (UnsupportedEncodingException e) {<break/>            String msg = ENCODING + " is unsupported encoding type";<break/>            log.error(msg,e);<break/>            throw new UnsupportedEncodingException(msg, e);<break/>        }<break/>        return bytes;<break/>    }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					See the InputStream.available() documentation:
  It is particularly important to realize that you must not use this
  method to size a container and assume that you can read the entirety
  of the stream without needing to resize the container.
					<delay>2</delay>
					Such callers
  should probably write everything they read to a ByteArrayOutputStream
  and convert that to a byte array.
					<delay>2</delay>
					Alternatively, if you're reading
  from a file, File.length returns the current length of the file
  (though assuming the file's length can't change may be incorrect,
  reading a file is inherently racy).

					<delay>2</delay>
				</li>
				<li>
					
					I use this.

					<delay>2</delay>
					public static byte[] toByteArray(InputStream is) throws IOException {<break/>        ByteArrayOutputStream output = new ByteArrayOutputStream();<break/>        try {<break/>            byte[] b = new byte[4096];<break/>            int n = 0;<break/>            while ((n = is.read(b)) != -1) {<break/>                output.write(b, 0, n);<break/>            }<break/>            return output.toByteArray();<break/>        } finally {<break/>            output.close();<break/>        }<break/>    }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					This is my copy-paste version:
@SuppressWarnings("empty-statement")<break/>public static byte[] inputStreamToByte(InputStream is) throws IOException {<break/>    if (is == null) {<break/>        return null;<break/>    }<break/>    // Define a size if you have an idea of it.<break/>    ByteArrayOutputStream r = new ByteArrayOutputStream(2048);<break/>    byte[] read = new byte[512]; // Your buffer size.<break/>    for (int i; -1 != (i = is.read(read)); r.write(read, 0, i));<break/>    is.close();<break/>    return r.toByteArray();<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Java 7 and later:
import sun.misc.IOUtils;<break/>...<break/>InputStream in = ...;<break/>byte[] buf = IOUtils.readFully(in, -1, false);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Finally, after twenty years, there’s a simple solution without the need for a 3rd party library, thanks to Java 9:

					<delay>2</delay>
					InputStream is;<break/>…<break/>byte[] array = is.readAllBytes();<break/>
Note also the convenience methods readNBytes(byte[] b, int off, int len) and transferTo(OutputStream) addressing recurring needs.

					<delay>2</delay>
				</li>
				<li>
					
					Java 9 will give you finally a nice method:
InputStream in = ...;<break/>ByteArrayOutputStream bos = new ByteArrayOutputStream();<break/>in.transferTo( bos );<break/>byte[] bytes = bos.toByteArray();<break/>

					<delay>2</delay>
				</li>
				<li>
					
					As always, also Spring framework (spring-core since 3.2.2) has something for you: StreamUtils.copyToByteArray()

					<delay>2</delay>
				</li>
				<li>
					
					In-case someone is still looking for a solution without dependency and If you have a file.

					<delay>2</delay>
					DataInputStream

					<delay>2</delay>
					 byte[] data = new byte[(int) file.length()];<break/> DataInputStream dis = new DataInputStream(new FileInputStream(file));<break/> dis.readFully(data);<break/> dis.close();<break/>

					<delay>2</delay>
					ByteArrayOutputStream

					<delay>2</delay>
					 InputStream is = new FileInputStream(file);<break/> ByteArrayOutputStream buffer = new ByteArrayOutputStream();<break/> int nRead;<break/> byte[] data = new byte[(int) file.length()];<break/> while ((nRead = is.read(data, 0, data.length)) != -1) {<break/>     buffer.write(data, 0, nRead);<break/> }<break/>
RandomAccessFile

					<delay>2</delay>
					 RandomAccessFile raf = new RandomAccessFile(file, &quot;r&quot;);<break/> byte[] data = new byte[(int) raf.length()];<break/> raf.readFully(data);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Java 8 way (thanks to BufferedReader and Adam Bien)

					<delay>2</delay>
					private static byte[] readFully(InputStream input) throws IOException {<break/>    try (BufferedReader buffer = new BufferedReader(new InputStreamReader(input))) {<break/>        return buffer.lines().collect(Collectors.joining("\n")).getBytes(&lt;charset_can_be_specified&gt;);<break/>    }<break/>}<break/>
Note that this solution wipes carriage return ('\r') and can be inappropriate.

					<delay>2</delay>
				</li>
				<li>
					
					You can try Cactoos:
byte[] array = new BytesOf(stream).bytes();<break/>

					<delay>2</delay>
				</li>
				<li>
					
					We are seeing some delay for few AWS transaction, while converting S3 object to ByteArray.

					<delay>2</delay>
					Note:
					<delay>2</delay>
					S3 Object is PDF document (max size is 3 mb).

					<delay>2</delay>
					We are using the option #1 (org.apache.commons.io.IOUtils) to convert the S3 object to ByteArray.
					<delay>2</delay>
					We have noticed S3 provide the inbuild IOUtils method to convert the S3 object to ByteArray, we are request you to confirm what is the best way to convert the S3 object to ByteArray to avoid the delay.

					<delay>2</delay>
					Option #1:
import org.apache.commons.io.IOUtils;<break/>is = s3object.getObjectContent();<break/>content =IOUtils.toByteArray(is);<break/>
Option #2:
import com.amazonaws.util.IOUtils;<break/>is = s3object.getObjectContent();<break/>content =IOUtils.toByteArray(is);<break/>
Also let me know if we have any other better way to convert the s3 object to bytearray

					<delay>2</delay>
				</li>
				<li>
					
					Safe solution (with capability of close streams correctly):
Java 9+:
 final byte[] bytes;<break/> try (inputStream) {<break/>     bytes = inputStream.readAllBytes();<break/> }<break/>
Java 8:
 public static byte[] readAllBytes(InputStream inputStream) throws IOException {<break/>     final int bufLen = 4 * 0x400; // 4KB<break/>     byte[] buf = new byte[bufLen];<break/>     int readLen;<break/>     IOException exception = null;<break/>     try {<break/>         try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {<break/>             while ((readLen = inputStream.read(buf, 0, bufLen)) != -1)<break/>                 outputStream.write(buf, 0, readLen);<break/>             return outputStream.toByteArray();<break/>         }<break/>     } catch (IOException e) {<break/>         exception = e;<break/>         throw e;<break/>     } finally {<break/>         if (exception == null) inputStream.close();<break/>         else try {<break/>             inputStream.close();<break/>         } catch (IOException e) {<break/>             exception.addSuppressed(e);<break/>         }<break/>     }<break/> }<break/>
Kotlin (when Java 9+ isn't accessible):
 @Throws(IOException::class)<break/> fun InputStream.readAllBytes(): ByteArray {<break/>     val bufLen = 4 * 0x400 // 4KB<break/>     val buf = ByteArray(bufLen)<break/>     var readLen: Int = 0<break/>     ByteArrayOutputStream().use { o -&gt;<break/>         this.use { i -&gt;<break/>             while (i.read(buf, 0, bufLen).also { readLen = it } != -1)<break/>                 o.write(buf, 0, readLen)<break/>         }<break/>         return o.toByteArray()<break/>     }<break/> }<break/>

					<delay>2</delay>
					To avoid nested use see here.

					<delay>2</delay>
					Scala (when Java 9+ isn't accessible)
					<delay>2</delay>
					(By @Joan.
					<delay>2</delay>
					Thx):
def readAllBytes(inputStream: InputStream): Array[Byte] =<break/>  Stream.continually(inputStream.read).takeWhile(_ != -1).map(_.toByte).toArray<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Solution in Kotlin (will work in Java too, of course), which includes both cases of when you know the size or not:
    fun InputStream.readBytesWithSize(size: Long): ByteArray? {<break/>        return when {<break/>            size &lt; 0L -&gt; this.readBytes()<break/>            size == 0L -&gt; ByteArray(0)<break/>            size &gt; Int.MAX_VALUE -&gt; null<break/>            else -&gt; {<break/>                val sizeInt = size.toInt()<break/>                val result = ByteArray(sizeInt)<break/>                readBytesIntoByteArray(result, sizeInt)<break/>                result<break/>            }<break/>        }<break/>    }<break/>    fun InputStream.readBytesIntoByteArray(byteArray: ByteArray,bytesToRead:Int=byteArray.size) {<break/>        var offset = 0<break/>        while (true) {<break/>            val read = this.read(byteArray, offset, bytesToRead - offset)<break/>            if (read == -1)<break/>                break<break/>            offset += read<break/>            if (offset &gt;= bytesToRead)<break/>                break<break/>        }<break/>    }<break/>

					<delay>2</delay>
					If you know the size, it saves you on having double the memory used compared to the other solutions (in a brief moment, but still could be useful).
					<delay>2</delay>
					That's because you have to read the entire stream to the end, and then convert it to a byte array (similar to ArrayList which you convert to just an array).

					<delay>2</delay>
					So, if you are on Android, for example, and you got some Uri to handle, you can try to get the size using this:
    fun getStreamLengthFromUri(context: Context, uri: Uri): Long {<break/>        context.contentResolver.query(uri, arrayOf(MediaStore.MediaColumns.SIZE), null, null, null)?.use {<break/>            if (!it.moveToNext())<break/>                return@use<break/>            val fileSize = it.getLong(it.getColumnIndex(MediaStore.MediaColumns.SIZE))<break/>            if (fileSize &gt; 0)<break/>                return fileSize<break/>        }<break/>        //if you wish, you can also get the file-path from the uri here, and then try to get its size, using this: https://stackoverflow.com/a/61835665/878126<break/>        FileUtilEx.getFilePathFromUri(context, uri, false)?.use {<break/>            val file = it.file<break/>            val fileSize = file.length()<break/>            if (fileSize &gt; 0)<break/>                return fileSize<break/>        }<break/>        context.contentResolver.openInputStream(uri)?.use { inputStream -&gt;<break/>            if (inputStream is FileInputStream)<break/>                return inputStream.channel.size()<break/>            else {<break/>                var bytesCount = 0L<break/>                while (true) {<break/>                    val available = inputStream.available()<break/>                    if (available == 0)<break/>                        break<break/>                    val skip = inputStream.skip(available.toLong())<break/>                    if (skip &lt; 0)<break/>                        break<break/>                    bytesCount += skip<break/>                }<break/>                if (bytesCount &gt; 0L)<break/>                    return bytesCount<break/>            }<break/>        }<break/>        return -1L<break/>    }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can use cactoos library with provides reusable object-oriented Java components.

					<delay>2</delay>
					OOP is emphasized by this library, so no static methods, NULLs, and so on, only real objects and their contracts (interfaces).

					<delay>2</delay>
					A simple operation like reading InputStream, can be performed like that
final InputStream input = ...;<break/>final Bytes bytes = new BytesOf(input);<break/>final byte[] array = bytes.asBytes();<break/>Assert.assertArrayEquals(<break/>    array,<break/>    new byte[]{65, 66, 67}<break/>);<break/>
Having a dedicated type Bytes for working with data structure
					<delay>2</delay>
					byte[] enables us to use OOP tactics for solving tasks at hand.

					<delay>2</delay>
					Something that a procedural &quot;utility&quot; method will forbid us to do.

					<delay>2</delay>
					For example, you need to enconde bytes you've read from this InputStream to Base64.

					<delay>2</delay>
					In this case you will use Decorator pattern and wrap Bytes object within implementation for Base64.

					<delay>2</delay>
					cactoos already provides such implementation:

					<delay>2</delay>
					final Bytes encoded = new BytesBase64(<break/>    new BytesOf(<break/>        new InputStreamOf(&quot;XYZ&quot;)<break/>    )<break/>);<break/>Assert.assertEquals(new TextOf(encoded).asString(), &quot;WFla&quot;);<break/>
You can decode them in the same manner, by using Decorator pattern
final Bytes decoded = new Base64Bytes(<break/>    new BytesBase64(<break/>        new BytesOf(<break/>            new InputStreamOf(&quot;XYZ&quot;)<break/>        )<break/>    )<break/>);<break/>Assert.assertEquals(new TextOf(decoded).asString(), &quot;XYZ&quot;);<break/>
Whatever your task is you will be able to create own implementation of Bytes to solve it.

					<delay>2</delay>
				</li>
				<li>
					
					In new version,
IOUtils.readAllBytes(inputStream)<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Wrap it in a DataInputStream if that is off the table for some reason, just use read to hammer on it until it gives you a -1 or the entire block you asked for.

					<delay>2</delay>
					public int readFully(InputStream in, byte[] data) throws IOException {<break/>    int offset = 0;<break/>    int bytesRead;<break/>    boolean read = false;<break/>    while ((bytesRead = in.read(data, offset, data.length - offset)) != -1) {<break/>        read = true;<break/>        offset += bytesRead;<break/>        if (offset &gt;= data.length) {<break/>            break;<break/>        }<break/>    }<break/>    return (read) ? offset : -1;<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ convert inputstream ^ byte array ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- When is an ArrayList preferable to an array in Java? -->
			^ arraylist preferable ^ array ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					ArrayLists are useful when you don't know in advance the number of elements you will need.
					<delay>2</delay>
					Simple Example: you are reading a text file and builing a list of all the words you find.
					<delay>2</delay>
					You can just keep adding to your array list, it will grow.

					<delay>2</delay>
					Arrays you need to pre-declare their size.

					<delay>2</delay>
				</li>
				<li>
					
					An array has to be declared with a fixed size therefore you need to know the number of elements in advance.

					<delay>2</delay>
					An ArrayList is preferable when you don't know how many elements you will need in advance as it can grow as desired.

					<delay>2</delay>
					An ArrayList may also be preferable if you need to perform operations that are available in its API that would required manual implementation for an array.
					<delay>2</delay>
					(e.g. indexOf)

					<delay>2</delay>
				</li>
				<li>
					
					Some differences:
Arrays are immutable in their size, you cannot easly remove and element and remove the hole whereas using an ArrayList is
					<delay>2</delay>
					straightforward
Arrays are fast (handled directly by the JVM as special objects) than an ArrayList and requires less memory 

					<delay>2</delay>
					Arrays have a nice syntax for accessing elements (e.g. a[i] vs a.get(i))

					<delay>2</delay>
					Arrays don't play well with generics (e.g. you cannot create a generic array)

					<delay>2</delay>
					Arrays cannot be easly wrapped as ArrayList (e.g. Collections utils like checkedList, synchronizedList and unmodifiableList)
declaring the ArrayList as List you can easly swap implementation with a LinkedList when you need; this imho is the best advantage over plain arrays 

					<delay>2</delay>
					Array's toString, a[i]0 and
					<delay>2</delay>
					a[i]1 are weird and error-prone, you must use Arrays class utilities

					<delay>2</delay>
				</li>
				<li>
					
					When you want to change its size by adding or removing elements.

					<delay>2</delay>
					When you want to pass it to something that wants a Collection or Iterable (although you can use Arrays.asList(a) to make an array, a, look like a List).

					<delay>2</delay>
				</li>
				<li>
					
					Another couple of points:
You may want to consider using an array to represent more than one dimension (e.g. matrix).

					<delay>2</delay>
					Arrays can be used to store primitives and hence offer a more compact representation of your data than using an ArrayList.

					<delay>2</delay>
				</li>
				<li>
					
					I would say the default presumption should be to use an ArrayList unless you have a specific need, simply because it keeps your code more flexible and less error prone.
					<delay>2</delay>
					No need to expand the declaration size when you add an extra element 500 lines of code away, etc.
					<delay>2</delay>
					And reference the List interface, so you can replace the Array list with a LinkedList or a CopyOnWriteArrayList or any other list implementation that may help a situation without having to change a lot of code.

					<delay>2</delay>
					That being said, arrays have some properties that you just won't get out of a list.
					<delay>2</delay>
					One is a defined size with null elements.
					<delay>2</delay>
					This can be useful if you don't want to keep things in a sequential order.
					<delay>2</delay>
					For example a tic-tac-toe game.

					<delay>2</delay>
					Arrays can be multi-dimensional.
					<delay>2</delay>
					ArrayLists cannot.

					<delay>2</delay>
					Arrays can deal with primitives, something an ArrayList cannot (although there are third party collection classes that wrap primitives, they aren't part of the standard collections API).

					<delay>2</delay>
				</li>
				<li>
					
					It's not only about the fact that arrays need to grow, a collection is easier to deal with.

					<delay>2</delay>
					Sometimes arrays are fine, when you just need to iterate over elements, read-only.
					<delay>2</delay>
					However, most of the time you want to use methods like contains, etc. 

					<delay>2</delay>
					You can't create generic arrays
					<delay>2</delay>
					so it 'might' or might not bother you.

					<delay>2</delay>
					When in doubt, use Collections, it will make people that use your API love you :-).
					<delay>2</delay>
					If you only provide them with arrays, the first lines of code that they'll write is : 
Arrays.asList(thatGuyArray);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					The List interface, of which ArrayList is an implementation in the Java Collections Framework is much richer then what a plain Java array has to offer.
					<delay>2</delay>
					Due to the relatively widespread support of the collection framework throughout Java and 3rd party libraries, using an ArrayList instead of an array makes sense in general.
					<delay>2</delay>
					I'd only use arrays if there is really need for them:
They are required by some other interface I'm calling
Profiling
					<delay>2</delay>
					shows a bottleneck in a situation where array access can yield a significant speedup over list access
Situations where an array feels more natural such as buffers of raw data as in
byte[] buffer = new byte[0x400]; // allocate 1k byte buffer<break/>

					<delay>2</delay>
					You can always get an array representation of your ArrayList if you need one:

					<delay>2</delay>
					Foo[] bar = fooList.toArray(new Foo[fooList.size()])<break/>

					<delay>2</delay>
					It is a common failure pattern that methods return a reference to a private array member (field) of a class.
					<delay>2</delay>
					This breaks the class' encapsulation as outsiders gain mutable access to the class' private state.
					<delay>2</delay>
					Consequently you would need to always clone the array and return a reference to the cloned array.
					<delay>2</delay>
					With an ArrayList you can use...
return Collections.unmodifiableList(privateListMember);<break/>
...
					<delay>2</delay>
					in order to return a wrapper that protects the actual list object.
					<delay>2</delay>
					Of course you need to make sure that the objects in the list are immutable too, but that also holds for a (cloned) array of mutable objects. 

					<delay>2</delay>
					As per Nick Holt's comment, you shouldn't expose the fact that a List is an ArrayList anywhere:
private List&lt;Foo&gt; fooList = new ArrayList&lt;Foo&gt;();<break/>public List&lt;Foo&gt; getFooList() {<break/>    return Collections.unmodifiableList(fooList);<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					G'day,
A couple of points that people seem to have missed so far.

					<delay>2</delay>
					an array can only contain one type of object whereas an ArrayList is a container that can contain a mixture of object types, it's heterogeneous,
an array must declare the type of its contents when the array itself is declared.
					<delay>2</delay>
					An ArrayList doesn't have to declare the type of its contents when the ArrayList is declared,
you must insert an item into a specific location in an array.
					<delay>2</delay>
					Adding to an ArrayList is done by means of the add() method on the container, and
objects are stored in an array and retain their type because of the way the array can only store objects of a particular type.
					<delay>2</delay>
					Objects are stored in an ArrayList by means of the superclass type Object.

					<delay>2</delay>
					Edit: Ooop.
					<delay>2</delay>
					Regarding the last point on the list, I forgot the special case where you have an array of Objects then these arrays can also contain any type of object.
					<delay>2</delay>
					Thanks for the comment, Yishai!
					<delay>2</delay>
					(-:

					<delay>2</delay>
					HTH
cheers,

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ arraylist preferable ^ array ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How do I populate a JComboBox with an ArrayList? -->
			^ populate ^ jcombobox ^ arraylist 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Use the toArray() method of the ArrayList class and pass it into the constructor of the JComboBox
See the JavaDoc and tutorial for more info.

					<delay>2</delay>
				</li>
				<li>
					
					i think that is the solution
ArrayList&lt;table&gt; libel = new ArrayList&lt;table&gt;();<break/>try {<break/>SessionFactory sf = new Configuration().configure().buildSessionFactory();<break/>Session s = sf.openSession();<break/>s.beginTransaction();<break/>String hql = "FROM table ";<break/>org.hibernate.Query query = s.createQuery(hql);<break/>libel= (ArrayList&lt;table&gt;) query.list();<break/>Iterator it = libel.iterator();<break/>while(it.hasNext()) {<break/>table cat = (table) it.next();<break/>cat.getLibCat();//table colonm getter<break/>combobox.addItem(cat.getLibCat());<break/>}<break/>s.getTransaction().commit();<break/>s.close();<break/>sf.close();<break/>} catch (Exception e) {<break/>System.out.println("Exception in getSelectedData::"+e.getMessage());<break/>

					<delay>2</delay>
				</li>
				<li>
					
					I don't like the accepted answer or @fivetwentysix's comment regarding how to solve this.
					<delay>2</delay>
					It gets at one method for doing this, but doesn't give the full solution to using toArray.
					<delay>2</delay>
					You need to use toArray and give it an argument that's an array of the correct type and size so that you don't end up with an Object array.
					<delay>2</delay>
					While an object array will work, I don't think it's best practice in a strongly typed language.

					<delay>2</delay>
					String[] array = arrayList.toArray(new String[arrayList.size()]);<break/>JComboBox comboBox = new JComboBox(array);<break/>

					<delay>2</delay>
					Alternatively, you can also maintain strong typing by just using a for loop.

					<delay>2</delay>
					String[] array = new String[arrayList.size()];<break/>for(int i = 0; i &lt; array.length; i++) {<break/>    array[i] = arrayList.get(i);<break/>}<break/>JComboBox comboBox = new JComboBox(array);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Elegant way to fill combo box with an array list :
List&lt;String&gt; ls = new ArrayList&lt;String&gt;(); <break/>jComboBox.setModel(new DefaultComboBoxModel&lt;String&gt;(ls.toArray(new String[0])));<break/>

					<delay>2</delay>
				</li>
				<li>
					
					I believe you can create a new Vector using your ArrayList and pass that to the JCombobox Constructor.

					<delay>2</delay>
					JComboBox&lt;String&gt; combobox = new JComboBox&lt;String&gt;(new Vector&lt;String&gt;(myArrayList));<break/>

					<delay>2</delay>
					my example is only strings though.

					<delay>2</delay>
				</li>
				<li>
					
					DefaultComboBoxModel dml= new DefaultComboBoxModel();<break/>for (int i = 0; i &lt; &lt;ArrayList&gt;.size(); i++) {<break/>  dml.addElement(&lt;ArrayList&gt;.get(i).getField());<break/>}<break/>&lt;ComboBoxName&gt;.setModel(dml);<break/>
Understandable code.
					<delay>2</delay>
					Edit&lt;&gt;
					<delay>2</delay>
					with type as required.

					<delay>2</delay>
				</li>
				<li>
					
					Check this simple code
import java.util.ArrayList;<break/>import javax.swing.JComboBox;<break/>import javax.swing.JFrame;<break/>public class FirstFrame extends JFrame{<break/>    static JComboBox&lt;ArrayList&gt; mycombo;<break/>    FirstFrame()<break/>    {<break/>        this.setSize(600,500);<break/>        this.setTitle("My combo");<break/>        this.setLayout(null);<break/>        ArrayList&lt;String&gt; names=new ArrayList&lt;String&gt;();   <break/>        names.add("jessy");<break/>        names.add("albert");<break/>        names.add("grace");<break/>        mycombo=new JComboBox(names.toArray());<break/>        mycombo.setBounds(60,32,200,50);<break/>        this.add(mycombo);<break/>        this.setVisible(true); // window visible<break/>    }   <break/>    public static void main(String[] args) {<break/>        FirstFrame frame=new FirstFrame();  <break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					By combining existing answers (this one and this one) the proper type safe way to add an ArrayList to a JComboBox is the following:
private DefaultComboBoxModel&lt;YourClass&gt; getComboBoxModel(List&lt;YourClass&gt; yourClassList)<break/>{<break/>    YourClass[] comboBoxModel = yourClassList.toArray(new YourClass[0]);<break/>    return new DefaultComboBoxModel&lt;&gt;(comboBoxModel);<break/>}<break/>

					<delay>2</delay>
					In your GUI code you set the entire list into your JComboBox as follows:
DefaultComboBoxModel&lt;YourClass&gt; comboBoxModel = getComboBoxModel(yourClassList);<break/>comboBox.setModel(comboBoxModel);<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ populate ^ jcombobox ^ arraylist </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java: Copy array of non-primitive type -->
			^ java ^ copy array ^ non ^ primitive type 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					System.arraycopy<break/>
(which gives you the ability to copy arbitrary portions of an array via the offset and length parameters).
					<delay>2</delay>
					Or
java.util.Arrays.copyOf<break/>
Which was added in JDK 6 and is a generic method so it can be used:
$
					<delay>2</delay>
					code_placeholder_5

					<delay>2</delay>
					Or it can narrow a type:
Number[] is = new Number[]{4, 5};<break/>Integer[] copy = Arrays.copyOf(is, is.length, Integer[].class);<break/>
Note that you can also use the clone method on an array:
Number[] other = is.clone();<break/>

					<delay>2</delay>
				</li>
				<li>
					
					The old school way was:
public static void java.lang.System.arraycopy(Object src, int srcPos, <break/>         Object dest, int destPos, int length)<break/>

					<delay>2</delay>
					This copys from one existing array to another.  
					<delay>2</delay>
					You have to allocate the new array yourself ...
					<delay>2</delay>
					assuming that you are making a copy of an array.

					<delay>2</delay>
					From JDK 6 onwards, the java.util.Arrays class has a number of copyOf methods for making copies of arrays, with a new size.  
					<delay>2</delay>
					The ones that are relevant are:
public static &lt;T&gt; T[] copyOf(T[] original, int newLength)<break/>
and
public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength,<break/>         Class&lt;? extends T[]&gt; newType)<break/>
This first one makes a copy using the original array type, and the second one makes a copy with a different array type.

					<delay>2</delay>
					Note that both arraycopy and the 3 argument copyOf have to check the types of each of the elements in the original (source) array against the target array type.  
					<delay>2</delay>
					So both can throw type exceptions.  
					<delay>2</delay>
					The 2 argument copyOf (in theory at least) does not need to do any type checking and therefore should be (in theory) faster.  
					<delay>2</delay>
					In practice the relative performance will be implementation dependent.  
					<delay>2</delay>
					For instance, arraycopy is often given special treatment by the JVM.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java ^ copy array ^ non ^ primitive type </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java ( Counting Distinct Integers ) -->
			^ java ^ counting distinct integers 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					A set stores each unique (as defined by .equals
					<delay>2</delay>
					()) element in it only once, and you can use this to simplify the problem.
					<delay>2</delay>
					Create a Set (I'd use a HashSet), iterate your array, adding each integer to the Set, then return .size() of the Set.

					<delay>2</delay>
				</li>
				<li>
					
					Set&lt;Integer&gt; s = new HashSet&lt;Integer&gt;();<break/>for (int i : a) s.add(i);<break/>int distinctCount = s.size();<break/>

					<delay>2</delay>
				</li>
				<li>
					
					An efficient method:
					<delay>2</delay>
					Sort the array with Arrays.sort.
					<delay>2</delay>
					Write a simple loop to count up adjacent equal values.

					<delay>2</delay>
				</li>
				<li>
					
					Really depends on the numbers of elements in the array.
					<delay>2</delay>
					If you're not dealing with a large amount of integers, a HashSet or a binary tree would probably be the best approach.
					<delay>2</delay>
					On the other hand, if you have a large array of diverse integers (say, more than a billion) it might make sense to allocate a 2^32 / 2^8 = 512 MByte byte array in which each bit represents the existence or non-existence of an integer and then count the number of set bits in the end. 

					<delay>2</delay>
					A binary tree approach would take n
					<delay>2</delay>
					* log n time, while an array approach would take n time.
					<delay>2</delay>
					Also, a binary tree requires two pointers per node, so your memory usage would be a lot higher as well.
					<delay>2</delay>
					Similar consideration apply to hash tables as well.

					<delay>2</delay>
					Of course, if your set is small, then just use the inbuilt HashSet.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java ^ counting distinct integers </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java: function for arrays like PHP's join()? -->
			^ java ^ function ^ arrays like php 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Starting from Java8 it is possible to use String.join().

					<delay>2</delay>
					String.join(", ", new String[]{"Hello", "World", "!"})<break/>
Generates:

					<delay>2</delay>
					Hello, World, !<break/>
Otherwise, Apache Commons Lang has a StringUtils class which has a join function which will join arrays together to make a String.

					<delay>2</delay>
					For example:
StringUtils.join(new String[] {"Hello", "World", "!"}, ", ")<break/>
Generates the following String:
Hello, World, !<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Not in core, no.
					<delay>2</delay>
					A search for "java array join string glue" will give you some code snippets on how to achieve this though.

					<delay>2</delay>
					e.g.
public static String join(Collection s, String delimiter) {<break/>    StringBuffer buffer = new StringBuffer();<break/>    Iterator iter = s.iterator();<break/>    while (iter.hasNext()) {<break/>        buffer.append(iter.next());<break/>        if (iter.hasNext()) {<break/>            buffer.append(delimiter);<break/>        }<break/>    }<break/>    return buffer.toString();<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Nothing built-in that I know of.

					<delay>2</delay>
					Apache Commons Lang has a class called StringUtils which contains many join functions.

					<delay>2</delay>
				</li>
				<li>
					
					You could easily write such a function in about ten lines of code:
String combine(String[] s, String glue)<break/>{<break/>  int k = s.length;<break/>  if ( k == 0 )<break/>  {<break/>    return null;<break/>  }<break/>  StringBuilder out = new StringBuilder();<break/>  out.append( s[0] );<break/>  for ( int x=1; x &lt; k; ++x )<break/>  {<break/>    out.append(glue).append(s[x]);<break/>  }<break/>  return out.toString();<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					java.util.Arrays has an 'asList' method.
					<delay>2</delay>
					Together with the java.util.List/ArrayList API this gives you all you need:;
private static String[] join(String[] array1, String[] array2) {<break/>    List&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(array1));<break/>    list.addAll(Arrays.asList(array2));<break/>    return list.toArray(new String[0]);<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					This is how I do it.

					<delay>2</delay>
					private String join(String[] input, String delimiter)<break/>{<break/>    StringBuilder sb = new StringBuilder();<break/>    for(String value : input)<break/>    {<break/>        sb.append(value);<break/>        sb.append(delimiter);<break/>    }<break/>    int length = sb.length();<break/>    if(length &gt; 0)<break/>    {<break/>        // Remove the extra delimiter<break/>        sb.setLength(length - delimiter.length());<break/>    }<break/>    return sb.toString();<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Given:
String[] a = new String[] { "Hello", "World", "!" };<break/>
Then as an alternative to coobird's answer, where the glue is ", ":
Arrays.asList(a).toString().replaceAll("^\\[|\\]$", "")<break/>
Or to concatenate with a different string, such as " &amp;amp; ".

					<delay>2</delay>
					Arrays.asList(a).toString().replaceAll(", ", " &amp;amp; ").replaceAll("^\\[|\\]$", "")<break/>

					<delay>2</delay>
					However...
					<delay>2</delay>
					this one ONLY works if you know that the values in the array or list DO NOT contain the character string ", ".

					<delay>2</delay>
				</li>
				<li>
					
					A little mod instead of using substring():
//join(String array,delimiter)<break/>public static String join(String r[],String d)<break/>{<break/>        if (r.length == 0) return "";<break/>        StringBuilder sb = new StringBuilder();<break/>        int i;<break/>        for(i=0;i&lt;r.length-1;i++){<break/>            sb.append(r[i]);<break/>            sb.append(d);<break/>        }<break/>        sb.append(r[i]);<break/>        return sb.toString();<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Google guava's library also has this kind of capability.
					<delay>2</delay>
					You can see the String[] example also from the API.

					<delay>2</delay>
					As already described in the api, beware of the immutability of the builder methods.

					<delay>2</delay>
					It can accept an array of objects so it'll work in your case.
					<delay>2</delay>
					In my previous experience, i tried joining a Stack which is an iterable and it works fine.

					<delay>2</delay>
					Sample from me :
Deque&lt;String&gt; nameStack = new ArrayDeque&lt;&gt;();<break/>nameStack.push("a coder");<break/>nameStack.push("i am");<break/>System.out.println("|" + Joiner.on(' ').skipNulls().join(nameStack) + "|");<break/>
prints out : |i am a coder|

					<delay>2</delay>
				</li>
				<li>
					
					If you are using the Spring Framework then you have the StringUtils class:
import static org.springframework.util.StringUtils.arrayToDelimitedString;<break/>arrayToDelimitedString(new String[] {"A", "B", "C"}, "\n");<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you've landed here looking for a quick array-to-string conversion, try Arrays.toString().
  Creates a String representation of the Object[] passed.
					<delay>2</delay>
					The result is
  surrounded by brackets ("[]"), each element is converted to a String
  via the String.valueOf(Object) and separated by ", ".
					<delay>2</delay>
					If the array is
  null, then "null" is returned.

					<delay>2</delay>
				</li>
				<li>
					
					A similar alternative
/**<break/> * @param delimiter <break/> * @param inStr<break/> * @return String<break/> */<break/>public static String join(String delimiter, String... inStr)<break/>{<break/>    StringBuilder sb = new StringBuilder();<break/>    if (inStr.length &gt; 0)<break/>    {<break/>        sb.append(inStr[0]);<break/>        for (int i = 1; i &lt; inStr.length; i++)<break/>        {<break/>            sb.append(delimiter);                   <break/>            sb.append(inStr[i]);<break/>        }<break/>    }<break/>    return sb.toString();<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you were looking for what to use in android, it is:
String android.text.TextUtils.join(CharSequence delimiter, Object[] tokens)<break/>
for example:
String joined = TextUtils.join(";", MyStringArray);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					I do it this way using a StringBuilder:
public static String join(String[] source, String delimiter) {<break/>    if ((null == source) || (source.length &lt; 1)) {<break/>        return "";<break/>    }<break/>    StringBuilder stringbuilder = new StringBuilder();<break/>    for (String s : source) {<break/>        stringbuilder.append(s + delimiter);<break/>    }<break/>    return stringbuilder.toString();<break/>} // join((String[], String)<break/>

					<delay>2</delay>
				</li>
				<li>
					
					
  There is simple shorthand technique I use most of the times..
String op = new String;<break/>for (int i : is) <break/>{<break/>    op += candidatesArr[i-1]+",";<break/>}<break/>op = op.substring(0, op.length()-1);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					
Just for the "I've the shortest one" challenge, here are mines ;)
Iterative:
public static String join(String s, Object... a) {<break/>    StringBuilder o = new StringBuilder();<break/>    for (Iterator&lt;Object&gt; i = Arrays.asList(a).iterator(); i.hasNext();)<break/>        o.append(i.next()).append(i.hasNext() ? s : "");<break/>    return o.toString();<break/>}<break/>
Recursive:
public static String join(String s, Object... a) {<break/>    return a.length == 0 ? "" : a[0] + (a.length == 1 ? "" : s + join(s, Arrays.copyOfRange(a, 1, a.length)));<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Do you like my 3-lines way using only String class's methods?

					<delay>2</delay>
					static String join(String glue, String[] array) {<break/>    String line = "";<break/>    for (String s : array) line += s + glue;<break/>    return (array.length == 0) ? line : line.substring(0, line.length() - glue.length());<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					In Java 8 you can use 
1) Stream API :
String[] a = new String[] {"a", "b", "c"};<break/>String result = Arrays.stream(a).collect(Collectors.joining(", "));<break/>
2) new String.join method: https://stackoverflow.com/a/21756398/466677 
3)
					<delay>2</delay>
					java.util.StringJoiner class: http://docs.oracle.com/javase/8/docs/api/java/util/StringJoiner.html

					<delay>2</delay>
				</li>
				<li>
					
					My spin.

					<delay>2</delay>
					public static String join(Object[] objects, String delimiter) {<break/>  if (objects.length == 0) {<break/>    return "";<break/>  }<break/>  int capacityGuess = (objects.length * objects[0].toString().length())<break/>      + ((objects.length - 1) * delimiter.length());<break/>  StringBuilder ret = new StringBuilder(capacityGuess);<break/>  ret.append(objects[0]);<break/>  for (int i = 1; i &lt; objects.length; i++) {<break/>    ret.append(delimiter);<break/>    ret.append(objects[i]);<break/>  }<break/>  return ret.toString();<break/>}<break/>public static String join(Object... objects) {<break/>  return join(objects, "");<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					As with many questions lately, Java 8 to the rescue:
Java 8 added a new static method to java.lang.String which does exactly what you want:

					<delay>2</delay>
					public static String join(CharSequence delimeter, CharSequence... elements);<break/>
Using it:
String s = String.join(", ", new String[] {"Hello", "World", "!"});<break/>
Results in:
"Hello, World, !"<break/>

					<delay>2</delay>
				</li>
				<li>
					
					To get "str1, str2" from "str1", "str2", "" :
Stream.of("str1", "str2", "").filter(str -&gt; !str.isEmpty()).collect(Collectors.joining(", ")); <break/>
Also you can add extra null-check

					<delay>2</delay>
				</li>
				<li>
					
					In case you're using Functional Java library and for some reason can't use Streams from Java 8 (which might be the case when using Android + Retrolambda plugin), here is a functional solution for you:
String joinWithSeparator(List&lt;String&gt; items, String separator) {<break/>    return items<break/>            .bind(id -&gt; list(separator, id))<break/>            .drop(1)<break/>            .foldLeft(<break/>                    (result, item) -&gt; result + item,<break/>                    ""<break/>            );<break/>}<break/>
Note that it's not the most efficient approach, but it does work good for small lists.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java ^ function ^ arrays like php </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Creating a byte[] from a List -->
			^ creating ^ list 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					The toArray() method sounds like a good choice.

					<delay>2</delay>
					Update:
					<delay>2</delay>
					Although, as folks have kindly pointed out, this works with "boxed" values.
					<delay>2</delay>
					So a plain for-loop looks like a very good choice, too.

					<delay>2</delay>
				</li>
				<li>
					
					byte[] byteArray = new byte[byteList.size()];<break/>for (int index = 0; index &lt; byteList.size(); index++) {<break/>    byteArray[index] = byteList.get(index);<break/>}<break/>

					<delay>2</delay>
					You may not like it but that’s about the only way to create a Genuine™ Array® of byte.

					<delay>2</delay>
					As pointed out in the comments, there are other ways.
					<delay>2</delay>
					However, none of those ways gets around a) creating an array and b) assigning each element.
					<delay>2</delay>
					This one uses an iterator.

					<delay>2</delay>
					byte[] byteArray = new byte[byteList.size()];<break/>int index = 0;<break/>for (byte b : byteList) {<break/>    byteArray[index++] = b;<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Using Bytes.toArray(Collection&lt;Byte&gt;) (from Google's Guava library.)

					<delay>2</delay>
					Example:
import java.util.ArrayList;<break/>import java.util.Arrays;<break/>import java.util.List;<break/>import com.google.common.primitives.Bytes;<break/>class Test {<break/>    public static void main(String[] args) {<break/>        List&lt;Byte&gt; byteList = new ArrayList&lt;Byte&gt;();<break/>        byteList.add((byte) 1);<break/>        byteList.add((byte) 2);<break/>        byteList.add((byte) 3);<break/>        byte[] byteArray = Bytes.toArray(byteList);<break/>        System.out.println(Arrays.toString(byteArray));<break/>    }<break/>}<break/>
Or similarly, using PCJ:
import bak.pcj.Adapter;<break/>// ...<break/>byte[] byteArray = Adapter.asBytes(byteList).toArray();<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ creating ^ list </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- When to use a List over an Array in Java? -->
			^ use ^ list ^ array ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					If you want the array of items to expand (i.e. if you don't know what the size of the list will be beforehand), a List will be beneficial.
					<delay>2</delay>
					However, if you want performance, you would generally use an array.

					<delay>2</delay>
				</li>
				<li>
					
					Pretty much always prefer a list.
					<delay>2</delay>
					Lists have much more functionality, particularly iterator support.
					<delay>2</delay>
					You can convert a list to an array at any time with the toArray() method.

					<delay>2</delay>
				</li>
				<li>
					
					It depends on what kind of List.

					<delay>2</delay>
					It's better to use a LinkedList if you know you'll be inserting many elements in positions other than the end.
					<delay>2</delay>
					LinkedList is not suitable for random access (getting the i'th element).

					<delay>2</delay>
					It's better to use an ArrayList if you don't know, in advance, how many elements there are going to be.
					<delay>2</delay>
					The ArrayList correctly amortizes the cost of growing the backing array as you add more elements to it, and is suitable for random access once the elements are in place.
					<delay>2</delay>
					An ArrayList can be efficiently sorted.

					<delay>2</delay>
				</li>
				<li>
					
					I see the question as being the opposite- 

					<delay>2</delay>
					When should you use an Array over a List? 

					<delay>2</delay>
					Only you have a specific reason to do so (eg: Project Constraints, Memory Concerns (not really a good reason), etc.)

					<delay>2</delay>
					Lists are much easier to use (imo), and have much more functionality. 

					<delay>2</delay>
					Note:
					<delay>2</delay>
					You should also consider whether or not something like a Set, or another datastructure is a better fit than a List for what you are trying to do.

					<delay>2</delay>
					Each datastructure, and implmentation, has different pros/cons.
					<delay>2</delay>
					Pick the ones that excel at the things that you need to do.

					<delay>2</delay>
					If you need get() to be O(1) for any item?
					<delay>2</delay>
					Likely use an ArrayList, Need O(1) insert()?
					<delay>2</delay>
					Possibly a Linked List.
					<delay>2</delay>
					Need O(1) contains()?
					<delay>2</delay>
					Possibly a Hashset.

					<delay>2</delay>
					TLDR:
					<delay>2</delay>
					Each data structure is good at some things, and bad at others.
					<delay>2</delay>
					Look at your objectives and choose the data structure that best fits the given problem.

					<delay>2</delay>
					Edit: 
  One thing not noted is that you're
  better off declaring the variable as
  its interface (i.e. List or Queue)
  rather than its implementing class.
  
					<delay>2</delay>
					This way, you can change the
  implementation at some later date
  without changing anything else in the
  code. 
  
  
					<delay>2</delay>
					As an example: 
List&lt;String&gt; myList = new ArrayList&lt;String&gt;(); <break/>
  vs
List&lt;String&gt; myList = new LinkedList&lt;String&gt;(); <break/>
  Note that myList is a List in both examples.
  
					<delay>2</delay>
					--R.
					<delay>2</delay>
					Bemrose

					<delay>2</delay>
				</li>
				<li>
					
					In many cases the type of collection used is an implementation detail which shouldn't be exposed to the outside world.
					<delay>2</delay>
					The more generic your returntype is the more flexibility you have changing the implementation afterwards.

					<delay>2</delay>
					Arrays (primitive type, ie.
					<delay>2</delay>
					new int[10]) are not generic, you won't be able to change you implementation without an internal conversion or altering the client code.
					<delay>2</delay>
					You might want to consider Iterable as a returntype.

					<delay>2</delay>
				</li>
				<li>
					
					If you know how many things you'll be holding, you'll want an array.  
					<delay>2</delay>
					My screen is 1024x768, and a buffer of pixels for that isn't going to change in size ever during runtime.

					<delay>2</delay>
					If you know you'll need to access specific indexes (go get item #763!), use an array or array-backed list.

					<delay>2</delay>
					If you need to add or remove items from the group regularly, use a linked list.

					<delay>2</delay>
					In general, dealing with hardware, arrays, dealing with users, lists.

					<delay>2</delay>
				</li>
				<li>
					
					Rules of thumb:
Use a List for reference types.

					<delay>2</delay>
					Use arrays for primitives.

					<delay>2</delay>
					If you have to deal with an API that is using arrays, it might be useful to use arrays.
					<delay>2</delay>
					OTOH, it may be useful to enforce defensive copying with the type system by using Lists.

					<delay>2</delay>
					If you are doing a lot of List type operations on the sequence and it is not in a performance/memory critical section, then use List.

					<delay>2</delay>
					Low-level optimisations may use arrays.
					<delay>2</delay>
					Expect nastiness with low-level optimisations.

					<delay>2</delay>
				</li>
				<li>
					
					Always prefer lists. 

					<delay>2</delay>
					Arrays when 
Varargs for a method
					<delay>2</delay>
					( I guess you are forced to use Arrays here ).

					<delay>2</delay>
					When you want your collections to be covariant ( arrays of reference types are covariant ).

					<delay>2</delay>
					Performance critical code. 

					<delay>2</delay>
				</li>
				<li>
					
					Most people have answered it already.

					<delay>2</delay>
					There are almost no good reason to use an array instead of List.
					<delay>2</delay>
					The main exception being the primitive array (like int[]).
					<delay>2</delay>
					You cannot create a primitive list (must have List&lt;Integer&gt;).

					<delay>2</delay>
					The most important difference is that when using List you can decide what implementation will be used.
					<delay>2</delay>
					The most obvious is to chose LinkedList or ArrayList. 

					<delay>2</delay>
					I would like to point out in this answer that choosing the implementation gives you very fine grained control over the data that is simply not available to array:

					<delay>2</delay>
					You can prevent client from modifying your list by wrapping your list in a Collection.unmodifiableList

					<delay>2</delay>
					You can synchronize a list for multithreading using Collection.synchronizedList

					<delay>2</delay>
					You can create a fixed length queue with implementation of LinkedBlockingQueue
...
					<delay>2</delay>
					etc

					<delay>2</delay>
					In any case, even if you don't want (now) any extra feature of the list.
					<delay>2</delay>
					Just use an ArrayList and size it with the size of the array you would have created.
					<delay>2</delay>
					It will use an Array in the back-end and the performance difference with a real array will be negligible.
					<delay>2</delay>
					(except for primitive arrays) 

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ use ^ list ^ array ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Final arraylist declaration -->
			^ final arraylist declaration 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Final means that the variable pointing to the arraylist can't change.
					<delay>2</delay>
					But that does not mean that you can not call any method of the object, so you can perform insert, search and any other operation to the object

					<delay>2</delay>
				</li>
				<li>
					
					If you're talking about Java's ArrayList, then, yes you can.
					<delay>2</delay>
					Final means just that you can't change which ArrayList instance your variable refers to.

					<delay>2</delay>
				</li>
				<li>
					
					If a list is declared final as follows:
public final List myList = new ArrayList();<break/>
there's nothing to stop modifications to the list:

					<delay>2</delay>
					myList.add("value");<break/>

					<delay>2</delay>
					However, the following would not be possible:
myList = new ArrayList();<break/>myList = someOtherList;<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ final arraylist declaration </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- What is the best way to combine several arrays into one single array -->
			^ best way ^ combine several arrays ^ one single array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					
Create an array of the right size (by going through and summing the lengths of all the source arrays)

					<delay>2</delay>
					Repeatedly call System.arraycopy to copy one source array at a time into the target array, updating the place where you copy it to on each iteration.

					<delay>2</delay>
					So something like:
public static double[] Combine(double[][] arrays)<break/>{<break/>    int totalLength = 0;<break/>    for (double[] source : arrays)<break/>    {<break/>        totalLength += source.length;<break/>    }<break/>    double[] ret = new double[totalLength];<break/>    int index = 0;<break/>    for (double[] source : arrays)<break/>    {<break/>        System.arraycopy(source, 0, ret, index, source.length);<break/>        index += source.length;<break/>    }<break/>    return ret;<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can use this method from the Guava library, which is open-source and will have an actual binary release probably later this month:
Doubles.concat(double[]...)

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ best way ^ combine several arrays ^ one single array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- list of 2D array in java -->
			^ list ^ 2d array ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					e.g. or what do you mean
int[][] a2d = new int[15][15];<break/>int[][] b2d = new int[10][10];<break/>List&lt;int[][]&gt; list2d = new ArrayList&lt;int[][]&gt;(10);<break/>list2d.add(a2d);<break/>list2d.add(b2d);<break/>
or
					<delay>2</delay>
					do you mean you have a Set&lt;int[][]&gt;
					<delay>2</delay>
					then you can simply do what tpierzina suggested
List&lt;int[][]&gt; list2d = new ArrayList&lt;int[][]&gt;();<break/>list2d.addAll(nameOfYourSetVariable);<break/>
or
List&lt;int[][]&gt; list2d = new ArrayList&lt;int[][]&gt;(nameOfYourSetVariable);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					List&lt;String[][]&gt; myFunc( Set&lt;String[][]&gt; s ) {<break/>  List&lt;String[][]&gt; l = new ArrayList&lt;String[][]&gt;( s.length() );<break/>  l.addAll( s );<break/>  return l;<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Can't you just pass the set into a list like so:
    int [][]a = new int[3][3];<break/>    Set&lt;int[][]&gt; set = new HashSet&lt;int[][]&gt;();<break/>    set.add(a);<break/>    ArrayList&lt;int[][]&gt; list = new ArrayList&lt;int[][]&gt;(set);<break/>

					<delay>2</delay>
					Or am I not understanding your question.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ list ^ 2d array ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Multi-Dimension length array reflection java -->
			^ multi ^ dimension length array reflection java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Class clazz = Class.forName("ReflectionTest");    <break/>Method m = clazz.getDeclaredMethod("getArray");<break/>Object o1 = m.invoke(o, arg);<break/>int array[][] = (int[][])o1;<break/>System.out.println("Array length: " + array.length);<break/>System.out.println("Array length: " + array[0].length);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Use java.lang.reflect.Array.getLength(obj).

					<delay>2</delay>
				</li>
				<li>
					
					There is no such thing as "length" for multi-dimensional array; it may not be rectangular.
					<delay>2</delay>
					I'm guessing you're talking about the number of dimensions.
					<delay>2</delay>
					You need to descend into it iteratively and count.

					<delay>2</delay>
					public int getDimensionCount(Object array) {<break/>  int count = 0;<break/>  Class arrayClass = array.getClass();<break/>  while ( arrayClass.isArray() ) {<break/>    count++;<break/>    arrayClass = arrayClass.getComponentType();<break/>  }<break/>  return count;<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Java arrays have lengths per instance, not all arrays in the same dimension have to have equals lengths.
					<delay>2</delay>
					That said, you can get the lengths of instances in the.

					<delay>2</delay>
					Dimensions can be counted by the number of '[' in their name, this is quicker than descending the type hierarchy.
					<delay>2</delay>
					The following code:

					<delay>2</delay>
					        int[][][] ary = {{{0},{1}}};<break/>        Class cls = ary.getClass();<break/>        boolean isAry = cls.isArray();<break/>        String clsName = cls.getName();<break/>        System.out.println("is array=" + isAry);<break/>        System.out.println("name=" + clsName);<break/>        int nrDims = 1 + clsName.lastIndexOf('[');<break/>        System.out.println("nrDims=" + nrDims);<break/>        Object orly = ary;<break/>        for (int n = 0; n &lt; nrDims; n++) {<break/>            int len = Array.getLength(orly);<break/>            System.out.println("dim[" + n + "]=" + len);<break/>            if (0 &lt; len) {<break/>                orly = Array.get(orly, 0);<break/>            }<break/>        }<break/>
gives the following output:
is array=true<break/>name=[[[I<break/>nrDims=3<break/>dim[0]=1<break/>dim[1]=2<break/>dim[2]=1<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you like me were trying to get the number of dimensions and the size of them then:
private static int[] getDimentionsOf(final Object expectedArray) {<break/>    if (!expectedArray.getClass().isArray()) {<break/>        return new int[0];<break/>    }<break/>    final int dimensionSize = Array.getLength(expectedArray);<break/>    final int[] innerDimensions =<break/>                    (expectedArray.getClass().getComponentType().isArray())<break/>                                    ? getDimentionsOf(Array.get(expectedArray, 0))<break/>                                    : new int[0];<break/>    final int lenghtPlusOne = innerDimensions.length + 1;<break/>    final int[] newDimensions = new int[lenghtPlusOne];<break/>    System.arraycopy(innerDimensions, 0, newDimensions, 1, innerDimensions.length);<break/>    newDimensions[0] = dimensionSize;<break/>    return newDimensions;<break/>} <break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ multi ^ dimension length array reflection java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Array of Dates in Java -->
			^ array ^ dates ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					The same way you do for String  and Int , you just place different types inside: 
Date [] dates = {<break/>    new Date(), <break/>    new Date()<break/> };<break/>
Declared an array of size two with two dates.

					<delay>2</delay>
					You can also initialize with null values:

					<delay>2</delay>
					 Date [] dates = new Date[2];<break/>
Or add more significant values:
 Date [] dates = {<break/>    getDateFromString("25/11/2009"), <break/>    getDateFromString("24/12/2009")<break/> };<break/>.... <break/>public Date getDateFromString( String s ) {<break/>    Date result = ...// parse the string set the value etc. <break/>    return result;<break/>}<break/>
EDIT
  ...
					<delay>2</delay>
					but is there anyway you can finish up what you were doing in the getDateFromString method?

					<delay>2</delay>
					Sure, I didn't initially because my point was to show, that you could put anything that is of type "Date" there. 

					<delay>2</delay>
					You just have to use the SimpleDateFormate.parse() method ( inherited from DateFormat class ) 

					<delay>2</delay>
					  simpleDateFormatInstance.parse( "24/12/2009" ); // returns christmas 2009.<break/>
Here's a complete working sample: 
import java.text.SimpleDateFormat;<break/>import java.text.ParseException;<break/>import java.util.Date;<break/>import static java.lang.System.out;<break/>public class DateArrayTest {<break/>    private static final SimpleDateFormat dateFormat <break/>                   = new SimpleDateFormat("dd/MM/yyyy");<break/>    private static final Date invalidDate = new Date(0);<break/>    // test creating a date from a string.<break/>    public static void main( String [] args ) { <break/>        Date [] randomDates = {<break/>            fromString("01/01/2010"), // new year<break/>            fromString("16/09/2010"), // 200 yrs Mex indepence <break/>            fromString("21/03/2010"), // uhhmm next spring?<break/>            fromString("this/should/fail"), // invalid date.<break/>        };<break/>        for( Date date: randomDates ) {<break/>            print( date );<break/>        }<break/>    }<break/>    /**<break/>     * Creates a date from the given string spec. <break/>     * The date format must be dd/MM/yyyy ie. <break/>     * 24 december 2009 would be: 24/12/2009<break/>     * @return invalidDate if the format is invalid.<break/>     */<break/>    private static final Date fromString( String spec ) {<break/>        try {<break/>            return dateFormat.parse( spec );<break/>        } catch( ParseException dfe ) {<break/>            return invalidDate;<break/>        }<break/>    }<break/>    private static final void print( Date date ) {<break/>        if( date == invalidDate ) {<break/>            out.println("Invalid date");<break/>        } else {<break/>            out.println( dateFormat.format( date ) );<break/>        }<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					you can use an array of java.util.Date (API docs are here)
Date[] dates = new Date[] {<break/>    new Date(),<break/>    new Date(),<break/>};<break/>

					<delay>2</delay>
					You can create an array of any object type in java - all reference and primitive types

					<delay>2</delay>
				</li>
				<li>
					
					Or you could use the Collections API and Calendar class,
import java.util.*;<break/>List&lt;Calendar&gt; dates = new ArrayList&lt;Calendar&gt;(5); // initial size<break/>dates.add( Calendar.getInstance() );<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can consider (and this is not reality, but it sort of works this way)
					<delay>2</delay>
					that primitives are something like this (I do get to reality later on... so keep reading):
int.7, int.42 (won't compile)
					<delay>2</delay>
					where int is a class (it is not) and 7 and 42 are public static final variables (they are not).

					<delay>2</delay>
					and that Strings are something like this:
String.
					<delay>2</delay>
					"Hello", String.
					<delay>2</delay>
					"world
					<delay>2</delay>
					" (won't compile) where String is a class (it is) and "Hello" and "world" are public static final variables (they are not).

					<delay>2</delay>
					If my fake reality were true you would have to have something like:
// again, won't compile.<break/>public class int<break/>{<break/>    public static final int 7 = new int(7);<break/>    public static final int 42 = new int(42);<break/>    private final ??? data;<break/>    public int(??? val)<break/>    {<break/>        data = val;<break/>    }<break/>}<break/>
and 
// also will not compile<break/>public class String<break/>{<break/>    public final String "Hello" = new String("Hello);<break/>    public final String "world" = new String("world);<break/>    private final ??? data;<break/>    public String(final ??? val)<break/>    {<break/>        data = val;<break/>    }<break/>}<break/>

					<delay>2</delay>
					now you make a an array like (still won't compile):

					<delay>2</delay>
					int[] array = new int[] { int.7, int.42 };<break/>String[] array = new String[] {String."Hello", String."world" };<break/>

					<delay>2</delay>
					In the case of String my alternate reality would be very silly since it is impossible for the String class to know in advance every single possible String (for int it is possible).

					<delay>2</delay>
					So we would get rid of the public static final variables in String and do this instead:

					<delay>2</delay>
					String[] array = new String[] { new String("Hello"), new String("world") };<break/>
Now to reality:
When the java compiler, when it sees "Hello" or "world" it does something similar to "new String("Hello")"
					<delay>2</delay>
					- it is a bit smarter so that if you have "Hello" 20 times in a file that there is only one copy (and some other things too).

					<delay>2</delay>
					When you say:

					<delay>2</delay>
					new int[100]; you get an array of 100 ints all set to 0.<break/>new String[100]; you get an array of 100 Strings all pointing to null.<break/>new Data[100]; you get 100 Dates all pointing to null.<break/>

					<delay>2</delay>
					Since the String and the Date ones are pointing to null you need to allocate a new object for each one.  
					<delay>2</delay>
					The reason that you don't have to say "new" with String is that the compiler treats is specially.  
					<delay>2</delay>
					The reason you do not have to say "new" with int is that it is a primitive instead of an object.

					<delay>2</delay>
					So, the easy answer to your question is, you have to allocate a new Date for each element of the array :-)

					<delay>2</delay>
				</li>
				<li>
					
					Did you mean inputting an array of dates.
					<delay>2</delay>
					This code would help..
import java.text.ParseException;<break/>import java.text.SimpleDateFormat;<break/>import java.util.ArrayList;<break/>import java.util.Date;<break/>import java.util.Scanner;<break/>public class Datinput {<break/>    public static void main(String args[]) {<break/>        int n;<break/>        ArrayList&lt;String&gt; al = new ArrayList&lt;String&gt;();<break/>        Scanner in = new Scanner(System.in);<break/>        n = in.nextInt();<break/>        String da[] = new String[n];<break/>        SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");<break/>        sdf.setLenient(false);<break/>        Date date[] = new Date[n];<break/>        in.nextLine();<break/>        for (int i = 0; i &lt; da.length; i++) {<break/>            da[i] = in.nextLine();<break/>        }<break/>        for (int i = 0; i &lt; da.length; i++) {<break/>            try {<break/>                date[i] = sdf.parse(da[i]);<break/>            } catch (ParseException e) {<break/>                e.printStackTrace();<break/>            }<break/>        }<break/>        in.close();<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ array ^ dates ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- how will I find odd elements from two arrays -->
			^ find odd elements ^ two arrays 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Make a loop for each array item.
					<delay>2</delay>
					Those for which item &amp; 1 == 1 are odd.

					<delay>2</delay>
				</li>
				<li>
					
					    int[] longArray = { 1, 3, 2 };<break/>    int[] shortArray = { 1, 2 };<break/>    //Check which array is longer, if b longer than a then swap<break/>    boolean found = false;<break/>    int odd = 0;<break/>    for (int i : longArray) {<break/>        for (int j : shortArray) {<break/>            if (i == j)<break/>                found = true;<break/>        }<break/>        if (!found)<break/>            odd = i;<break/>        found = false;<break/>    }<break/>    System.out.println(odd);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you are talking about Set Comparisons, have a look at java-is-there-an-easy-quick-way-to-and-or-or-xor-together-sets

					<delay>2</delay>
					This SO question was talking in terms of the Set interface, but the List interface also inherits the relevant methods from Collection, so copying your arrays to ArrayList objects makes it easy.

					<delay>2</delay>
					If you want to keep it purely at the native array level, you might want to do something like:
 public int[] findOddElement(int[] fromArray, int[] secondArray){<break/>  int[] result = new int[fromArray.length];<break/>  int resPointer = 0;<break/>  for (int i = 0;i &lt; fromArray.length;i++){<break/>   boolean notFound = true;<break/>   for (int j = 0; j &lt; secondArray.length; j++) {<break/>    if (fromArray[i] == secondArray[j]) {<break/>     notFound = false;<break/>     break;<break/>    }<break/>   }<break/>   if (notFound){<break/>    result[resPointer] = fromArray[i];<break/>    resPointer++;<break/>   }<break/>  }<break/>  if (resPointer &gt; 0 &amp;&amp; resPointer &lt; fromArray.length ) {<break/>   int[] newResult = new int[resPointer];<break/>   for (int i = 0;i &lt; resPointer; i++) {<break/>    newResult[i] = result[i];<break/>   }<break/>   return newResult;<break/>  }<break/>  return result;<break/> }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					    int[] longArray = { 1, 3, 2 };<break/>    int[] shortArray = { 1, 2 };<break/>    //Check which array is longer, if b longer than a then swap<break/>    for (int x:longArray){<break/>        set.add(x);<break/>    }<break/>    for (int x:shortArray){<break/>        if (set.contains(x))<break/>           set.remove(x);<break/>    }<break/>    //odd numbers<break/>    for (Object i:set.toArray())<break/>        System.out.println(i+",");<break/>

					<delay>2</delay>
					I put two answers for the voting, the previous is nested loops and might be slow for very long arrays.
					<delay>2</delay>
					In the next solution some might dont prefer the TreeSet.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ find odd elements ^ two arrays </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- In Java, why are arrays objects? Are there any specific reasons? -->
			^ java ^ arrays objects ^ specific reasons 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					So that they get all the benefits thereof:
getHashCode()

					<delay>2</delay>
					toString()
etc.

					<delay>2</delay>
					And arrays aren't 'primitive', so if they can't be primitive, they must be objects.

					<delay>2</delay>
				</li>
				<li>
					
					I'm not sure about the official reason.

					<delay>2</delay>
					However, it makes sense to me that they are objects because operations can be performed on them (such as taking the length) and it made more sense to support these operations as member functions rather than introduce new keywords.
					<delay>2</delay>
					Other operations include clone(), the inherited operations of object, etc.
					<delay>2</delay>
					Arrays are also hashable and potentially comparable. 

					<delay>2</delay>
					This is different from C (and native arrays in C++), where your arrays are essentially pointers to a memory offset. 

					<delay>2</delay>
				</li>
				<li>
					
					Having arrays be objects means that you can do operations with them (e.g., someArray.count('foo'))
					<delay>2</delay>
					instead of just doing it against them (e.g., count(someArray, 'foo')), which leads to more natural syntax.

					<delay>2</delay>
				</li>
				<li>
					
					Another point is that objects are mutable and are passed by reference.
					<delay>2</delay>
					In arrays there aren't any fields/methods that you can use to change "properties" of the array, but you sure can mutate the element values.
					<delay>2</delay>
					And the benefits of passing arrays by reference are pretty obvious (though functional programmers probably wish Java had immutable lists passed by value). 

					<delay>2</delay>
					Edit: forgot to mention.
					<delay>2</delay>
					In the period before autoboxing, it was helpful to be able to store arrays in collections, write them to ObjectStreams etc.

					<delay>2</delay>
				</li>
				<li>
					
					Probably because they wanted to get as close as possible to making everything an object.
					<delay>2</delay>
					Native types are there for backward compatibility.

					<delay>2</delay>
				</li>
				<li>
					
					Because the Java Language Specification says so :) 
  
					<delay>2</delay>
					In the Java programming language arrays are objects (§4.3.1), are dynamically created, and may be assigned to variables of type Object (§4.3.2).
					<delay>2</delay>
					All methods of class Object may be invoked on an array.

					<delay>2</delay>
					So, unlike C++, Java provides true arrays as first-class objects: 

					<delay>2</delay>
					There is a length member. 

					<delay>2</delay>
					There is a clone() method which overrides the method of the same name in class Object.

					<delay>2</delay>
					Plus all the members of the class Object.

					<delay>2</delay>
					An exception is thrown if you attempt to access an array out of bounds.

					<delay>2</delay>
					Arrays are instanciated in dynamic memory.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java ^ arrays objects ^ specific reasons </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java Arrays - What are they -->
			^ java arrays 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Arrays are "special" in Java - they don't implement any interfaces, which means they can't implement the collection interfaces.
					<delay>2</delay>
					They're collections in "natural language" terms, and you can use the enhanced for loop over them - but if you want to use an array within the collection API, you'll need something like Arrays.asList which wraps an array with the List&lt;T&gt; interface.
					<delay>2</delay>
					(The result is only a view on the array - changes to the array are visible through the list, and vice versa.)

					<delay>2</delay>
					(This is in contrast to .NET, where T[] implements IList&lt;T&gt; etc.)

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java arrays </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- how to split the value in an array in java -->
			^ split ^ value ^ array ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					String [] splits = string.split("")<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Well, the String.getChars() function will give you a char[] array with one character per array element. 

					<delay>2</delay>
					So you should be able to do: 
char[] k = new char[myString.length()]<break/>myString.getChars(0,myString.length(),k,0);<break/>

					<delay>2</delay>
					If you need to convert to an array of integers, you can add
int[] i = new int[k.length]<break/>for(int j = 0; j &lt; k.length; j++) i[j] = k[j] - '0';<break/>

					<delay>2</delay>
					If you need to convert from an integer first, just use String myString = Integer.toString(myInt)

					<delay>2</delay>
				</li>
				<li>
					
					Keep dividing by 10 in a loop and take remainder : n % 10;

					<delay>2</delay>
				</li>
				<li>
					
					If it's a string, then you can just take the individual characters with getChars().

					<delay>2</delay>
					If it's a number then you just need to loop and use each digit individually.
					<delay>2</delay>
					To start from the end you can iteratively get the last digit by number % 10 and remove it with number / 10.
					<delay>2</delay>
					If you start with the first digits, then you can get the digit with number / 100, number / 10, etc.
					<delay>2</delay>
					and remove it with number % 100, number % 10, etc.

					<delay>2</delay>
					I'm sure you can convert that description into Java code.
					<delay>2</delay>
					I'm not convinced that simply posting a bunch of code here
					<delay>2</delay>
					actually helps you in the long term.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ split ^ value ^ array ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Convert Hash Map to 2D Array -->
			^ convert hash map ^ 2d array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					This can only be done when the types of both key and value are the same.

					<delay>2</delay>
					Given:   
HashMap&lt;String,String&gt; map;<break/>

					<delay>2</delay>
					I can create an array from this map with this simple loop:
String[][] array = new String[map.size()][2];<break/>int count = 0;<break/>for(Map.Entry&lt;String,String&gt; entry : map.entrySet()){<break/>    array[count][0] = entry.getKey();<break/>    array[count][1] = entry.getValue();<break/>    count++;<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Iterate over your Map using entrySet, and fill your array record with the Entry object

					<delay>2</delay>
				</li>
				<li>
					
					How about
Object[][] array = new Object[][]{map.keySet.toArray(), map.entrySet.toArray()};<break/>

					<delay>2</delay>
					Or, to be more specific about the types, let's say they're Strings:
					<delay>2</delay>
					Set's toArray takes a hint argument, so that
String[][] array = new String[][]{map.keySet.toArray(new String[0]), map.entrySet.toArray(new String[0])};<break/>
Edit: I just realized a couple of days later that while this may work by chance, in general it shouldn't.
					<delay>2</delay>
					The reason is the intermediate Set; although it is "backed by the map", there seems to be no explicit guarantee that it will iterate in any particular order.
					<delay>2</delay>
					Thus the key- and entry-arrays might not be in the same order, which is a disaster for sure!

					<delay>2</delay>
				</li>
				<li>
					
					HashMap map = new HashMap();<break/>Object[][] arr = new Object[map.size()][2];<break/>Set entries = map.entrySet();<break/>Iterator entriesIterator = entries.iterator();<break/>int i = 0;<break/>while(entriesIterator.hasNext()){<break/>    Map.Entry mapping = (Map.Entry) entriesIterator.next();<break/>    arr[i][0] = mapping.getKey();<break/>    arr[i][1] = mapping.getValue();<break/>    i++;<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ convert hash map ^ 2d array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- how to generate random number from array -->
			^ generate random number ^ array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					import java.util.Random;<break/>...<break/>Random random = new Random();<break/>System.out.println(n[random.nextInt(n.length)]);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					In general terms, get a random integer ranging from a minimum of 0 to a maximum of the array length -1, and use that as the array index.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ generate random number ^ array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java ArrayList Middle -->
			^ java arraylist middle 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					ArrayList.size()/2<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you have N items, the middle item is usually defined as item at index N/2 (0-based).

					<delay>2</delay>
					10 items<break/>0,1,2,3,4,5,6,7,8,9<break/>          |<break/>          5<break/>13 items<break/>0,1,2,3,4,5,6,7,8,9,0,1,2<break/>            |<break/>            6<break/>
Generally, if you need to find the middle of items between index low (inclusive) and high (exclusive), it's mathematically int mid = (low + high) / 2.
					<delay>2</delay>
					But due to arithmetic overflow in limited-precision integer, the proper formula is int mid = (low + high) &gt;&gt;&gt; 1;
See also
Google Research Blog post by Josh Bloch
Extra,
					<delay>2</delay>
					Extra - Read All About It: Nearly All Binary Searches and Mergesorts are Broken

					<delay>2</delay>
				</li>
				<li>
					
					If the size of ArrayList is even in number, then use
     (ArrayList.size()/2)+1 or    (ArrayList.size()/2) as the middle.

					<delay>2</delay>
					If the size of ArrayList is odd in number, then use     (ArrayList.size()+1)/2 as the middle.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java arraylist middle </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to put a Scanner input into an array... for example a couple of numbers -->
			^ put ^ scanner input ^ example ^ couple ^ numbers 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					double [] avg = new double[5];<break/>for(int i=0; i&lt;5; i++)<break/>   avg[i] = scan.nextDouble();<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can get all the doubles with this code:
List&lt;Double&gt; numbers = new ArrayList&lt;Double&gt;();<break/>while (scan.hasNextDouble()) {<break/>    numbers.add(scan.nextDouble());<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You could try something like this:
public static void main (String[] args)<break/>{<break/>    Scanner input = new Scanner(System.in);<break/>    double[] numbers = new double[5];<break/>    for (int i = 0; i &lt; numbers.length; i++)<break/>    {<break/>        System.out.println("Please enter number");<break/>        numbers[i] = input.nextDouble();<break/>    }<break/>}<break/>

					<delay>2</delay>
					It seems pretty basic stuff unless I am misunderstanding you

					<delay>2</delay>
				</li>
				<li>
					
					Scanner scan = new Scanner (System.in);<break/>for (int i=0; i&lt;=4, i++){<break/>    System.out.printf("Enter value at index"+i+" :");<break/>    anArray[i]=scan.nextInt();<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					import java.util.Scanner;<break/>public class Main {<break/>    /**<break/>     * @param args<break/>     */<break/>    public static void main(String[] args) {<break/>        Scanner in=new Scanner (System.in);<break/>        int num[]=new int[10];<break/>        int average=0;<break/>        int i=0;<break/>        int sum=0;<break/>        for (i=0;i&lt;num.length;i++) {<break/>            System.out.println("enter a number");<break/>            num[i]=in.nextInt();<break/>            sum=sum+num[i];<break/>        }<break/>        average=sum/10;<break/>        System.out.println("Average="+average);<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					import  java.util.Scanner;<break/>class Array {<break/>public static void main(String a[]){<break/>    Scanner input = new Scanner(System.in);<break/>    System.out.println("Enter the size of an Array");<break/>    int num = input.nextInt();<break/>    System.out.println("Enter the Element "+num+" of an Array");<break/>    double[] numbers = new double[num];<break/>    for (int i = 0; i &lt; numbers.length; i++)<break/>    {<break/>        System.out.println("Please enter number");<break/>        numbers[i] = input.nextDouble();<break/>    }<break/>    for (int i = 0; i &lt; numbers.length; i++)<break/>    {<break/>        if ( (i%3) !=0){<break/>            System.out.print("");<break/>            System.out.print(numbers[i]+"\t");<break/>        } else {<break/>            System.out.println("");<break/>            System.out.print(numbers[i]+"\t");<break/>        }<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					import java.util.Scanner;<break/>public class sort {<break/>  public static void main(String args[])<break/>    {<break/>        int i,n,t;          <break/>        Scanner sc=new Scanner(System.in);<break/>        System.out.print("Enter the size of array");<break/>        n=sc.nextInt();<break/>        int a[] = new int[n];<break/>        System.out.println("Enter elements in array");<break/>        for(i=0;i&lt;n;i++)<break/>        {<break/>            a[i]=sc.nextInt();<break/>        }<break/>        t=a[1];<break/>        for(i=0;i&lt;n;i++)<break/>        {<break/>            if(a[i]&gt;t)<break/>                t=a[i];<break/>        }<break/>        System.out.println("Greates integer is" +t);<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					This is a program to show how to give input from system and also calculate sum at each level and average.

					<delay>2</delay>
					package NumericTest;<break/>import java.util.Scanner;<break/>public class SumAvg {<break/> public static void main(String[] args) {<break/> int i,n;<break/> System.out.println("Enter the number of inputs");<break/> Scanner sc = new Scanner(System.in);<break/> n=sc.nextInt();<break/> int a[] = new int [n];<break/>    System.out.println("Enter the inputs");<break/>   for(i=0;i&lt;n;i++){<break/>   a[i] = sc.nextInt();<break/>  System.out.println("Inputs are " +a[i]);<break/> }<break/>  int sum = 0;<break/>  for(i=0;i&lt;n;i++){<break/> sum = sum +a[i];<break/>  System.out.println("Sums : " +sum);<break/> }<break/>  int avg ;<break/>  avg = sum/n;<break/>  System.out.println("avg : " +avg);<break/>  }<break/> }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					**Simple solution**<break/>public static void main(String[] args) {<break/>    Scanner sc = new Scanner(System.in);<break/>    int size;<break/>    System.out.println("Enter the number of size of array");<break/>    size = sc.nextInt();<break/>    int[] a = new int[size];<break/>    System.out.println("Enter the array element");<break/>    //For reading the element<break/>    for(int i=0;i&lt;size;i++) {<break/>        a[i] = sc.nextInt();<break/>    }<break/>    //For print the array element<break/>    for(int i : a) {<break/>        System.out.print(i+" ,");<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					List&lt;Double&gt; numbers = new ArrayList&lt;Double&gt;();<break/>double sum = 0;<break/>Scanner scan = new Scanner(System.in);<break/>while(scan.hasNext()){<break/>    double value = scan.nextDouble();<break/>    numbers.add(value);<break/>    sum += value;<break/>}<break/>double average = sum / numbers.size();<break/>

					<delay>2</delay>
				</li>
				<li>
					
					public static void main (String[] args)<break/>{<break/>    Scanner s = new Scanner(System.in);<break/>    System.out.println("Please enter size of an array");<break/>    int n=s.nextInt();<break/>    double arr[] = new double[n];<break/>    System.out.println("Please enter elements of array:");<break/>    for (int i=0; i&lt;n; i++)<break/>    {<break/>        arr[i] = s.nextDouble();<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ put ^ scanner input ^ example ^ couple ^ numbers </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- how to get HashTable values as Arraylist? -->
			^ get hashtable values ^ arraylist 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Use the ArrayList constructor that takes a collection.

					<delay>2</delay>
					ArrayList&lt;Word&gt; arr = new ArrayList&lt;Word&gt;(hw.values());<break/>

					<delay>2</delay>
					Then every value that was in the HashTable will be in the new ArrayList.

					<delay>2</delay>
					You can find documentation about the constructor in the javadocs.

					<delay>2</delay>
				</li>
				<li>
					
					ArrayList&lt;Word&gt; arr = new ArrayList&lt;Word&gt;( hw.values() );<break/>

					<delay>2</delay>
				</li>
				<li>
					
					use
hw.values();<break/>

					<delay>2</delay>
					it will simply return the Collection (like a List) of Word objects. 
from javadocs
values
public Collection values() 
  Returns a Collection view of the
  values contained in this map.
					<delay>2</delay>
					The
  collection is backed by the map, so
  changes to the map are reflected in
  the collection, and vice-versa.
					<delay>2</delay>
					If the
  map is modified while an iteration
  over the collection is in progress
  (except through the iterator's own
  remove operation), the results of the
  iteration are undefined.
					<delay>2</delay>
					The
  collection supports element removal,
  which removes the corresponding
  mapping from the map, via the
  Iterator.remove, Collection.remove,
  removeAll, retainAll and clear
  operations.
					<delay>2</delay>
					It does not support the
  add or addAll operations.

					<delay>2</delay>
				</li>
				<li>
					
					Also you can use
ArrayList&lt;Word&gt; arr = Collections.list(hw.keys());<break/>
for keys as ArrayList

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ get hashtable values ^ arraylist </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Free memory of a byte array in Java -->
			^ free memory ^ byte array ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Stop referencing it.

					<delay>2</delay>
				</li>
				<li>
					
					Removing all the reference to that array of bytes.
					<delay>2</delay>
					The garbage collector will take care of the rest.

					<delay>2</delay>
				</li>
				<li>
					
					When creating a new byte[] in Java, you do something like
byte[] myArray = new byte[54];<break/>

					<delay>2</delay>
					To free it, you should do
myArray = null;<break/>

					<delay>2</delay>
					If something else references your byte array, like
yourArray = myArray;<break/>
you need to also set the other references to null, like so
yourArray = null;<break/>
In Java garbage collection is automatic.  
					<delay>2</delay>
					If the JVM can detect that a piece of memory is no longer reachable by the entire program, then the JVM will free the memory for you.

					<delay>2</delay>
				</li>
				<li>
					
					Setting all references to it to null will make it a candidate for Java's automatic garbage collection.
					<delay>2</delay>
					You can't be sure how long it will take for this to happen though.
					<delay>2</delay>
					If you really need to explicitly reclaim the memory immediately you can make a call to System.gc();
Also just to clear you may not need to set the references to null explicitly.
					<delay>2</delay>
					If the references go out of scope they are automatically nulled e.g. a local variable reference will be nulled once the method it is declared in finishes executing.
					<delay>2</delay>
					So local variables are usually released implicitly all the time during an apps runtime.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ free memory ^ byte array ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Do Java arrays have a maximum size? -->
			^ java arrays ^ maximum size 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					There are actually two limits.  
					<delay>2</delay>
					One, the maximum element indexable for the array and, two, the amount of memory available to your application.  
					<delay>2</delay>
					Depending on the amount of memory available and
					<delay>2</delay>
					the amount used by other data structures, you may hit the memory limit before you reach the maximum addressable array element.

					<delay>2</delay>
				</li>
				<li>
					
					Haven't seen the right answer, even though it's very easy to test.

					<delay>2</delay>
					In a recent HotSpot VM, the correct answer is Integer.MAX_VALUE - 5.  
					<delay>2</delay>
					Once you go beyond that:

					<delay>2</delay>
					public class Foo {<break/>  public static void main(String[] args) {<break/>    Object[] array = new Object[Integer.MAX_VALUE - 4];<break/>  }<break/>}<break/>

					<delay>2</delay>
					You get:
Exception in thread "main" java.lang.OutOfMemoryError:<break/>  Requested array size exceeds VM limit<break/>

					<delay>2</delay>
				</li>
				<li>
					
					This is (of course) totally VM-dependent.

					<delay>2</delay>
					Browsing through the source code of OpenJDK 7 and 8 java.util.ArrayList, .Hashtable, .AbstractCollection,  .PriorityQueue, and .Vector, you can see this claim being repeated:
/**<break/> * Some VMs reserve some header words in an array.<break/> * Attempts to allocate larger arrays may result in<break/> * OutOfMemoryError: Requested array size exceeds VM limit<break/> */<break/>private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;<break/>
which is added by Martin Buchholz (Google) on 2010-05-09; reviewed by Chris Hegarty (Oracle).

					<delay>2</delay>
					So,  probably  we can say that the maximum "safe" number would be  2 147 483 639 (Integer.MAX_VALUE - 8) and "attempts to allocate larger arrays may result in OutOfMemoryError".

					<delay>2</delay>
					(Yes, Buchholz's standalone claim does not include backing evidence, so this is a calculated appeal to authority.
					<delay>2</delay>
					Even within OpenJDK itself, we can see code like return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; which shows that MAX_ARRAY_SIZE does not yet have a real use.)

					<delay>2</delay>
				</li>
				<li>
					
					Maximum number of elements of an array is (2^31)−1 or 2 147 483 647 

					<delay>2</delay>
				</li>
				<li>
					
					Going by this article http://en.wikipedia.org/wiki/Criticism_of_Java#Large_arrays:
  Java has been criticized for not supporting arrays of more than 231−1 (about 2.1 billion) elements.
					<delay>2</delay>
					This is a limitation of the language; the Java Language Specification, Section 10.4, states that:
  
  
    Arrays must be indexed by int values...
					<delay>2</delay>
					An attempt to access an array
    component with a long index value results in a compile-time error.
  

					<delay>2</delay>
					Supporting large arrays would also require changes to the JVM.
					<delay>2</delay>
					This limitation manifests itself in areas such as collections being limited to 2 billion elements and the inability to memory map files
					<delay>2</delay>
					larger than 2 GiB. Java also lacks true multidimensional arrays (contiguously allocated single blocks of memory accessed by a single indirection), which limits performance for scientific and technical computing.

					<delay>2</delay>
				</li>
				<li>
					
					Arrays are non-negative integer indexed , so maximum array size you can access would be Integer.MAX_VALUE.
					<delay>2</delay>
					The other thing is how big array you can create.
					<delay>2</delay>
					It depends on the maximum memory available to your JVM and the content type of the array.
					<delay>2</delay>
					Each array element has it's size, example.
					<delay>2</delay>
					byte = 1 byte, int = 4 bytes, Object reference = 4 bytes (on a 32 bit system) 

					<delay>2</delay>
					So if you have 1 MB memory available on your machine, you could allocate an array of byte[1024 * 1024] or Object[256 * 1024]. 

					<delay>2</delay>
					Answering your question - You can allocate an array of size (maximum available memory / size of array item).   

					<delay>2</delay>
					Summary -
					<delay>2</delay>
					Theoretically the maximum size of an array will be Integer.MAX_VALUE.
					<delay>2</delay>
					Practically it depends on how much memory your Integer.MAX_VALUE0 has and how much of that has already been allocated to other objects.

					<delay>2</delay>
				</li>
				<li>
					
					I tried to create a byte array like this
byte[] bytes = new byte[Integer.MAX_VALUE-x];<break/>System.out.println(bytes.length);<break/>
With this run configuration:

					<delay>2</delay>
					-Xms4G -Xmx4G<break/>
And java version:
  Openjdk version "1.8.0_141" 
  
  OpenJDK Runtime Environment (build 1.8.0_141-b16) 
  
  OpenJDK 64-Bit Server VM (build 25.141-b16, mixed mode)

					<delay>2</delay>
					It only works for x >= 2 which means the maximum size of an array is Integer.
					<delay>2</delay>
					MAX_VALUE-2
Values above that give
  Exception in thread "main" java.lang.OutOfMemoryError:
					<delay>2</delay>
					Requested array size exceeds VM limit
      at Main.main(Main.java:6)

					<delay>2</delay>
				</li>
				<li>
					
					Actually it's java limitation caping it at 2^30-4 being 1073741820.
					<delay>2</delay>
					Not 2^31-1.
					<delay>2</delay>
					Dunno
					<delay>2</delay>
					why
					<delay>2</delay>
					but i tested it manually on jdk.
					<delay>2</delay>
					^30-3 still throwing vm except
Edit: fixed -1 to -4, checked on windows jvm

					<delay>2</delay>
				</li>
				<li>
					
					Yes, there limit on java array.
					<delay>2</delay>
					Java uses an integer as an index to the array and the maximum integer store by JVM is 2^32.
					<delay>2</delay>
					so you can store 2,147,483,647 elements in the array. 

					<delay>2</delay>
					In case you need more than max-length you can use two different arrays but the recommended method is store data into a file.
					<delay>2</delay>
					because storing data in the file has no limit.
					<delay>2</delay>
					because files stored in your storage drivers but array are stored in JVM.
					<delay>2</delay>
					JVM provides limited space for program execution. 

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java arrays ^ maximum size </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Send an Array with an HTTP Get -->
			^ send ^ array ^ http get 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					That depends on what the target server accepts.
					<delay>2</delay>
					There is no definitive standard for this.
					<delay>2</delay>
					See also a.o.
					<delay>2</delay>
					Wikipedia:
					<delay>2</delay>
					Query string:
  
					<delay>2</delay>
					While there is no definitive standard, most web frameworks allow multiple values to be associated with a single field (e.g. field1=value1&amp;field1=value2&amp;field2=value3).[4][5]

					<delay>2</delay>
					Generally, when the target server uses a strong typed programming language like Java (Servlet), then you can just send them as multiple parameters with the same name.
					<delay>2</delay>
					The API usually offers a dedicated method to obtain multiple parameter values as an array.

					<delay>2</delay>
					foo=value1&amp;foo=value2&amp;foo=value3<break/>
String[] foo = request.getParameterValues("foo"); // [value1, value2, value3]<break/>
The request.getParameter("foo") will also work on it, but it'll return only the first value.

					<delay>2</delay>
					String foo = request.getParameter("foo"); // value1<break/>

					<delay>2</delay>
					And, when the target server uses a weak typed language like PHP or RoR, then you need to suffix the parameter name with braces [] in order to trigger the language to return an array of values instead of a single value.

					<delay>2</delay>
					foo[]=value1&amp;foo[]=value2&amp;foo[]=value3<break/>
$foo = $_GET["foo"]; // [value1, value2, value3]<break/>echo is_array($foo); // true<break/>

					<delay>2</delay>
					In case you still use foo=value1&amp;foo=value2&amp;foo=value3, then it'll return only the first value.

					<delay>2</delay>
					field1=value1&amp;field1=value2&amp;field2=value30
Do note that when you send field1=value1&amp;field1=value2&amp;field2=value31 to a Java Servlet, then you can still obtain them, but you'd need to use the exact parameter name including the braces.

					<delay>2</delay>
					field1=value1&amp;field1=value2&amp;field2=value32

					<delay>2</delay>
				</li>
				<li>
					
					I know this post is really old, but I have to reply because although BalusC's answer is marked as correct, it's not completely correct.

					<delay>2</delay>
					You have to write the query adding "[]" to foo like this:
foo[]=val1&amp;foo[]=val2&amp;foo[]=val3<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ send ^ array ^ http get </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- java array sorting -->
			^ java array sorting 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Use Arrays.sort().
					<delay>2</delay>
					See the API documentation of class java.util.Arrays.

					<delay>2</delay>
					Example:

					<delay>2</delay>
					import java.util.Arrays;<break/>// ...<break/>String[] arr = new String[] { "one", "two", "three" };<break/>Arrays.sort(arr);<break/>
edit -
					<delay>2</delay>
					Ok, you've edited your question and added "without using Arrays.sort()".
					<delay>2</delay>
					Is this homework?
					<delay>2</delay>
					Are you supposed to implement your own sorting algorithm?
					<delay>2</delay>
					Then just do some research on sorting algorithms and implement one yourself.

					<delay>2</delay>
				</li>
				<li>
					
					To add a little bit more to their answers above - as you mentioned "sorting logically", you can implement your own Comparator and use Arrays.sort(array, comparator).

					<delay>2</delay>
					Is there a specific reason you want to avoid Arrays.sort()?

					<delay>2</delay>
				</li>
				<li>
					
					Here is a nice selection including code examples for the various ways to sort arrays and/or collections: Rosetta Code

					<delay>2</delay>
				</li>
				<li>
					
					I have covered sorting algorithms in Java which includes the bubble sort, quick sort and merge sort with comprehensive code and explanations.
					<delay>2</delay>
					You may find the code here.

					<delay>2</delay>
				</li>
				<li>
					
					Write a quicksort or mergesort algorithm.
					<delay>2</delay>
					Smells homework, too.

					<delay>2</delay>
				</li>
				<li>
					
					Have a look at Insertion Sort.

					<delay>2</delay>
				</li>
				<li>
					
					You can write bubble sort or quick sort or any sorting algorithm yourself

					<delay>2</delay>
				</li>
				<li>
					
					I write my own sorting algorithms in my personal projects without looking at any formal sorting algorithms.
					<delay>2</delay>
					It keeps my programming edges sharpend, plus it's interesting to see what you can come up with on your own, compared to the more formal sorting algorithms.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java array sorting </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Finding an element in an array in Java -->
			^ finding ^ element ^ array ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Use a for loop.  
					<delay>2</delay>
					There's nothing built into array.  
					<delay>2</delay>
					Or switch to a java.util Collection class.

					<delay>2</delay>
				</li>
				<li>
					
					You might want to consider using a Collection implementation instead of a flat array.

					<delay>2</delay>
					The Collection interface defines a contains(Object o) method, which returns true/false.

					<delay>2</delay>
					ArrayList implementation defines an indexOf(Object o), which gives an index, but that method is not on all collection implementations.

					<delay>2</delay>
					Both these methods require proper implementations of the equals() method, and you probably want a properly implemented hashCode() method just in case you are using a hash based Collection0 (e.g. Collection1).

					<delay>2</delay>
				</li>
				<li>
					
					You can use one of the many Arrays.binarySearch() methods.  
					<delay>2</delay>
					Keep in mind that the array must be sorted first.

					<delay>2</delay>
				</li>
				<li>
					
					There is a contains method for lists, so you should be able to do:

					<delay>2</delay>
					Arrays.asList(yourArray).contains(yourObject);<break/>
Warning:
					<delay>2</delay>
					this might not do what you (or I) expect, see Tom's comment below. 

					<delay>2</delay>
				</li>
				<li>
					
					With Java 8, you can do this:
int[] haystack = {1, 2, 3};<break/>int needle = 3;<break/>boolean found = Arrays.stream(haystack).anyMatch(x -&gt; x == needle);<break/>

					<delay>2</delay>
					You'd need to do 
boolean found = Arrays.stream(haystack).anyMatch(x -&gt; needle.equals(x));<break/>
if you're working with objects.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ finding ^ element ^ array ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- divide array into smaller parts -->
			^ divide array ^ smaller parts 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You can use the method Arrays.copyOfRange(original, from, to)
 public static byte[][] divideArray(byte[] source, int chunksize) {<break/>        byte[][] ret = new byte[(int)Math.ceil(source.length / (double)chunksize)][chunksize];<break/>        int start = 0;<break/>        for(int i = 0; i &lt; ret.length; i++) {<break/>            ret[i] = Arrays.copyOfRange(source,start, start + chunksize);<break/>            start += chunksize ;<break/>        }<break/>        return ret;<break/>    }<break/>

					<delay>2</delay>
					Or You can use as Max suggested the System.arraycopy
public static byte[][] divideArray(byte[] source, int chunksize) {<break/>        byte[][] ret = new byte[(int)Math.ceil(source.length / (double)chunksize)][chunksize];<break/>        int start = 0;<break/>        for(int i = 0; i &lt; ret.length; i++) {<break/>            if(start + chunksize &gt; source.length) {<break/>                System.arraycopy(source, start, ret[i], 0, source.length - start);<break/>            } else {<break/>                System.arraycopy(source, start, ret[i], 0, chunksize);<break/>            }<break/>            start += chunksize ;<break/>        }<break/>        return ret;<break/>    }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					See Arrays.copyOfRange for help.
					<delay>2</delay>
					You could use this in a loop to split your array into several smaller chunks.

					<delay>2</delay>
				</li>
				<li>
					
					Well, System.arraycopy(src, fromPos, dest, toPos, length) is generally considered faster than Arrays.copyOfRange.

					<delay>2</delay>
					byte[] source = ...read it from somewhere...;<break/>byte[] newArray = new byte[64];<break/>System.arraycopy(source, 0, newArray, 0, 64);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You have two choices:
System.arraycopy(...)
Array.copyOfRange(...)
both of them work the same way
					<delay>2</delay>
					but while first one only manages copy, second one is meant to be used to allocate the new chunk at the same time.

					<delay>2</delay>
					I benchmarked them with a result that System.arraycopy is faster if you manage to allocate chunks all together before splitting your array but slightly slower if you allocate them whle you copy: in this case you should use Array.copyOfRange.

					<delay>2</delay>
				</li>
				<li>
					
					This will do...
    byte[] source = new byte[2048];<break/>    byte[] target = new byte[1024];  <break/>// fill source with some data...<break/>    Array.Copy(source, buffer, 1024);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Damian Vash's first method (the one using Arrays.copyOfRange()) adds zeros to the end of the last chunk if the input is not exactly a multiple of chunksize.

					<delay>2</delay>
					You might want to use this instead:

					<delay>2</delay>
					public static List&lt;byte[]&gt; divideArray(byte[] source, int chunksize) {<break/>    List&lt;byte[]&gt; result = new ArrayList&lt;byte[]&gt;();<break/>    int start = 0;<break/>    while (start &lt; source.length) {<break/>        int end = Math.min(source.length, start + chunksize);<break/>        result.add(Arrays.copyOfRange(source, start, end));<break/>        start += chunksize;<break/>    }<break/>    return result;<break/>}<break/>
and in case it's useful, the same thing using ArrayList's:
  public static List&lt;List&lt;String&gt;&gt; divideList(List&lt;String&gt; source, int chunksize) {<break/>    List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;List&lt;String&gt;&gt;();<break/>    int start = 0;<break/>    while (start &lt; source.size()) {<break/>      int end = Math.min(source.size(), start + chunksize);<break/>      result.add(source.subList(start, end));<break/>      start += chunksize;<break/>    }<break/>    return result;<break/>  }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you are looking save some memory, a slight modification to Damian Vash's answer would help (in this case any remaining chunk is not allocated a complete 64 byte block size, as well...)
private byte[][] splitChunks(byte[] source)<break/>{<break/>    byte[][] ret = new byte[(int)Math.ceil(source.length / (double)CHUNK_SIZE)][];<break/>    int start = 0;<break/>    for(int i = 0; i &lt; ret.length; i++) {<break/>        if(start + CHUNK_SIZE &gt; source.length) {<break/>            ret[i] = new byte[source.length-start];<break/>            System.arraycopy(source, start, ret[i], 0, source.length - start);<break/>        } <break/>        else {<break/>            ret[i] = new byte[CHUNK_SIZE];<break/>            System.arraycopy(source, start, ret[i], 0, CHUNK_SIZE);<break/>        }<break/>        start += CHUNK_SIZE ;<break/>    }<break/>    return ret;<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ divide array ^ smaller parts </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- java vector to arraylist -->
			^ java vector ^ arraylist 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Yup - just use the constructor which takes a collection as its parameter:

					<delay>2</delay>
					Vector&lt;String&gt; vector = new Vector&lt;String&gt;();<break/>// (... Populate vector here...)<break/>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(vector);<break/>
Note that it only does a shallow copy.

					<delay>2</delay>
				</li>
				<li>
					
					I just wrote a class to do the same thing, but is more flexible as it will accept Objects accordingly. 

					<delay>2</delay>
					public class ExteriorCastor {<break/>    public static  ArrayList vectorToArrayList(Vector vector){<break/>        if (vector == null){return null;}<break/>        return new ArrayList&lt;Object&gt;(vector);<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					i´m not sure if it is length() or size()....
					<delay>2</delay>
					but the idea is the next:
ArrayList&lt;Object&gt; a;<break/>for(int i = 0;i &lt; Vector.length() ; i++)<break/>    a.add(Vector.elementAt(i); // Again... i´m not sure if this is elementAt() or get()<break/>Vector.finalize();<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java vector ^ arraylist </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How does ArrayList work? -->
			^ arraylist work 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Internally an ArrayList uses an Object[].

					<delay>2</delay>
					As you add items to an ArrayList, the list checks to see if the backing array has room left.  
					<delay>2</delay>
					If there is room, the new item is just added at the next empty space.  
					<delay>2</delay>
					If there is not room, a new, larger, array is created, and the old array is copied into the new one.

					<delay>2</delay>
					Now, there is more room left, and the new element is added in the next empty space.

					<delay>2</delay>
					Since people really like the source code:
/**<break/> * The array buffer into which the elements of the ArrayList are stored.<break/> * The capacity of the ArrayList is the length of this array buffer.<break/> */<break/>private transient Object[] elementData;<break/>
Straight out of the JDK.

					<delay>2</delay>
				</li>
				<li>
					
					It uses an Object[], and makes a bigger array when the array gets full.

					<delay>2</delay>
					You can read the source code here.

					<delay>2</delay>
				</li>
				<li>
					
					It uses an array, and a couple of integers to indicate the first value - last value index
private transient int firstIndex;<break/>private transient int lastIndex;<break/>private transient E[] array;<break/>

					<delay>2</delay>
					Here's an example implementation.

					<delay>2</delay>
				</li>
				<li>
					
					Typically, structures like ArrayLists are implemented by a good old fashioned array defined within the class and not directly accessible outside the class. 

					<delay>2</delay>
					A certain amount of space is initially allocated for the list, and when you add an element that exceeds the size of the array, the array will be reinitialized with a new capacity (which is typically some multiple of the current size, so the framework isn't constantly re-allocating arrays with each new entry added).

					<delay>2</delay>
				</li>
				<li>
					
					The Java platform source code is freely available.
					<delay>2</delay>
					Here's an extract:
public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;<break/>  implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable<break/>{<break/>  /**<break/>   * The array buffer into which the elements of the ArrayList are stored.<break/>   * The capacity of the ArrayList is the length of this array buffer.<break/>   */<break/>  private transient E[] elementData;<break/>  .<break/>  .<break/>  .<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					ArrayLists use arrays to hold the data.
					<delay>2</delay>
					Once the number of elements exceeds the allocated array it copies the data to another array, probably double the size.

					<delay>2</delay>
					A (minor) performance hit is taken when copying the array, it's therefore possible to set the size of the internal array in the constructor of the array list.

					<delay>2</delay>
					Furthermore it implements java.util.Collection and and java.util.list, and it's is therefore possible to get the element at a specified index, and iterable (just like an array).

					<delay>2</delay>
				</li>
				<li>
					
					ArrayList uses an Array of Object to store the data internally.

					<delay>2</delay>
					When you initialize an ArrayList, an array of size 10 (default capacity) is created and an element added to the ArrayList is actually added to this array.
					<delay>2</delay>
					10 is the default size and it can be passed as a parameter while initializing the ArrayList.

					<delay>2</delay>
					When adding a new element, if the array is full, then a new array of 50% more the initial size is created and the last array is copied to this new array so that now there are empty spaces for the new element to be added.

					<delay>2</delay>
					Since the underlying data-structure used is an array, it is fairly easy to add a new element to the ArrayList as it is added to the end of the list.
					<delay>2</delay>
					When an element is to be added anywhere else, say the beginning, then all the elements shall have to move one position to the right to create an empty space at the beginning for the new element to be added.
					<delay>2</delay>
					This process is time-consuming (linear-time).
					<delay>2</delay>
					But the Advantage of ArrayList is that retrieving an element at any position is very fast (constant-time), as underlying it is simply using an array of objects.

					<delay>2</delay>
				</li>
				<li>
					
					ArrayList has the basic data structure:

					<delay>2</delay>
					private transient Object[] elementData;<break/>

					<delay>2</delay>
					When we actually create an ArrayList the following piece of code is executed:
 this.elementData = new Object[initial capacity];<break/>
ArrayList can be created in the two ways mentioned below:

					<delay>2</delay>
					List list = new ArrayList();

					<delay>2</delay>
					The default constructor is invoked and will internally create an array of Object with default size 10.

					<delay>2</delay>
					List list = new ArrayList(5);

					<delay>2</delay>
					When we create an ArrayList in this way, constructor with an integer argument is invoked and 
create an array of ArrayList0 with default size 5.

					<delay>2</delay>
					Inside the ArrayList1 method there is check whether the current size of filled elements is greater/equal to the maximum size of the
ArrayList2
					<delay>2</delay>
					then it will create new ArrayList3 with the size new ArrayList4 and copy the data from old to
new array list.

					<delay>2</delay>
				</li>
				<li>
					
					It uses an Object[].
					<delay>2</delay>
					When the array is full it creates a new array which is 50% bigger in size and copies current elements to new array.
					<delay>2</delay>
					It happens automatically. 

					<delay>2</delay>
				</li>
				<li>
					
					as i understand is that 
  ArrayList class implements List interface and 
  (as interface only extends other interface)
  List interface extends Collection interface.
  while talking about arraylist when we initialize in memory it reserve by default space 10 > and create array of Integer which you normally use.
					<delay>2</delay>
					when this this array is full then the another array of interger is created which is greater then default size. 

					<delay>2</delay>
					List&lt;Integer&gt; list = new ArrayList&lt;&gt;();<break/>
  now in memory as =
					<delay>2</delay>
					Integer[] list = new Integer[10]
					<delay>2</delay>
					;
  
  now suppose that you enter 1,2,3,4,5,6,7,8,9,10 array is full now and what happen when you enter 11 in the memory
					<delay>2</delay>
					another array of Integer is created which is greater then by default and all element in old array is copied in new array.
					<delay>2</delay>
					Internally arraylist user Object[] array.

					<delay>2</delay>
					thats how arrayList work

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ arraylist work </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Does initialized java array go onto stack or heap? -->
			^ initialized java array go onto stack ^ heap 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You can think of it as always going on the heap.

					<delay>2</delay>
					I believe some smart VMs are able to stack-allocate objects if they can detect it's safe - but conceptually it's on the heap.
					<delay>2</delay>
					In particular, all array types are reference types (even if the element type is primitive), so the array variable (which is on the stack) is just a reference to an object, and objects normally go on the heap.

					<delay>2</delay>
					In particular, imagine a small change:
byte[] someMethod() { <break/>    byte[] array = { 0, 0 };<break/>    return array;<break/>}<break/>

					<delay>2</delay>
					If the array were allocated on the stack, what would the returned reference have to refer to?

					<delay>2</delay>
				</li>
				<li>
					
					It will be stored in the heap

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ initialized java array go onto stack ^ heap </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Best way to create singleton array -->
			^ best way ^ create singleton array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					The standard way is this:
String[] arr = new String[]{"I am the one and only"};<break/>

					<delay>2</delay>
					I'm afraid it doesn't get much simpler than this.

					<delay>2</delay>
					Edit: it does:

					<delay>2</delay>
					String[] arr = {"I am the one and only"};<break/>

					<delay>2</delay>
					Thanks aioobe, I keep forgetting this.

					<delay>2</delay>
					Of course if you often create array you can create a helper method that makes things a bit simpler:
public static &lt;T&gt; T[] asArray(T... items){<break/>    return items;<break/>}<break/>String[] arr = asArray("I am the one and only");<break/>

					<delay>2</delay>
					(But you can't enforce at compile time that it will be an array with only one element)

					<delay>2</delay>
					Next I was going to write a singleton array method, but Stephen beat me to that.

					<delay>2</delay>
				</li>
				<li>
					
					Object [] singleton = { new SomeObject() };<break/>

					<delay>2</delay>
				</li>
				<li>
					
					This should do the job
public SomeType[] makeSingletonArray(SomeType elem) {<break/>    return new SomeType[]{elem};<break/>}<break/>

					<delay>2</delay>
					A generic version of this method would be somewhat awkward to use, since you would need to pass it a Class object as an additional parameter.

					<delay>2</delay>
					Inlining the SomeType[]{elem} expression is simpler, and that's how I'd normally do this.

					<delay>2</delay>
				</li>
				<li>
					
					You could do this:

					<delay>2</delay>
					String[] a = Collections.singletonList(&quot;SingleElement&quot;).toArray();
Edit: Whoops!
					<delay>2</delay>
					The above example doesn't compile.
					<delay>2</delay>
					As stated in the comment, this can be done either as:
Object[] a = Collections.singletonList(&quot;SingleElement&quot;).toArray();
Or
String[] a = Collections.singletonList(&quot;SingleElement&quot;).toArray(new String[1]);

					<delay>2</delay>
				</li>
				<li>
					
					enum solution(anti reflect attack):
enum MySingleton{<break/>    INSTANCE(new String[]{"a","b"});<break/>    final String[] values;<break/>    private MySingleton(String[] values) {<break/>        this.values = values;<break/>    }<break/>}<break/>
reference it as:
MySingleton.INSTANCE;<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If your project is already using Apache Commons lib, you can stick to ArrayUtils.toArray() method.

					<delay>2</delay>
					String[] arr = ArrayUtils.toArray("The string");<break/>// or if using static import<break/>String[] arr = toArray("The string");<break/>

					<delay>2</delay>
					Even if using static import it is still more verbose than the accepted answer:
String[] arr = {"The string"};<break/>

					<delay>2</delay>
					But it comes very handy when compact array initializer syntax is not allowed. 

					<delay>2</delay>
					Some examples:
someMethod(toArray("The string"), /* other params */);<break/>return toArray("The string");<break/>@DataProvider<break/>public Object[][] someDataProvider() {<break/>    return rangeClosed(-12, +12)<break/>        .map(HOURS::toMillis).boxed()<break/>        .map(ArrayUtils::toArray)<break/>        .toArray(Object[][]::new);<break/>}<break/>
You can imagine any other examples yourself.

					<delay>2</delay>
					Also note, that the ArrayUtils.toArray() can wrap an arbitrary number of objects into array, not only a single one.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ best way ^ create singleton array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- What is the best way to remove the first element from an array? -->
			^ best way ^ remove ^ first element ^ array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Simplest way is probably as follows - you basically need to construct a new array that is one element smaller, then copy the elements you want to keep to the right positions.

					<delay>2</delay>
					int n=oldArray.length-1;<break/>String[] newArray=new String[n];<break/>System.arraycopy(oldArray,1,newArray,0,n);<break/>
Note that if you find yourself doing this kind of operation frequently, it could be a sign that you should actually be using a different kind of data structure, e.g. a linked list.
					<delay>2</delay>
					Constructing a new array every time is an O(n) operation, which could get expensive if your array is large.
					<delay>2</delay>
					A linked list would give you O(1) removal of the first element.

					<delay>2</delay>
					An alternative idea is not to remove the first item at all, but just increment an integer that points to the first index that is in use.
					<delay>2</delay>
					Users of the array will need to take this offset into account, but this can be an efficient approach.
					<delay>2</delay>
					The Java String class actually uses this method internally when creating substrings.

					<delay>2</delay>
				</li>
				<li>
					
					The size of arrays in Java cannot be changed.  
					<delay>2</delay>
					So, technically you cannot remove any elements from the array.

					<delay>2</delay>
					One way to simulate removing an element from the array is to create a new, smaller array, and then copy all of the elements from the original array into the new, smaller array.

					<delay>2</delay>
					String[] yourArray = Arrays.copyOfRange(oldArr, 1, oldArr.length);<break/>

					<delay>2</delay>
					However, I would not suggest the above method.  
					<delay>2</delay>
					You should really be using a List&lt;String&gt;.  
					<delay>2</delay>
					Lists allow you to add and remove items from any index.  
					<delay>2</delay>
					That would look similar to the following:
List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // or LinkedList&lt;String&gt;();<break/>list.add("Stuff");<break/>// add lots of stuff<break/>list.remove(0); // removes the first item<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can't do it at all, let alone quickly.  
					<delay>2</delay>
					Arrays in Java are fixed size.  
					<delay>2</delay>
					Two things you could do are:
Shift every element up one, then set the last element to null.

					<delay>2</delay>
					Create a new array, then copy it.

					<delay>2</delay>
					You can use System.arraycopy for either of these.  
					<delay>2</delay>
					Both of these are O(n), since they copy all but 1 element.

					<delay>2</delay>
					If you will be removing the first element often, consider using LinkedList instead.  
					<delay>2</delay>
					You can use LinkedList.remove, which is from the Queue interface, for convenience.  
					<delay>2</delay>
					With LinkedList, removing the first element is O(1).  
					<delay>2</delay>
					In fact, removing any element is O(1)
					<delay>2</delay>
					once you have a ListIterator to that position.  
					<delay>2</delay>
					However, accessing an arbitrary element by index is O(n).

					<delay>2</delay>
				</li>
				<li>
					
					Keep an index of the first "live" element of the array.
					<delay>2</delay>
					Removing (pretending to remove) the first element then becomes an O(1) time complexity operation.

					<delay>2</delay>
				</li>
				<li>
					
					An alternative ugly method:
   String[] a ={"BLAH00001","DIK-11","DIK-2","MAN5"};<break/>   String[] k=Arrays.toString(a).split(", ",2)[1].split("]")[0].split(", ");<break/>

					<delay>2</delay>
				</li>
				<li>
					
					To sum up, the quick linkedlist method:
List&lt;String&gt; llist = new LinkedList&lt;String&gt;(Arrays.asList(oldArray));<break/>llist.remove(0);<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ best way ^ remove ^ first element ^ array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How do you write a method that prints objects in a array in java? -->
			^ write ^ method ^ prints objects ^ array ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					There are several useful toString() and deepToString() methods in java.util.Arrays class.

					<delay>2</delay>
					String[] strings = { "foo", "bar", "waa" };<break/>System.out.println(Arrays.toString(strings)); // [foo, bar, waa]<break/>
An alternative is to just loop over them yourself and print each item separately.

					<delay>2</delay>
				</li>
				<li>
					
					Using Apache Commons Lang:
org.apache.commons.lang.StringUtils.join(Arrays.asList(strings), ", ");<break/>
Using Spring Core:
org.springframework.util.StringUtils.collectionToDelimitedString(Arrays.asList(strings), ", ");<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can do it using for loop. 

					<delay>2</delay>
					Here's example :

					<delay>2</delay>
					  String[] colors = {"red","blue","black","green","yellow"};<break/>  for (String color : colors) {<break/>   System.out.println(color);<break/>  }<break/>
Also check :
					<delay>2</delay>
					What&#39;s the simplest way to print a Java array?

					<delay>2</delay>
					As quoted by Esko in above link is best answer:
  
					<delay>2</delay>
					In Java 5 Arrays.toString(arr) or
  Arrays.deepToString(arr) for arrays
  within arrays.
  
  
					<delay>2</delay>
					Note that Object[]
  version calls .toString
					<delay>2</delay>
					() of each
  object in array.
					<delay>2</delay>
					If my memory serves
  me correct, the output is even
  decorated in the exact way you're
  asking.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ write ^ method ^ prints objects ^ array ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Assigning an array to an ArrayList in Java -->
			^ assigning ^ array ^ arraylist ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					The Arrays class contains an asList method which you can use as follows:
String[] words = ...;<break/>List&lt;String&gt; wordList = Arrays.asList(words);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can use Arrays.asList():
Type[] anArray = ...<break/>ArrayList&lt;Type&gt; aList = new ArrayList&lt;Type&gt;(Arrays.asList(anArray));<break/>
or alternatively, Collections.addAll():
ArrayList&lt;Type&gt; aList = new ArrayList&lt;Type&gt;();<break/>Collections.addAll(theList, anArray); <break/>
Note that you aren't technically assigning an array to a List (well, you can't do that), but I think this is the end result you are looking for.

					<delay>2</delay>
				</li>
				<li>
					
					If you are importing or you have an array (of type string) in your code and you have to convert it into arraylist (offcourse string) then use of collections is better.

					<delay>2</delay>
					like this:
String array1[] = getIntent().getExtras().getStringArray("key1"); or<break/>String array1[] = ...<break/>then<break/>List&lt;String&gt; allEds = new ArrayList&lt;String&gt;();<break/>Collections.addAll(allEds, array1);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					This is working
    int[] ar = {10, 20, 20, 10, 10, 30, 50, 10, 20};<break/>    ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();<break/>    for(int i:ar){<break/>        list.add(new Integer(i));<break/>    }<break/>    System.out.println(list.toString());<break/>    // prints : [10, 20, 20, 10, 10, 30, 50, 10, 20]<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ assigning ^ array ^ arraylist ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How much data can a List can hold at the maximum? -->
			^ much data ^ list ^ hold ^ maximum 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					As much as your available memory will allow.  
					<delay>2</delay>
					There's no size limit except for the heap.

					<delay>2</delay>
				</li>
				<li>
					
					It would depend on the implementation, but the limit is not defined by the List interface.

					<delay>2</delay>
					The interface however defines the size() method, which returns an int. 
  Returns the number of elements in this list.  
					<delay>2</delay>
					If this list contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.

					<delay>2</delay>
					So, no limit,
					<delay>2</delay>
					but after you reach Integer.MAX_VALUE, the behaviour of the list changes a bit
ArrayList (which is tagged) is backed by an array, and is limited to the size of the array - i.e. Integer.MAX_VALUE

					<delay>2</delay>
				</li>
				<li>
					
					java.util.List is an interface.
					<delay>2</delay>
					How much data a list can hold is dependant on the specific implementation of List you choose to use. 

					<delay>2</delay>
					Generally, a List implementation can hold any number of items (If you use an indexed List, it may be limited to Integer.MAX_VALUE or Long.MAX_VALUE).
					<delay>2</delay>
					As long as you don't run out of memory, the List doesn't become "full" or anything.

					<delay>2</delay>
				</li>
				<li>
					
					
  How much data can be added in java.util.List in Java at the maximum?

					<delay>2</delay>
					This is very similar to Theoretical limit for number of keys (objects)
					<delay>2</delay>
					that can be stored in a HashMap?

					<delay>2</delay>
					The documentation of java.util.List does not explicitly documented any limit on the maximum number of elements.
					<delay>2</delay>
					The documentation of List.toArray however, states that ...
  Return an array containing all of the elements in this list in proper sequence (from first to last element);
   would have trouble implementing certain methods faithfully, such as 
...
					<delay>2</delay>
					so strictly speaking it would not be possible to faithfully implement this method if the list had more than 231-1 = 2147483647 elements since that is the largest possible array.

					<delay>2</delay>
					Some will argue that the documentation of size()...
  Returns the number of elements in this list.
					<delay>2</delay>
					If this list contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
...indicates that there is no upper limit, but this view leads to numerous inconsistencies.
					<delay>2</delay>
					See this bug report.
  
					<delay>2</delay>
					Is there any default size an array list?

					<delay>2</delay>
					If you're referring to ArrayList then I'd say that the default size is 0.
					<delay>2</delay>
					The default capacity however (the number of elements you can insert, without forcing the list to reallocate memory) is 10.
					<delay>2</delay>
					See the documentation of the default constructor.

					<delay>2</delay>
					The size limit of ArrayList is Integer.MAX_VALUE since it's backed by an ordinary array.

					<delay>2</delay>
				</li>
				<li>
					
					It depends on the List implementation.
					<delay>2</delay>
					Since you index arrays with ints, an ArrayList can't hold more than Integer.MAX_VALUE elements.
					<delay>2</delay>
					A LinkedList isn't limited in the same way, though, and can contain any amount of elements.

					<delay>2</delay>
				</li>
				<li>
					
					see the code below of arraylist default it is 10 when u create 
List l = new ArrayList();
   public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;,<break/>           Cloneable, Serializable, RandomAccess {<break/>          private static final long serialVersionUID = 8683452581122892189L;<break/>          private transient int firstIndex;<break/>          private transient int lastIndex;<break/>          private transient E[] array;<break/>          /**<break/>           * Constructs a new instance of {@code ArrayList} with ten capacity.<break/>           */<break/>          public ArrayList() {<break/>              this(10);<break/>          }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					The interface however defines the size() method, which returns an int.

					<delay>2</delay>
					Returns the number of elements in this list. If this list contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.<break/>

					<delay>2</delay>
					So, no limit, but after you reach Integer.
					<delay>2</delay>
					MAX_VALUE, the behaviour of the list changes a bit
ArrayList (which is tagged) is backed by an array, and is limited to the size of the array - i.e. Integer.
					<delay>2</delay>
					MAX_VALUE

					<delay>2</delay>
				</li>
				<li>
					
					Numbering an items in the java array should start from zero.
					<delay>2</delay>
					This was i think we can have access to Integer.
					<delay>2</delay>
					MAX_VALUE+1 an items.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ much data ^ list ^ hold ^ maximum </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- 2D Array Question Java -->
			^ 2d array question java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					arr.length <break/>
will be the number of rows
arr[x].length<break/>
will be the number of columns in row x.

					<delay>2</delay>
				</li>
				<li>
					
					You can find the number of rows as:
arr.length<break/>

					<delay>2</delay>
					In Java all the rows need not have same number of elements.
					<delay>2</delay>
					You can find the number of elements in the row i as:
arr[i].length<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Rows - arr.length<break/>Columns -arr[rowNumber].length //Each row can have different number of elements<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ 2d array question java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Possible to return a String array -->
			^ possible ^ return ^ string array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Yes, but in Java the type is String[], not string[].
					<delay>2</delay>
					The case is important.

					<delay>2</delay>
					For example a method could look something like this:

					<delay>2</delay>
					public String[] foo() {<break/>    // ...<break/>}<break/>
Here is a complete example:

					<delay>2</delay>
					public class Program<break/>{<break/>    public static void main(String[] args) {<break/>        Program program = new Program();<break/>        String[] greeting = program.getGreeting();<break/>        for (String word: greeting) {<break/>            System.out.println(word);<break/>        }<break/>    }<break/>    public String[] getGreeting() {<break/>        return new String[] { "hello", "world" };<break/>    }<break/>}<break/>
Result:
hello

					<delay>2</delay>
					world
ideone

					<delay>2</delay>
				</li>
				<li>
					
					Yes.
/** Returns a String array of length 5 */<break/>public String[] createStringArray() {<break/>    return new String[5];<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Yes:
String[] dummyMethod()<break/>{<break/>    String[] s = new String[2];<break/>    s[0] = "hello";<break/>    s[1] = "world";<break/>    return s;<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					yes.

					<delay>2</delay>
					public String[] returnStringArray()<break/>{<break/>    return new String[] { "a", "b", "c" };<break/>}<break/>

					<delay>2</delay>
					Do you have a more specific need?

					<delay>2</delay>
				</li>
				<li>
					
					Sure
public String [] getSomeStrings() {<break/>    return new String [] { "Hello", "World" };<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ possible ^ return ^ string array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java Scanner() to read from Array -->
			^ read ^ array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					There is nothing built in, but you could certainly join all of the elements in your array and pass the resulting string into the Scanner constructor.

					<delay>2</delay>
					A solution with better performance but a greater time investment is to implement Readable by wrapping your array, and keeping track of the current element in the array and the current position in that element's string representation.
					<delay>2</delay>
					You can then fill the buffer with data from the backing array as the Scanner reads from your Readable object.
					<delay>2</delay>
					This approach lets you lazily stream data from your array into the Scanner, but at the cost of requiring you to write some code.

					<delay>2</delay>
				</li>
				<li>
					
					Use the Arrays.toString() method on the array.

					<delay>2</delay>
					For example:
int[] arrayOfInts = {1, 2, 3};<break/>Scanner s = new Scanner(Arrays.toString(arrayOfInts));<break/>while (s.hasNext()) {<break/>    System.out.println(s.next());<break/>}<break/>
Will print out:
[1,<break/>2,<break/>3]<break/>

					<delay>2</delay>
				</li>
				<li>
					
					public class Totalsum {<break/>  public static void main(String[] args){<break/>  int[] y={6,1,5,9,5};<break/>  int[] z={2,13,6,15,2};<break/>  int Total= sumLargeNumber(y,z,5);<break/>  System.out.println("The Total sum is "+Total); //call method<break/>}<break/>public static int sumLargeNumber(int a[], int b[], int size) {<break/>  int total=0;<break/>  for(int i=0; i&lt; size; i++) {<break/>    if(a[i] &gt; b[i]){<break/>      total=total+a[i];<break/>    }<break/>    else {<break/>      total=total+b[i];<break/>    }<break/>  }<break/>  return total;<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ read ^ array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Efficient array elements un-ordering in Java -->
			^ efficient array elements un ^ ordering ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					I think you want Collections.shuffle(List)?
					<delay>2</delay>
					If not that, you will need to give us more details about what you're trying to do.

					<delay>2</delay>
				</li>
				<li>
					
					I don't know much Java, so there may be better way, but this'll do the trick nicely. 

					<delay>2</delay>
					Fisher-Yates shuffle from Wikipedia:
static Random rng = new Random();<break/>public static void shuffle(int[] array) {<break/>    // i is the number of items remaining to be shuffled.<break/>    for (int i = array.length; i &gt; 1; i--) {<break/>        // Pick a random element to swap with the i-th element.<break/>        int j = rng.nextInt(i);  // 0 &lt;= j &lt;= i-1 (0-based array)<break/>        // Swap array elements.<break/>        int tmp = array[j];<break/>        array[j] = array[i-1];<break/>        array[i-1] = tmp;<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You want to shuffle that array using a good algorithm.

					<delay>2</delay>
					I would trust Collections#shuffle to implement this properly.
					<delay>2</delay>
					If you need it to work on the array directly, implement the algorithm in your own helper method.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ efficient array elements un ^ ordering ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java array to multi dimensional -->
			^ java array ^ multi dimensional 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Iterate throughout your list of 100 chars and divide it amongst the 10*10,
Modulus (%) will probably be very useful.

					<delay>2</delay>
					You could use 2 nested for loops to assign the chars of the array to the appropriate element.

					<delay>2</delay>
				</li>
				<li>
					
					Here you go
char[] chars = ("01234567890123456789012345678901234567890123456789" + <break/>                "01234567890123456789012345678901234567890123456789")<break/>                .toCharArray();<break/>char[][] char2D = new char[10][10];<break/>for (int i = 0; i &lt; 100; i++)<break/>    char2D[i / 10][i % 10] = chars[i];<break/>

					<delay>2</delay>
					Now the this code...
System.out.println(Arrays.deepToString(char2D).replaceAll("],","],\n"));<break/>
...prints the following
[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],<break/> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],<break/> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],<break/> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],<break/> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],<break/> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],<break/> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],<break/> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],<break/> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],<break/> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java array ^ multi dimensional </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Creating an Arraylist of Objects -->
			^ creating ^ arraylist ^ objects 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					ArrayList&lt;Matrices&gt; list = new ArrayList&lt;Matrices&gt;();<break/>list.add( new Matrices(1,1,10) );<break/>list.add( new Matrices(1,2,20) );<break/>

					<delay>2</delay>
				</li>
				<li>
					
					How to Creating an Arraylist of Objects.

					<delay>2</delay>
					Create an array to store the objects:
ArrayList&lt;MyObject&gt; list = new ArrayList&lt;MyObject&gt;();<break/>

					<delay>2</delay>
					In a single step:

					<delay>2</delay>
					list.add(new MyObject (1, 2, 3)); //Create a new object and adding it to list. <break/>
or
MyObject myObject = new MyObject (1, 2, 3); //Create a new object.<break/>list.add(myObject); // Adding it to the list.<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you want to allow a user to add a bunch of new MyObjects to the list, you can do it with a for loop:

					<delay>2</delay>
					Let's say I'm creating an ArrayList of Rectangle objects, and each Rectangle has two parameters- length and width.

					<delay>2</delay>
					//here I will create my ArrayList:<break/>ArrayList &lt;Rectangle&gt; rectangles= new ArrayList &lt;&gt;(3); <break/>int length;<break/>int width;<break/>for(int index =0; index &lt;3;index++)<break/>{JOptionPane.showMessageDialog(null, "Rectangle " + (index + 1));<break/> length = JOptionPane.showInputDialog("Enter length");<break/> width = JOptionPane.showInputDialog("Enter width");<break/> //Now I will create my Rectangle and add it to my rectangles ArrayList:<break/> rectangles.add(new Rectangle(length,width));<break/>//This passes the length and width values to the rectangle constructor,<break/>  which will create a new Rectangle and add it to the ArrayList.<break/>
}

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ creating ^ arraylist ^ objects </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Converting 'ArrayList to 'String[]' in Java -->
			^ converting ^ arraylist ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					List&lt;String&gt; list = ..;<break/>String[] array = list.toArray(new String[0]);<break/>

					<delay>2</delay>
					For example:

					<delay>2</delay>
					List&lt;String&gt; list = new ArrayList&lt;String&gt;();<break/>//add some stuff<break/>list.add("android");<break/>list.add("apple");<break/>String[] stringArray = list.toArray(new String[0]);<break/>

					<delay>2</delay>
					The toArray() method without passing any argument returns Object[].
					<delay>2</delay>
					So you have to pass an array as an argument, which will be filled with the data from the list, and returned.
					<delay>2</delay>
					You can pass an empty array as well, but you can also pass an array with the desired size.

					<delay>2</delay>
					Important update: Originally the code above used new String[list.size()].
					<delay>2</delay>
					However, this blogpost reveals that due to JVM optimizations, using new String[0] is better now.

					<delay>2</delay>
				</li>
				<li>
					
					List &lt;String&gt; list = ...<break/>String[] array = new String[list.size()];<break/>int i=0;<break/>for(String s: list){<break/>  array[i++] = s;<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();<break/>Object[] objectList = arrayList.toArray();<break/>String[] stringArray =  Arrays.copyOf(objectList,objectList.length,String[].class);<break/>

					<delay>2</delay>
					Using copyOf, ArrayList to arrays might be done also.

					<delay>2</delay>
				</li>
				<li>
					
					An alternative in Java 8:
String[] strings = list.stream().toArray(String[]::new);<break/>
Java 11
					<delay>2</delay>
					+:
String[] strings = list.toArray(String[]::new);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can use the toArray() method for List:
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();<break/>list.add("apple");<break/>list.add("banana");<break/>String[] array = list.toArray(new String[list.size()]);<break/>

					<delay>2</delay>
					Or you can manually add the elements to an array:
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();<break/>list.add("apple");<break/>list.add("banana");<break/>String[] array = new String[list.size()];<break/>for (int i = 0; i &lt; list.size(); i++) {<break/>    array[i] = list.get(i);<break/>}<break/>
Hope this helps!

					<delay>2</delay>
				</li>
				<li>
					
					In Java 8:
String[] strings = list.parallelStream().toArray(String[]::new);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					in case some extra manipulation of the data is desired, for which the user wants a function, this approach is not perfect (as it requires passing the class of the element as second parameter), but works:
import java.util.ArrayList;
import java.lang.reflect.Array;
public class Test {<break/>  public static void main(String[] args) {<break/>    ArrayList&lt;Integer&gt; al = new ArrayList&lt;&gt;();<break/>    al.add(1);<break/>    al.add(2);<break/>    Integer[] arr = convert(al, Integer.class);<break/>    for (int i=0; i&lt;arr.length; i++)<break/>      System.out.println(arr[i]);<break/>  }<break/>  public static &lt;T&gt; T[] convert(ArrayList&lt;T&gt; al, Class clazz) {<break/>    return (T[]) al.toArray((T[])Array.newInstance(clazz, al.size()));<break/>  }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Generics solution to covert any List&lt;Type&gt; to String []:
$
					<delay>2</delay>
					code_placeholder_3
Note You must override toString() method.

					<delay>2</delay>
					class Car {<break/>  private String name;<break/>  public Car(String name) {<break/>    this.name = name;<break/>  }<break/>  public String toString() {<break/>    return name;<break/>  }<break/>}<break/>final List&lt;Car&gt; carList = new ArrayList&lt;Car&gt;();<break/>carList.add(new Car("BMW"))<break/>carList.add(new Car("Mercedes"))<break/>carList.add(new Car("Skoda"))<break/>final String[] carArray = listToArray(carList);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can use Iterator&lt;String&gt; to iterate the elements of the ArrayList&lt;String&gt;:
ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();<break/>String[] array = new String[list.size()];<break/>int i = 0;<break/>for (Iterator&lt;String&gt; iterator = list.iterator(); iterator.hasNext(); i++) {<break/>    array[i] = iterator.next();<break/>}<break/>

					<delay>2</delay>
					Now you can retrive elements from String[] using any Loop.

					<delay>2</delay>
				</li>
				<li>
					
					private String[] prepareDeliveryArray(List&lt;DeliveryServiceModel&gt; deliveryServices) {<break/>    String[] delivery = new String[deliveryServices.size()];<break/>    for (int i = 0; i &lt; deliveryServices.size(); i++) {<break/>        delivery[i] = deliveryServices.get(i).getName();<break/>    }<break/>    return delivery;<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If your application is already using Apache Commons lib, you can slightly modify the accepted answer to not create a new empty array each time:

					<delay>2</delay>
					List&lt;String&gt; list = ..;<break/>String[] array = list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);<break/>// or if using static import<break/>String[] array = list.toArray(EMPTY_STRING_ARRAY);<break/>

					<delay>2</delay>
					There are a few more preallocated empty arrays of different types in ArrayUtils.

					<delay>2</delay>
					Also we can trick JVM to create en empty array for us this way:
String[] array = list.toArray(ArrayUtils.toArray());<break/>// or if using static import<break/>String[] array = list.toArray(toArray());<break/>

					<delay>2</delay>
					But there's really no advantage this way, just a matter of taste, IMO.

					<delay>2</delay>
				</li>
				<li>
					
					You can convert List to String array by using this method:
 Object[] stringlist=list.toArray();<break/>

					<delay>2</delay>
					The complete example:
ArrayList&lt;String&gt; list=new ArrayList&lt;&gt;();<break/>    list.add("Abc");<break/>    list.add("xyz");<break/>    Object[] stringlist=list.toArray();<break/>    for(int i = 0; i &lt; stringlist.length ; i++)<break/>    {<break/>          Log.wtf("list data:",(String)stringlist[i]);<break/>    }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Starting from Java-11, one can alternatively use the API Collection.toArray(IntFunction&lt;T[]&gt; generator) to achieve the same as:
List&lt;String&gt; list = List.of("x","y","z");<break/>String[] arrayBeforeJDK11 = list.toArray(new String[0]);<break/>String[] arrayAfterJDK11 = list.toArray(String[]::new); // similar to Stream.toArray<break/>

					<delay>2</delay>
				</li>
				<li>
					
					In Java 8, it can be done using
String[] arrayFromList = fromlist.stream().toArray(String[]::new);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					In Java 11, we can use the Collection.toArray(generator) method.
					<delay>2</delay>
					The following code will create a new array of strings:

					<delay>2</delay>
					List&lt;String&gt; list = List.of("one", "two", "three");<break/>String[] array = list.toArray(String[]::new)<break/>
from java.base's  java.util.Collection.toArray().

					<delay>2</delay>
				</li>
				<li>
					
					    List&lt;String&gt; list = new ArrayList&lt;&gt;();<break/>    list.add("a");<break/>    list.add("b");<break/>    list.add("c");<break/>    String [] strArry= list.stream().toArray(size -&gt; new String[size]);<break/>

					<delay>2</delay>
					Per comments, I have added a paragraph to explain how the conversion works. 

					<delay>2</delay>
					First, List is converted to a String stream.
					<delay>2</delay>
					Then it uses Stream.toArray to convert the elements in the stream to an Array.
					<delay>2</delay>
					In the last statement above "size ->
					<delay>2</delay>
					new String[size]" is actually an IntFunction function that allocates a String array with the size of the String stream.
					<delay>2</delay>
					The statement is identical to
IntFunction&lt;String []&gt; allocateFunc = size -&gt; { <break/>return new String[size];<break/>};   <break/>String [] strArry= list.stream().toArray(allocateFunc);<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ converting ^ arraylist ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Can I add a group of ArrayList into a single ArrayList? -->
			^ add ^ group ^ arraylist ^ single arraylist 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					I hope I understand your question correctly.

					<delay>2</delay>
					An ArrayList is a list of Object types.
					<delay>2</delay>
					If you wish to add an ArrayList as the item in your ArrayList, then you can do this.

					<delay>2</delay>
					An example
ArrayList list = new ArrayList();<break/>ArrayList list2 = new ArrayList();<break/>ArrayList list3 = new ArrayList();<break/>list.add(list2);<break/>list.add(list3);<break/>

					<delay>2</delay>
					This will result in your first ArrayList (list) containing two arraylists in position 0 and 1.

					<delay>2</delay>
					If however you are looking to add the contents of several ArrayLists to a single list of elements, then you use addAll on the  ArrayList.
					<delay>2</delay>
					Such as
ArrayList consolidatedList = new ArrayList();<break/>list.addAll(list2);<break/>list.addAll(list3);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					I didn't actually get what you want to do.
					<delay>2</delay>
					Do you want to add all elements from different ArrayLists to one resulting ArrayList?
					<delay>2</delay>
					If so, use ArrayList#addAll(Collection collection) method.

					<delay>2</delay>
					If you want an ArrayList of ArrayLists, use ArrayList#add(Object o) method.
					<delay>2</delay>
					You can also parameterize your resulting ArrayList like this:
List&lt;ArrayList&gt; res = new ArrayList&lt;ArrayList&gt;()

					<delay>2</delay>
				</li>
				<li>
					
					Yes you can add a "group of ArrayLists" into a single array list.
					<delay>2</delay>
					If you want to "recognize" your ArrayLists, I would recommend using a Map, a HashMap for example.

					<delay>2</delay>
					Please also think about accepting answers to your other questions, and post code in your questions, you will get better help and people will hate you less.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ add ^ group ^ arraylist ^ single arraylist </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Maximum number of dimensions in a Java array -->
			^ maximum number ^ dimensions ^ java array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					The Java language does not limit the number of dimensions, but the Java VM spec limits the number of dimensions to 255.

					<delay>2</delay>
					For example, the following code will fail to compile:
class Main {<break/>    public static void main(String[] args) {<break/>        final int[][][][][][][][][][][][][][][][]<break/>                 [][][][][][][][][][][][][][][][]<break/>                 [][][][][][][][][][][][][][][][]<break/>                 [][][][][][][][][][][][][][][][]<break/>                 [][][][][][][][][][][][][][][][]<break/>                 [][][][][][][][][][][][][][][][]<break/>                 [][][][][][][][][][][][][][][][]<break/>                 [][][][][][][][][][][][][][][][]<break/>                 [][][][][][][][][][][][][][][][]<break/>                 [][][][][][][][][][][][][][][][]<break/>                 [][][][][][][][][][][][][][][][]<break/>                 [][][][][][][][][][][][][][][][]<break/>                 [][][][][][][][][][][][][][][][]<break/>                 [][][][][][][][][][][][][][][][]<break/>                 [][][][][][][][][][][][][][][][]<break/>                 [][][][][][][][][][][][][][][][] x;<break/>    }<break/>}<break/>
with error:
1.java:18: error: array type has too many dimensions<break/>                 [][][][][][][][][][][][][][][][] x;<break/>                                                  ^<break/>1 error<break/>

					<delay>2</delay>
					(Ref: https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.1 "An array type descriptor is valid only if it represents 255 or fewer dimensions.")

					<delay>2</delay>
				</li>
				<li>
					
					Strictly speaking about 
 Maximum number of dimensions in a Java array<break/>
is only one dimensional array is possible in java.
					<delay>2</delay>
					because under the hood java treat multidimensional arrays as array of arrays.

					<delay>2</delay>
					Proof of concept:
					<delay>2</delay>
					http://www.willamette.edu/~gorr/classes/cs231/lectures/chapter9/arrays2d.htm

					<delay>2</delay>
					that's why its possible to have ragged arrays in Java as well!

					<delay>2</delay>
				</li>
				<li>
					
					Small experiment shows, that 255 dimensions is maximum.
					<delay>2</delay>
					256 causes compilation error;
The screenshot

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ maximum number ^ dimensions ^ java array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to read a file into a Java Bitmap? -->
			^ read ^ file ^ java bitmap 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Use BitmapFactory if you already have your byte array:
Bitmap bitmap = BitmapFactory.decodeByteArray(yourByteArray, offset, length);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Skip the byte array if you want:
    Bitmap bitmap = BitmapFactory.decodeFile(filename);

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ read ^ file ^ java bitmap </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- can I copy an array to a hash table? -->
			^ copy ^ array ^ hash table 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You can easily put them into a Hashtable of int -> float.  
					<delay>2</delay>
					The following method will use their index in the array as the key.
float[] arr;<break/>Hashtable&lt;Integer, Float&gt; table = new Hashtable&lt;Integer, Float&gt;(arr.length);<break/>for (int i = 0; i &lt; arr.length; i++) {<break/>    table.put(i, arr[i]);<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Hashtable implements Map, so you would need to pair every float with some key. 

					<delay>2</delay>
				</li>
				<li>
					
					An array cannot directly correspond to a Map.
					<delay>2</delay>
					It can correspond to a set.

					<delay>2</delay>
					new HashSet(Arrays.asList(array))<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Given the OP's clarification of his/her requirements in jjnguy's answer, here's an O(n) (amortized) way to count occurrences of unique values in a float array:
float[] values;<break/>Map&lt;Float, Integer&gt; occurrences = new HashMap&lt;Float, Integer&gt;();<break/>for ( float f : values ) {<break/>    int count = occurrences.containsKey(f) ? occurrences.get(f) : 0;<break/>    occurrences.put(f, count+1);<break/>}<break/>//then find multiple occurrences by finding entries with a value &gt; 0<break/>for ( Entry&lt;Float, Integer&gt; entry : occurrences.values() ) {<break/>    if ( entry.getValue() &gt; 1 ) {<break/>       System.out.println("Duplicate: " + entry.getKey());<break/>    }<break/>}<break/>

					<delay>2</delay>
					In practice it's usually smelly to use a float as a key to anything, or to use a float in a way that pretends it's a discrete value.  
					<delay>2</delay>
					Floating point types are typically used to simulate "continuous" values, where for all intents and purposes 7.000000000012 should be considered the same as 7.000000000013.

					<delay>2</delay>
				</li>
				<li>
					
					If you want to know how many there are of different float values in your array, the best solution would be a multiset (which is typically built on top of a Map&lt;T, Integer&gt;).
					<delay>2</delay>
					With Guava, you could do this:
float[] floats = ...<break/>Multiset&lt;Float&gt; multiset = HashMultiset.create(Floats.asList(floats));<break/>for (Multiset.Entry&lt;Float&gt; entry : multiset.entrySet()) {<break/>  Float value = entry.getElement();<break/>  int count = entry.getCount();<break/>  ...<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ copy ^ array ^ hash table </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Copy 2 array in a new one -->
			^ copy 2 array ^ new one 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Using System.arraycopy takes advantage of the underlying hardware to perform the array copy as efficiently as possible.

					<delay>2</delay>
					In the context of the question you would need to call System.arraycopy twice; e.g.
int[] dest = new int[10];<break/>int[] src1 = new int[5];<break/>int[] src2 = new int[5];<break/>// Populate source arrays with test data.<break/>for (int i=0; i&lt;5; ++i) {<break/>  src1[i] = i;<break/>  src2[i] = i + 100;<break/>}<break/>System.arraycopy(src1, 0, dest, 0, src1.length);<break/>System.arraycopy(src2, 0, dest, src1.length, src2.length);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can use [System.arraycopy][1] as shown here.

					<delay>2</delay>
					[1]:
					<delay>2</delay>
					http://download.oracle.com/javase/1.4.2/docs/api/java/lang/System.html#arraycopy(java.lang.Object, int, java.lang.Object, int, int)

					<delay>2</delay>
				</li>
				<li>
					
					My reputation doesn't allow me to comment on Adamski's answer, but there is an error on this line:
 System.arraycopy(src2, 0, dest, src1.length - 1, src2.length);<break/>
With src1.length - 1 as an argument to destPos, you overwrite the last element copied from the src1 array.
					<delay>2</delay>
					In this case you overwrite the element on index 4, which is the 5th element of the array.

					<delay>2</delay>
					This code might be easier to understand:
    int[] array1 = { 1, 2, 3 };<break/>    int[] array2 = { 4, 5, 6, 7 };<break/>    int[] array3 = new int[ array1.length + array2.length ];<break/>    System.arraycopy( array1, 0, array3, 0, array1.length );<break/>    System.arraycopy( array2, 0, array3, array1.length, array2.length );<break/>    for (int i = 0; i &lt; array3.length; i++) {<break/>        System.out.print( array3[i] + ", " );<break/>    }<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ copy 2 array ^ new one </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to convert a byte array to a string? -->
			^ convert ^ byte array ^ string 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					The Best way to convert bytearray to String is 
public void convertByteArrayToString(Charset encoding) {<break/>        byte[] byteArray = new byte[] {87, 79, 87, 46, 46, 46};<break/>        String value = new String(byteArray, encoding);<break/>        System.out.println(value);<break/>    }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You need to supply an encoding, otherwise you get the system default encoding, essentially a random value.

					<delay>2</delay>
					String value = new String(byteArray, encoding);<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ convert ^ byte array ^ string </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to Pass Array from One Servlet to Another Servlet? -->
			^ pass array ^ one servlet ^ another servlet 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You can store the array in the user session in servlet 1 and read it from servlet 2 getting it from the user session.
					<delay>2</delay>
					Make sure you delete the array from session in servlet 2.

					<delay>2</delay>
				</li>
				<li>
					
					You can 
put your array in request context as an attribute using request.setAttribute()
forward the request to second servlet using RequestDispatcher.forward() 
in your second servlet read the value using request.getAttribute()

					<delay>2</delay>
				</li>
				<li>
					
					Depending if you use sessions:
Store the array in the session variable using session.setAttribute();

					<delay>2</delay>
					Retrieve the array using session.getAttribute();

					<delay>2</delay>
					However the variable will stay until the session dies, you overwrite it with something else, or you remove it.

					<delay>2</delay>
					If you forward one servlet to another servlet, you can store it in the request variable:
request.setAttribute()
Which you can read after forwarding using request.getAttribute() after calling
RequestDispatcher.forward()
Note this does not work if you're doing a redirect instead of a servlet forward.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ pass array ^ one servlet ^ another servlet </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- best way to convert an array of strings to a vector? -->
			^ best way ^ convert ^ array ^ strings ^ vector 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Call the constructor of Vector that uses an existing collection (your array, in this case) to initialize itself:
String[] strings = { "Here", "Are", "Some", "Strings" };<break/>Vector&lt;String&gt; vector = new Vector&lt;String&gt;(Arrays.asList(strings));<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Vector&lt;String&gt; strVector = new Vector&lt;String&gt;(Arrays.asList(strArray));<break/>
Breaking this down:
Arrays.asList(array) converts the array to a List (which implements Collection)

					<delay>2</delay>
					The Vector(Collection) constructor takes a Collection and instantiates a new Vector based off of it. 

					<delay>2</delay>
					We pass the new List to the Vector constructor to get a new Vector&lt;String&gt; strVector = new Vector&lt;String&gt;(Arrays.asList(strArray));<break/>0 from the array of Vector&lt;String&gt; strVector = new Vector&lt;String&gt;(Arrays.asList(strArray));<break/>1s, then save the reference to this object in Vector&lt;String&gt; strVector = new Vector&lt;String&gt;(Arrays.asList(strArray));<break/>2.

					<delay>2</delay>
				</li>
				<li>
					
					new Vector(Arrays.asList(array))<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ best way ^ convert ^ array ^ strings ^ vector </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Why does ensureCapacity() in Java ArrayList extend the capacity with a const 1.5 or (oldCapacity * 3)/2 + 1? -->
			^ java arraylist extend ^ capacity ^ const 1 ^ 1 ^ 5 ^ oldcapacity 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					It helps mitigate the exponential increase in time that would result if the array was expanded by one element instead.

					<delay>2</delay>
				</li>
				<li>
					
					You can create an array with a small capacity even 0 and you small capacities need to grow relatively quickly.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java arraylist extend ^ capacity ^ const 1 ^ 1 ^ 5 ^ oldcapacity </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- What is the different between a stackoverflow and arrayindexoutofbounds? -->
			^ different ^ stackoverflow ^ arrayindexoutofbounds 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					StackOverflowError occurs during endless recursive calls.
					<delay>2</delay>
					It has nothing to do with arrays.
					<delay>2</delay>
					ArrayIndexOutOfBoundsException occurs when when you try to use an index beyond the size of the array.

					<delay>2</delay>
				</li>
				<li>
					
					arrayindexoutofbounds : The exception that is thrown when an attempt is made to read beyond the bounds of an array.

					<delay>2</delay>
					stackoverflow : An error that is issued when a stack overflow occurs.

					<delay>2</delay>
				</li>
				<li>
					
					StackOverFlowError:
 Occurs when the JVM (Java Virtual Memory) is running out of allocated heap space.

					<delay>2</delay>
					ArrayIndexOutOfBoundsException: 
 
					<delay>2</delay>
					Occurs when an application tries to access the array index which does not fall in declared range.

					<delay>2</delay>
				</li>
				<li>
					
					Arrayindexoutofbounds:
					<delay>2</delay>
					You limit your variable for example defining an array with size of 50 and if you want to use the 51.
					<delay>2</delay>
					element of that array you get this exception.

					<delay>2</delay>
					Stackoverflow
					<delay>2</delay>
					: Think about that you didn't limit your variable for example; 
List myList = new List();<break/>

					<delay>2</delay>
					And you are adding elements to this list.

					<delay>2</delay>
					myList.add(something);<break/>

					<delay>2</delay>
					If you add too much element that your heap memory can't allocate any more space to keep your variable it throws that exception.

					<delay>2</delay>
					At first your limit is 50, at 51
					<delay>2</delay>
					you get an exception, at second you don't get an exception at 51.
					<delay>2</delay>
					element if your heap is free enough but you can get an exception when your heap not enough for you.

					<delay>2</delay>
				</li>
				<li>
					
					These two are actually very different things.
					<delay>2</delay>
					As the other guys have already mentioned, ArrayIndexOutOfBoundsException is an Exception that occurs when you are trying to access an array using an incorrect index.
					<delay>2</delay>
					This could be caused by a very simple bug in programming logic.

					<delay>2</delay>
					StackOverflowError is something more low-level.
					<delay>2</delay>
					It has nothing to do with arrays and, contrary to what the other guys said, has nothing to do with the heap either.
					<delay>2</delay>
					Try doing that trick with a List and you'll get an OutOfMemoryError instead.
					<delay>2</delay>
					Now it's an Error that is much more similar to StackOverflowError than ArrayIndexOutOfBoundsException.
					<delay>2</delay>
					Both OutOfMemoryError and StackOverflowError indicate that you're running out of memory, only in different segments.
					<delay>2</delay>
					Running out of stack memory almost always occurs due to infinite recursion (unless you have a ridiculously long chain of methods calling each other with lots of local variables in them), and running out of heap memory happens when you allocate too much and keep all those references so even the garbage collector can't free some memory for you.

					<delay>2</delay>
					So when ArrayIndexOutOfBoundsException is indeed "sticking data where it shouldn't go", StackOverflowError and OutOfMemoryError are better described as "running out of memory to stick your data into".

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ different ^ stackoverflow ^ arrayindexoutofbounds </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java Array Destroy -->
			^ java array destroy 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Only if Array_Name had actually been referencing an array to begin with.
					<delay>2</delay>
					And only if there are no other references to the array.
					<delay>2</delay>
					And it will reclaim only those elements of the array which aren't referenced by anything outside of the array.
					<delay>2</delay>
					And it will only do so when it feels like getting around to it :-)

					<delay>2</delay>
					(The syntax Array_Name[] = NULL isn't really meaningful.
					<delay>2</delay>
					But I'm assuming you'd done something like:

					<delay>2</delay>
					 Foo[] Array_Name = new Foo[n];<break/> //...<break/> Array_Name = null; // Note the lowercase "null"<break/>
This might make the array a proper target for garbage collection, given the conditions I described above.)

					<delay>2</delay>
				</li>
				<li>
					
					I agree with everything Dan mentioned above but you can actually trigger garbage collection manually by calling System.gc().
					<delay>2</delay>
					Of course as mentioned this will only collect objects that are no longer referenced by anything else.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java array destroy </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Why does Java allow arrays of size 0? -->
			^ java allow arrays ^ size 0 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Sometimes it's much more friendly to return a zero size array than null.

					<delay>2</delay>
				</li>
				<li>
					
					It signifies that it is empty.
					<delay>2</delay>
					I.e. you can loop over it as if it had items and have no result
					<delay>2</delay>
					occur:
for(int k = 0; k &lt; strings.length; k++){<break/>   // something<break/>}<break/>

					<delay>2</delay>
					Thereby avoiding the need to check.
					<delay>2</delay>
					If the array in question were null, an exception would occur, but in this case it just does nothing, which may be appropriate.

					<delay>2</delay>
				</li>
				<li>
					
					Same as C++, it allows for cleaner handling when there is no data.

					<delay>2</delay>
				</li>
				<li>
					
					Consider this (a more detailed explanation of Noon's answer):

					<delay>2</delay>
					public String[] getStrings() {<break/> if( foo ) {<break/>  return null;<break/> } else {<break/>  return new String[] {"bar, "baz"};<break/> }<break/>}<break/>String[] strings = getStrings();<break/>if (strings != null) {<break/> for (String s : strings) {<break/>  blah(s);<break/> }<break/>}<break/>
Now compare it to this:

					<delay>2</delay>
					public String[] getStrings() {<break/> if( foo ) {<break/>  return new String[0];<break/> } else {<break/>  return new String[] {"bar, "baz"};<break/> }<break/>}<break/>// the if block is not necessary anymore<break/>String[] strings = getStrings();<break/>for (String s : strings) {<break/> blah(s);<break/>}<break/>
This (returning empty arrays rather than null values), is in fact a best practice in Java API design world.

					<delay>2</delay>
					Besides, in Java, you can covert Lists (e.g. ArrayList) to arrays and it only makes sense to convert an empty list to an empty array.

					<delay>2</delay>
				</li>
				<li>
					
					Why does Java allow arrays of size 1?
					<delay>2</delay>
					Isn't it pretty useless to wrap a single value in an array?
					<delay>2</delay>
					Wouldn't it be sufficient if Java only allowed arrays of size 2 or greater?

					<delay>2</delay>
					Yes, we can pass null instead of an empty array and a single object or primitive instead of a size-one-matrix.

					<delay>2</delay>
					But there are some good arguments against such an restriction.
					<delay>2</delay>
					My personal top arguments:

					<delay>2</delay>
					Restriction is too complicated and not really necessary
To limit arrays to sizes [1..
					<delay>2</delay>
					INTEGER.MAX_INT] we'd have to add a lot of additional boudary checks,(agree to Konrads comment) conversion logic and method overloads to our code.
					<delay>2</delay>
					Excluding 0
					<delay>2</delay>
					(and maybe 1) from the allowed array sizes does not save costs, it requires additional effort and has an negative impact on performance.

					<delay>2</delay>
					Array models vector

					<delay>2</delay>
					An array is a good data model for a vector (mathematics, not the Vector class!).
					<delay>2</delay>
					And of course, a vector in mathematics may be zero dimensional.
					<delay>2</delay>
					Which is conceptually different from being non-existant.

					<delay>2</delay>
					Sidenote - a prominent wrapper for an (char-)array is the String class.
					<delay>2</delay>
					The immutable String materializes the concept of an empty array: it is the empty String ("").

					<delay>2</delay>
				</li>
				<li>
					
					One case I can think of where an empty array is extremely useful is to use it instead of null in a situation where null isn't allowed.
					<delay>2</delay>
					One possible example of that is a BlockingQueue of arrays.
					<delay>2</delay>
					When you want to signal the end of input to the reading side, what would you do?
					<delay>2</delay>
					To send null seems like an obvious choice, but the thing is that BlockingQueue doesn't accept nulls.
					<delay>2</delay>
					You could wrap your array inside a class with "boolean last;" kind of field, but that's kind of overkill.
					<delay>2</delay>
					Sending an empty (zero-sized) array seems like the most reasonable choice.

					<delay>2</delay>
				</li>
				<li>
					
					Another case where a zero length array can be useful:
To return an array containing all of the elements in a list : 
&lt;T&gt; T[ ] toArray(T[ ] a)<break/>

					<delay>2</delay>
					A zero length array can be used to pass the type of the array into this method.
					<delay>2</delay>
					For example:
ClassA[ ] result = list.toArray(new ClassA[0]);<break/>

					<delay>2</delay>
					A zero length array is still an instance of Object which holds zero elements.

					<delay>2</delay>
				</li>
				<li>
					
					Another case when a zero length array is useful is when copying a two dimensional array.
					<delay>2</delay>
					I can write:
public int[][] copyArray(int[][] array){<break/>     int[][] newArray = new int[array.length][0];<break/>     for(int i=0;i&lt;array.length;i++){<break/>         newArray[i] = array[i];<break/>     }<break/>     return newArray;<break/>
Being that every array reference in array is being overwritten, initializing them as refernces to zero length arrays
					<delay>2</delay>
					is most efficient.

					<delay>2</delay>
				</li>
				<li>
					
					0-length byte[], or char[] can represent an empty String, which is distinct from null.
					<delay>2</delay>
					Getting the bytes, or characters, as arrays from strings (using getBytes(), getChars() of String class etc.)
					<delay>2</delay>
					and the vice-versa of forming Strings from byte[], byte[]0 is quite common.
					<delay>2</delay>
					For example, for custom encoding, decoding of strings. 

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java allow arrays ^ size 0 </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Array handling Algorithms -->
			^ array handling algorithms 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					This was recently covered on the ihas1337code blog.
					<delay>2</delay>
					See the comments section for solutions.

					<delay>2</delay>
					Essentially the most efficient way to solve this is to put the numbers in a hash_map and then loop through the array a second time checking each element x
					<delay>2</delay>
					if element (N - x) exists in the hash_map. 

					<delay>2</delay>
					You can optimize a bit from there, but that is the general idea.

					<delay>2</delay>
				</li>
				<li>
					
					Follow these steps:
1.Sort
					<delay>2</delay>
					the numbers using merge sort in O(n logn) in descending order(can be ascending also but for this text assumed them to be sorted in desceending order).

					<delay>2</delay>
					2.Use two pointer variables one pointing to starting element (say p1) and other pointing to last element( say p2).

					<delay>2</delay>
					3.Now add *p1 + *p2 ( temp_sum= *p1 + *p2 ) and compare it with required sum 
Repeat these steps untill p1>p2 
i.
					<delay>2</delay>
					If sum ==
					<delay>2</delay>
					temp_sum  
					<delay>2</delay>
					then our job is over .

					<delay>2</delay>
					ii.
					<delay>2</delay>
					If sum > temp_sum then decrease p2 to make it point to a bigger value then its current value so that temp_sum can increase.

					<delay>2</delay>
					iii.
					<delay>2</delay>
					If sum &lt; temp_sum then decrease p1 to make it point to a smaller value then its current value so that temp_sum can decrease.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ array handling algorithms </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- deepHashCode with byte array -->
			^ deephashcode ^ byte array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					First off, no need for "Deep".
					<delay>2</delay>
					It's a primitive.
					<delay>2</delay>
					You don't need Deep.

					<delay>2</delay>
					Just use Arrays.hashCode(byte[] yourArray)
Edit: To clarify, Deep implies delving into the Objects contained within the array.
					<delay>2</delay>
					Given that you are dealing with a primitive, you just need to use the primitive value itself in the calculation.
					<delay>2</delay>
					That's why none of the Deep methods revolve around primitives.

					<delay>2</delay>
				</li>
				<li>
					
					Using deepHashCode is indeed correct if you want two byte arrays containing the same bytes to have equivalent hash codes, you just need some additional casting for the byte[] array.

					<delay>2</delay>
					import java.utils.Arrays;<break/>public class A {<break/>  public static void main(String[] args) {<break/>    byte[] a = {10,32,-43,80};<break/>    byte[] b = {13,-40};<break/>    byte[] c = {10,32,-43,80};<break/>    // A and C will have different hash codes<break/>    System.out.println(a.hashCode());<break/>    System.out.println(b.hashCode());<break/>    System.out.println(c.hashCode());<break/>    // A and C will now have equivalent hash codes<break/>    System.out.println(Arrays.deepHashCode(new Object[]{a}));<break/>    System.out.println(Arrays.deepHashCode(new Object[]{b}));<break/>    System.out.println(Arrays.deepHashCode(new Object[]{c}));<break/>  }<break/>}<break/>

					<delay>2</delay>
					This results in output similar to...
// Hash Codes<break/>a = 16130931<break/>b = 26315233<break/>c = 32716405<break/>// Deep hash codes<break/>a = 1250961<break/>b = 1355<break/>c = 1250961<break/>

					<delay>2</delay>
				</li>
				<li>
					
					The accepted answer is correct: using Arrays.hashCode gives identical results for byte[] with the same values.

					<delay>2</delay>
					Arrays.deepHashCode is necessary if you have a nested (deep) structure.

					<delay>2</delay>
					import java.util.Arrays;<break/>public class A {<break/>    public static void main(String[] args) {<break/>        byte[] a = {10, 32, -43, 80};<break/>        byte[] b = {13, -40};<break/>        byte[] c = {10, 32, -43, 80};<break/>        System.out.println("NOTE: A and C have identical values, B differs");<break/>        System.out.println("Using byte[].hashCode(): A and C have different hash codes");<break/>        System.out.println("a = " + a.hashCode());<break/>        System.out.println("b = " + b.hashCode());<break/>        System.out.println("c = " + c.hashCode());<break/>        System.out.println("Using Arrays.hashCode(): A and C have identical hash codes");<break/>        System.out.println("a = " + Arrays.hashCode(a));<break/>        System.out.println("b = " + Arrays.hashCode(b));<break/>        System.out.println("c = " + Arrays.hashCode(c));<break/>        System.out.println("Using Arrays.deepHashCode(): A and C have identical hash codes");<break/>        System.out.println("a = " + Arrays.deepHashCode(new Object[]{a}));<break/>        System.out.println("b = " + Arrays.deepHashCode(new Object[]{b}));<break/>        System.out.println("c = " + Arrays.deepHashCode(new Object[]{c}));<break/>    }<break/>}<break/>

					<delay>2</delay>
					This results in output:
NOTE: A and C have identical values, B differs<break/>Using byte[].hashCode(): A and C have different hash codes<break/>a = 141847843<break/>b = 329849131<break/>c = 1119051810<break/>Using Arrays.hashCode(): A and C have identical hash codes<break/>a = 1250930<break/>b = 1324<break/>c = 1250930<break/>Using Arrays.deepHashCode(): A and C have identical hash codes<break/>a = 1250961<break/>b = 1355<break/>c = 1250961<break/>

					<delay>2</delay>
					Here's an example of when Arrays.deepHashCode is necessary
import java.util.Arrays;<break/>public class B {<break/>    public static void main(String[] args) {<break/>        Object[] d = {"abc", "def", new String[]{"ghi"}};<break/>        Object[] e = {"abc", "def", new String[]{"ghi"}};<break/>        System.out.println("NOTE: D and E have identical nested values");<break/>        System.out.println("Using Object[].hashCode(): different");<break/>        System.out.println("d = " + d.hashCode());<break/>        System.out.println("f = " + e.hashCode());<break/>        System.out.println("Using Arrays.hashCode(): still different");<break/>        System.out.println("d = " + Arrays.hashCode(d));<break/>        System.out.println("e = " + Arrays.hashCode(e));<break/>        System.out.println("Using Arrays.deepHashCode(): identical");<break/>        System.out.println("d = " + Arrays.deepHashCode(d));<break/>        System.out.println("e = " + Arrays.deepHashCode(e));<break/>    }<break/>}<break/>
output:
NOTE: D and E have identical nested values<break/>Using Object[].hashCode(): different<break/>d = 241990244<break/>f = 1943487137<break/>Using Arrays.hashCode(): still different<break/>d = 1057745997<break/>e = 709187068<break/>Using Arrays.deepHashCode(): identical<break/>d = 95807651<break/>e = 95807651<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ deephashcode ^ byte array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Memory Address of Array - Java -->
			^ memory address ^ array ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You can't.
					<delay>2</delay>
					Java doesn't have direct memory access.

					<delay>2</delay>
				</li>
				<li>
					
					There is no programmer-realizable notion of an "address" in Java.  
					<delay>2</delay>
					In a language like C or C++, objects' identities are equated with
					<delay>2</delay>
					their address - two objects are the same object if they live in the same memory location.  
					<delay>2</delay>
					In Java, this notion of identity is decoupled from the object's address.  
					<delay>2</delay>
					This allows some optimizations that are not possible in C++.  
					<delay>2</delay>
					For example, the garbage collector could, in theory, move objects around in memory to avoid fragmentation, so long as it modifies references so they point to the right location.  
					<delay>2</delay>
					Because memory addresses can't be accessed directly by the programmer, this operation is permissible.  
					<delay>2</delay>
					In C++, it wouldn't work, because the compiler couldn't tell if a particular bit pattern in memory was some sort of encoded pointer.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ memory address ^ array ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Android opengl modify vertex array after draw call -->
			^ android opengl modify vertex array ^ draw call 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					It's not bad practice if you modify the vertex array when you draw it as ordinary vertex array.

					<delay>2</delay>
					It's bad practice to modify the vertex array if you use vertex buffer objects in your draw method.
					<delay>2</delay>
					That's because you have to reupload it to your VRAM once it is edited.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ android opengl modify vertex array ^ draw call </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- In Java, do primitive types and arrays have a containing package? -->
			^ java ^ primitive types ^ arrays ^ containing package 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					No they don't have,as they aren't class.

					<delay>2</delay>
					Primitive  
					<delay>2</delay>
					: A primitive type is predefined by the language and is named by a reserved keyword. 

					<delay>2</delay>
					array :
					<delay>2</delay>
					An array is a container object that holds a fixed number of values of a single type.

					<delay>2</delay>
				</li>
				<li>
					
					Simple Answer
Let's test:
public static void main(final String[] args){<break/>    System.out.println(long.class.getPackage());<break/>    System.out.println(Object[].class.getPackage());<break/>}<break/>
Output:
  null
  null  

					<delay>2</delay>
					No they don't :-)

					<delay>2</delay>
					Primitive Types
Primitive classes are special constructs that don't have a package.
					<delay>2</delay>
					For reference, see the source of Long.TYPE, the alias for long.class:
/**<break/> * The &lt;code&gt;Class&lt;/code&gt; instance representing the primitive type<break/> * &lt;code&gt;long&lt;/code&gt;.<break/> *<break/> * @since   JDK1.1<break/> */<break/>public static final Class&lt;Long&gt; TYPE =<break/>       (Class&lt;Long&gt;) Class.getPrimitiveClass("long");<break/>
As you can see, a primitive class is loaded through a package-private and native mechanism:

					<delay>2</delay>
					static native Class getPrimitiveClass(String name);<break/>
and casted to Class&lt;Long&gt; (in order to enable auto-boxing, I guess)
Wrapper Types and their Primitive Types

					<delay>2</delay>
					BTW: every wrapper class has a static final field called TYPE that maps to the corresponding primitive class, as the following code shows:
private static Class&lt;?&gt; getPrimitiveClass(final Class&lt;?&gt; wrapperClass){<break/>    try{<break/>        final Field field = wrapperClass.getDeclaredField("TYPE");<break/>        final int modifiers = field.getModifiers();<break/>        if(Modifier.isPublic(modifiers) &amp;&amp; Modifier.isStatic(modifiers)<break/>            &amp;&amp; Modifier.isFinal(modifiers)<break/>            &amp;&amp; Class.class.equals(field.getType())){<break/>            return (Class&lt;?&gt;) field.get(null);<break/>        } else{<break/>            throw new IllegalArgumentException("This is not a wrapper class: "<break/>                + wrapperClass);<break/>        }<break/>    } catch(final NoSuchFieldException e){<break/>        throw new IllegalArgumentException("This is not a wrapper class:"<break/>            + wrapperClass + ", field TYPE doesn't exists.", e);<break/>    } catch(final IllegalAccessException e){<break/>        throw new IllegalArgumentException("This is not a wrapper class:"<break/>            + wrapperClass + ", field TYPE can't be accessed.", e);<break/>    }<break/>}<break/>public static void main(final String[] args){<break/>    final List&lt;Class&lt;?&gt;&gt; wrappers =<break/>        Arrays.&lt;Class&lt;?&gt;&gt; asList(<break/>            Byte.class, Long.class, Integer.class,<break/>            Short.class, Boolean.class, Double.class<break/>            // etc.<break/>        );<break/>    for(final Class&lt;?&gt; clazz : wrappers){<break/>        System.out.println("Wrapper type: " + clazz.getName()<break/>            + ", primitive type: "<break/>            + getPrimitiveClass(clazz).getCanonicalName());<break/>    }<break/>}<break/>
Output:
  Wrapper type: java.lang.Byte, primitive type:
					<delay>2</delay>
					byte
  Wrapper type: java.lang.Long, primitive type:
					<delay>2</delay>
					long
  Wrapper type: java.lang.Integer, primitive type:
					<delay>2</delay>
					int
  Wrapper type:
					<delay>2</delay>
					java.lang.Short, primitive type:
					<delay>2</delay>
					short
  Wrapper type:
					<delay>2</delay>
					java.lang.Boolean, primitive type:
					<delay>2</delay>
					boolean
  Wrapper type:
					<delay>2</delay>
					java.lang.Double, primitive type:
					<delay>2</delay>
					double  
Array Types
Arrays can be created through Array.newInstance(type, length), which internally calls this method:
public static void main(final String[] args){<break/>    System.out.println(long.class.getPackage());<break/>    System.out.println(Object[].class.getPackage());<break/>}<break/>0
so again, the classes are special constructs created by native code (and they don't have a package, or else you could find them somewhere)

					<delay>2</delay>
				</li>
				<li>
					
					No, but there are objects to wrap primitive data types in the java.lang package. 

					<delay>2</delay>
					http://download.oracle.com/javase/6/docs/api/java/lang/package-summary.html

					<delay>2</delay>
				</li>
				<li>
					
					No since they are language constructs and not classes per-se. 

					<delay>2</delay>
					You can however have a class representing a primitive type in the wrapper for instance:
Integer.
					<delay>2</delay>
					TYPE et al.
					<delay>2</delay>
					useful for reflection. 

					<delay>2</delay>
					But you'll see that still those don't have a package ie.

					<delay>2</delay>
					Integer.TYPE.getPackage()<break/>
Returns null

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java ^ primitive types ^ arrays ^ containing package </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Can you extend ArrayList in Java? -->
			^ extend arraylist ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You can extend any class that is not final in Java.
					<delay>2</delay>
					Having said that, you should avoid inheritance if there is no true is-a relationship.
					<delay>2</delay>
					Consider composition for reuse.
					<delay>2</delay>
					Read about Liskov substitution principle

					<delay>2</delay>
				</li>
				<li>
					
					Just try it out.
					<delay>2</delay>
					The class is not final, it's constructor is public, so you can.
					<delay>2</delay>
					However, it's probably no good idea for a beginner.

					<delay>2</delay>
					Most of the time, it's no good idea for anyone.
					<delay>2</delay>
					Imagine you add some functionality and get ExtList1 extends ArrayList.
					<delay>2</delay>
					A college of yours adds a different independent functionality, so you have ExtList2 extends ArrayList.
					<delay>2</delay>
					Now you want them both at once
					<delay>2</delay>
					and you're out of luck.

					<delay>2</delay>
					Or you need the same feature with a different base list implementation (maybe LinkedList, though it's virtually always wrong to use it).
					<delay>2</delay>
					Again, out of luck.

					<delay>2</delay>
					These are all cases when delegation wins.
					<delay>2</delay>
					It needn't be more verbose when someone has created the base already.

					<delay>2</delay>
					I'd only inherit from ArrayList, if there was a very good reason for doing exactly this.
					<delay>2</delay>
					Maybe some really extreme performance requirements based on proper JMH benchmarks.

					<delay>2</delay>
				</li>
				<li>
					
					Yes you can.

					<delay>2</delay>
					public class MyArrayList&lt;E&gt; extends ArrayList&lt;E&gt;<break/>{<break/>}<break/>

					<delay>2</delay>
					However, I'm not sure why you would want to do this.

					<delay>2</delay>
				</li>
				<li>
					
					ArrayList is not final class and it provides public constructor, so technically it can be extended.

					<delay>2</delay>
					But best practice is delegate rather than extend.

					<delay>2</delay>
					See: Decorator pattern

					<delay>2</delay>
				</li>
				<li>
					
					As many other have said, yes, you can extend class ArrayList, but it is not something that you should normally do; it is not considered good practice in Java.

					<delay>2</delay>
					I'm mainly a Java programmer, but the past months I've also been working on C# code.
					<delay>2</delay>
					It seems like it's a common idiom in C# to extend the standard collection classes if you need a collection of a specific type (I actually don't know if it is a common idiom in general -
					<delay>2</delay>
					at least the people who wrote the code I'm working with are doing this all the time).

					<delay>2</delay>
					So if they have a class Person and they need a list of persons, they'd create a class PersonList that extends the C# equivalent of ArrayList&lt;Person&gt;.

					<delay>2</delay>
					The common idiom in Java would just to use ArrayList&lt;Person&gt; if you need a list of Person objects and not to create a specific subclass for this.

					<delay>2</delay>
					I'd advise you to stick to the common Java way of doing things, and not create your own subclasses of ArrayList or other collection classes.

					<delay>2</delay>
				</li>
				<li>
					
					As others said, extending java lang data structures is a very bad idea.

					<delay>2</delay>
					However, if you have some logic you want to isolate in a collection class, I would suggest bellow solution:
public class ProductCollection{<break/>    ArrayList&lt;Product&gt; products;<break/>    public Product getByCode(String code) {<break/>       // ... your logic goes here.<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ extend arraylist ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java getting array keys -->
			^ java getting array keys 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					The Map collection has a keySet() method, and I think that's the closest thing to PHP's associative arrays in Java. 

					<delay>2</delay>
				</li>
				<li>
					
					Well, in Java I think the only way to have non integer keys is to use the Map class:
http://download.oracle.com/javase/6/docs/api/java/util/Map.html

					<delay>2</delay>
					And as you can see it has a keySet function.

					<delay>2</delay>
				</li>
				<li>
					
					http://download.oracle.com/javase/1.4.2/docs/api/java/util/HashMap.html#keySet()
This returns you a Java Set of the keys :)
Another way is to iterate the Map and store the keys in Array/ArrayList

					<delay>2</delay>
				</li>
				<li>
					
					Let me see if got this right, i know that php arrays have keys and values, nevertheless in java thins does not work like that arrays and list
					<delay>2</delay>
					are index base, this means that your keys are just index in natural order.
					<delay>2</delay>
					if you can shared some code to look what do you exactly need that would be perfect, but in the mean time you might use Map
 Map&lt;String,String&gt; hashMap = new HashMap&lt;String,String&gt;();<break/> hashMap.put("Key1","Value1");<break/> hashMap.put("Key2","Value2");<break/> hashMap.put("Key3","Value3");<break/> hashMap.put("Key4","Value4");<break/>
then you can use keySet() method to get the keys.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java getting array keys </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Where is Java's Array indexOf? -->
			^ java ^ array indexof 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Java ArrayList has an indexOf method.  
					<delay>2</delay>
					Java arrays have no such method.

					<delay>2</delay>
				</li>
				<li>
					
					You're probably thinking of the java.util.ArrayList, not the array.

					<delay>2</delay>
				</li>
				<li>
					
					Arrays themselves do not have that method.  
					<delay>2</delay>
					A List, however, does:
indexOf

					<delay>2</delay>
				</li>
				<li>
					
					I don't recall of a "indexOf" on arrays other than coding it for yourself...
					<delay>2</delay>
					though you could probably use one of the many java.util.Arrays#binarySearch(...) methods (see the Arrays javadoc) if your array contains primitive types

					<delay>2</delay>
				</li>
				<li>
					
					The List interface has an indexOf() method, and you can obtain a List from your array with Array's asList() method.
					<delay>2</delay>
					Other than that, Array itself has no such method.
					<delay>2</delay>
					It does have a binarySearch() method for sorted arrays.

					<delay>2</delay>
				</li>
				<li>
					
					There are a couple of ways to accomplish this using the Arrays utility class.

					<delay>2</delay>
					If the array is not sorted and is not an array of primitives:
java.util.Arrays.asList(theArray).indexOf(o)<break/>

					<delay>2</delay>
					If the array is primitives and not sorted, one should use a solution offered by one of the other answers such as Kerem Baydoğan's, Andrew McKinlay's or Mishax's.  
					<delay>2</delay>
					The above code will compile even if theArray is primitive (possibly emitting a warning) but you'll get totally incorrect results nonetheless.

					<delay>2</delay>
					If the array is sorted, you can make use of a binary search for performance:
java.util.Arrays.binarySearch(theArray, o)<break/>

					<delay>2</delay>
				</li>
				<li>
					
					There is none.
					<delay>2</delay>
					Either use a java.util.List*, or you can write your own indexOf():

					<delay>2</delay>
					public static &lt;T&gt; int indexOf(T needle, T[] haystack)<break/>{<break/>    for (int i=0; i&lt;haystack.length; i++)<break/>    {<break/>        if (haystack[i] != null &amp;&amp; haystack[i].equals(needle)<break/>            || needle == null &amp;&amp; haystack[i] == null) return i;<break/>    }<break/>    return -1;<break/>}<break/>

					<delay>2</delay>
					*you can make one from your array using Arrays#asList()

					<delay>2</delay>
				</li>
				<li>
					
					Array has no indexOf() method.

					<delay>2</delay>
					Maybe this Apache Commons Lang ArrayUtils method is what you are looking for
import org.apache.commons.lang3.ArrayUtils;<break/>String[] colours = { "Red", "Orange", "Yellow", "Green" };<break/>int indexOfYellow = ArrayUtils.indexOf(colours, "Yellow");<break/>

					<delay>2</delay>
				</li>
				<li>
					
					For primitives, if you want to avoid boxing, Guava has helpers for primitive arrays
					<delay>2</delay>
					e.g. Ints.indexOf(int[] array, int target)

					<delay>2</delay>
				</li>
				<li>
					
					Unlike in C# where you have the Array.
					<delay>2</delay>
					IndexOf method, and JavaScript where you have the indexOf method, Java's API (the Array and Arrays classes in particular) have no such method. 

					<delay>2</delay>
					This method indexOf (together with its complement lastIndexOf) is defined in the java.util.List interface.
					<delay>2</delay>
					Note that indexOf and lastIndexOf are not overloaded and only take an Object as a parameter.

					<delay>2</delay>
					If your array is sorted, you are in luck because the Arrays class defines a series of overloads of the binarySearch method that will find the index of the element you are looking for with best possible performance (O(log n) instead of O(n)
					<delay>2</delay>
					, the latter being what you can expect from a sequential search done by indexOf).
					<delay>2</delay>
					There are four considerations:

					<delay>2</delay>
					The array must be sorted either in natural order or in the order of a Comparator that you provide as an argument, or at the very least all elements that are "less than" the key must come before that element in the array and all elements that are "greater than" the key must come after that element in the array;

					<delay>2</delay>
					The test you normally do with indexOf to determine if a key is in the array (verify if the return value is not -1) does not hold with binarySearch.
					<delay>2</delay>
					You need to verify that the return value is not less than zero since the value returned will indicate the key is not present but the index at which it would be expected if it did exist;
If your array contains multiple elements that are equal to the key, what you get from binarySearch is undefined; this is different from indexOf that will return the first occurrence and lastIndexOf that will return the last occurrence.

					<delay>2</delay>
					An array of booleans might appear to be sorted if it first contains all falses and then all trues, but this doesn't count.
					<delay>2</delay>
					There is no override of the binarySearch method that accepts an array of booleans and you'll have to do something clever there
					<delay>2</delay>
					if you want O(log n) performance when detecting where the first true appears in an array, for instance using an array of Booleans and the constants Boolean.
					<delay>2</delay>
					FALSE and Boolean.
					<delay>2</delay>
					TRUE.

					<delay>2</delay>
					If your array is not sorted and not primitive type, you can use List's indexOf and lastIndexOf methods by invoking the asList method of java.util.Arrays.
					<delay>2</delay>
					This method will return an AbstractList interface wrapper around your array.
					<delay>2</delay>
					It involves minimal overhead since it does not create a copy of the array.
					<delay>2</delay>
					As mentioned, this method is not overloaded so this will only work on arrays of reference types.

					<delay>2</delay>
					If your array is not sorted and the type of the array is primitive, you are out of luck with the Java API.
					<delay>2</delay>
					Write your own for loop, or your own static utility method, which will certainly have performance advantages over the asList approach that involves some overhead of an object instantiation.
					<delay>2</delay>
					In case you're concerned that writing a brute force for loop that iterates over all of the elements of the array is not an elegant solution, accept that that is exactly what the Java API is doing when you call indexOf.
					<delay>2</delay>
					You can make something like this:

					<delay>2</delay>
					public static int indexOfIntArray(int[] array, int key) {<break/>    int returnvalue = -1;<break/>    for (int i = 0; i &lt; array.length; ++i) {<break/>        if (key == array[i]) {<break/>            returnvalue = i;<break/>            break;<break/>        }<break/>    }<break/>    return returnvalue;<break/>}<break/>
If you want to avoid writing your own method here, consider using one from a development framework like Guava.
					<delay>2</delay>
					There you can find an implementation of indexOf and lastIndexOf. 

					<delay>2</delay>
				</li>
				<li>
					
					There is no direct indexOf function in java arrays.

					<delay>2</delay>
				</li>
				<li>
					
					int findIndex(int myElement, int[] someArray){<break/> int index = 0;<break/> for(int n: someArray){<break/>   if(myElement == n) return index;<break/>   else index++;<break/> }<break/>}<break/>
Note: you can use this method for arrays of type int
					<delay>2</delay>
					, you can also use this algorithm for other types with minor changes

					<delay>2</delay>
				</li>
				<li>
					
					Jeffrey Hantin's answer is good but it has some constraints, if its this do this or else to that...

					<delay>2</delay>
					You can write your own extension method and it always works the way you want.

					<delay>2</delay>
					Lists.indexOf(array, x -&gt; item == x); // compare in the way you want<break/>

					<delay>2</delay>
					And here is your extension
public final class Lists {<break/>    private Lists() {<break/>    }<break/>    public static &lt;T&gt; int indexOf(T[] array, Predicate&lt;T&gt; predicate) {<break/>        for (int i = 0; i &lt; array.length; i++) {<break/>            if (predicate.test(array[i])) return i;<break/>        }<break/>        return -1;<break/>    }<break/>    public static &lt;T&gt; int indexOf(List&lt;T&gt; list, Predicate&lt;T&gt; predicate) {<break/>        for (int i = 0; i &lt; list.size(); i++) {<break/>            if (predicate.test(list.get(i))) return i;<break/>        }<break/>        return -1;<break/>    }<break/>    public interface Predicate&lt;T&gt; {<break/>        boolean test(T t);<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java ^ array indexof </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java: Clob to byte[] -->
			^ java ^ clob 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Get the ASCII stream and then read from the stream into a byte array.
					<delay>2</delay>
					http://download.oracle.com/javase/1.4.2/docs/api/java/sql/Clob.html#getAsciiStream()

					<delay>2</delay>
				</li>
				<li>
					
					int length = clob.getLength();         <break/> byte[] array = new byte[length];       <break/> InputStream in = clob.getAsciiStream();       <break/> int offset = 0;        <break/> int n;        <break/> do      <break/>    n = in.read(array, offset, length - offset);        <break/> while (n != -1);<break/>
Try the above snippet of code for reading a clob into Byte array. 

					<delay>2</delay>
				</li>
				<li>
					
					with commons-io
byte[] data = IOUtils.toByteArray(clob.getAsciiStream());<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java ^ clob </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java: How to convert a String of Binary values to a Float and vice-versa? -->
			^ java ^ convert ^ string ^ binary values ^ float ^ vice ^ versa 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You can get the bit representation of a Java Float value using
Float.floatToIntBits(float f);<break/>

					<delay>2</delay>
					Once you have done that you can test each bit of the resulting int in turn, starting with the highest, and find out if it set, writing a '1' if it is set and
					<delay>2</delay>
					a '0' if not.

					<delay>2</delay>
				</li>
				<li>
					
					I'm not sure it is what you want, but here's a solution to have the binary representation of the IEEE 754 floating-point "double format" bit layout for a float
					<delay>2</delay>
					(it is basically the memory representation of a float) :

					<delay>2</delay>
					int intBits = Float.floatToIntBits(yourFloat); <break/>String binary = Integer.toBinaryString(intBits);<break/>

					<delay>2</delay>
					For the reverse procedure :
int intBits = Integer.parseInt(myString, 2);<break/>float myFloat = Float.intBitsToFloat(intBits);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Working sample:
class F { <break/>  public static void main( String ... args ) { <break/>    System.out.println(<break/>          Integer.toBinaryString( <break/>             Float.floatToIntBits(12345.12346f)<break/>          ) <break/>     );<break/>  }<break/>}<break/>
Output:
1000110010000001110010001111110<break/>

					<delay>2</delay>
				</li>
				<li>
					
					For signed Floats, use Long or BigInteger to parse the string.
					<delay>2</delay>
					Casting by int causes the digit at first of 32 bits be intepreted as sign digit.

					<delay>2</delay>
					procedure :
int intBits = Float.floatToIntBits(yourFloat); <break/>String binary = Integer.toBinaryString(intBits);<break/>
reverse procedure :
int intBits = new BigInteger(myString, 2).intValue();<break/>// int intBits = (int) Long.parseLong(myString, 2);<break/>float myFloat = Float.intBitsToFloat(intBits);<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java ^ convert ^ string ^ binary values ^ float ^ vice ^ versa </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Model a Rubix Cube in an Array Java -->
			^ model ^ rubix cube ^ array java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					The source code for this one is available:

					<delay>2</delay>
					 http://software.rubikscube.info/AnimCube/<break/>

					<delay>2</delay>
					Your in luck, it's Java.
					<delay>2</delay>
					:)

					<delay>2</delay>
					This paper shows different ways to model the cube -
http://portal.acm.org/citation.cfm?id=801107&amp;coll=portal&amp;dl=ACM
and another exploratory paper...
http://www.chilton.com/~jimw/rubik.html
but a simple answer would be a 3x3x3 array with 3 digits.

					<delay>2</delay>
				</li>
				<li>
					
					I wouldn't try a 1 dimensional array.
					<delay>2</delay>
					But you could have a 3 dimensional array.

					<delay>2</delay>
					And array of 3x3 arrays of each side.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ model ^ rubix cube ^ array java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to store arrayList into an array in java? -->
			^ store arraylist ^ array ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					List list = getList();<break/>Object[] array = new Object[list.size()];<break/>for (int i = 0; i &lt; list.size(); i++)<break/>{<break/>  array[i] = list.get(i);<break/>}<break/>

					<delay>2</delay>
					Or just use List#toArray()

					<delay>2</delay>
				</li>
				<li>
					
					That depends on what you want:
List&lt;String&gt; list = new ArrayList&lt;String&gt;();<break/>// add items to the list<break/>

					<delay>2</delay>
					Now if you want to store the list in an array, you can do one of these:
Object[] arrOfObjects = new Object[]{list};<break/>List&lt;?&gt;[] arrOfLists = new List&lt;?&gt;[]{list};<break/>

					<delay>2</delay>
					But if you want the list items in an array, do one of these:
Object[] arrayOfObjects = list.toArray();<break/>String[] arrayOfStrings = list.toArray(new String[list.size()]);<break/>
Reference:
Collection.toArray()
Collection.toArray(T[])

					<delay>2</delay>
				</li>
				<li>
					
					List&lt;Foo&gt; fooList = new ArrayList&lt;Foo&gt;();<break/>Foo[] fooArray = fooList.toArray(new Foo[0]);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					List list = new ArrayList();<break/>list.add("Blobbo");<break/>list.add("Cracked");<break/>list.add("Dumbo");<break/>// Convert a collection to Object[], which can store objects    <break/>Object[] ol = list.toArray();<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You mean you want to convert an ArrayList to an array?

					<delay>2</delay>
					Object[] array = new Object[list.size()];<break/>array = list.toArray(array);<break/>
Choose the appropriate class.

					<delay>2</delay>
				</li>
				<li>
					
					Try the generic method List.toArray():
List&lt;String&gt; list = Arrays.asList("Foo", "Bar", "Gah");<break/>String array[] = list.toArray(new String[list.size()]);<break/>// array = ["Foo", "Bar", "Gah"]<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If Type is known (aka not a generics parameter) and you want an Array of Type:
ArrayList&lt;Type&gt; list = ...;<break/>Type[] arr = list.toArray(new Type[list.size()]);<break/>
Otherwise
Object[] arr = list.toArray();<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ store arraylist ^ array ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Convert array of strings into a string in Java -->
			^ convert array ^ strings ^ string ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Try the Arrays.toString overloaded methods.

					<delay>2</delay>
					Or else, try this below generic implementation:
public static void main(String... args) throws Exception {<break/>    String[] array = {"ABC", "XYZ", "PQR"};<break/>    System.out.println(new Test().join(array, ", "));<break/>}<break/>public &lt;T&gt; String join(T[] array, String cement) {<break/>    StringBuilder builder = new StringBuilder();<break/>    if(array == null || array.length == 0) {<break/>        return null;<break/>    }<break/>    for (T t : array) {<break/>        builder.append(t).append(cement);<break/>    }<break/>    builder.delete(builder.length() - cement.length(), builder.length());<break/>    return builder.toString();<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Use Apache commons StringUtils.join().  
					<delay>2</delay>
					It takes an array, as a parameter (and also has overloads for Iterable and Iterator parameters) and calls toString() on each element (if it is not null) to get each elements string representation.  
					<delay>2</delay>
					Each elements string representation is then joined into one string with a separator in between if one is specified:
$
					<delay>2</delay>
					code_placeholder_5
Produces:
a-b-1<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You could do this, given an array a of primitive type:
StringBuffer result = new StringBuffer();<break/>for (int i = 0; i &lt; a.length; i++) {<break/>   result.append( a[i] );<break/>   //result.append( optional separator );<break/>}<break/>String mynewstring = result.toString();<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You want code which produce string from arrayList, 
Iterate through all elements in list and add it to your String result<break/>
you can do this in 2 ways: using String as result or StringBuffer/StringBuilder. 

					<delay>2</delay>
					Example:
String result = "";<break/>for (String s : list) {<break/>    result += s;<break/>}<break/>
...
					<delay>2</delay>
					but this isn't good practice because of performance reason.
					<delay>2</delay>
					Better is using StringBuffer (threads safe) or StringBuilder which are more appropriate to adding Strings

					<delay>2</delay>
				</li>
				<li>
					
					I like using Google's Guava Joiner for this, e.g.:
Joiner.on(", ").skipNulls().join("Harry", null, "Ron", "Hermione");<break/>
would produce the same String as:
new String("Harry, Ron, Hermione");<break/>
ETA: Java 8 has similar support now:

					<delay>2</delay>
					String.join(", ", "Harry", "Ron", "Hermione");<break/>
Can't see support for skipping null values, but that's easily worked around.

					<delay>2</delay>
				</li>
				<li>
					
					With control over the delimiter (Java 8+):
String str = String.join(&quot;,&quot;, arr);<break/>
...or &lt;8:
StringBuilder builder = new StringBuilder();<break/>for(String s : arr) {<break/>    builder.append(s);<break/>}<break/>String str = builder.toString();<break/>

					<delay>2</delay>
					Alternatively, if you just want a &quot;debug-style&quot; dump of an array:
String str = Arrays.toString(arr);<break/>

					<delay>2</delay>
					And if you're coming from the Android angle:
String str = TextUtils.join(&quot;,&quot;, arr);<break/>
You can modify the above depending on what characters, if any, you want in between strings.

					<delay>2</delay>
					You may see near identical code to the pre-Java 8 code but using StringBuffer - StringBuilder is a newer class that's not thread-safe, but therefore has better performance in a single thread because it does away with unneeded synchronization.
					<delay>2</delay>
					In short, you're better using StringBuilder in 99% of cases - functionality wise, the two are identical.

					<delay>2</delay>
					DON'T use a string and just append to it with +=
					<delay>2</delay>
					like some of the answers show here.
					<delay>2</delay>
					This sends the GC through the roof because you're creating and throwing away as many string objects as you have items in your array.
					<delay>2</delay>
					For small arrays you might not really notice the difference, but for large ones it can be orders of magnitude slower.

					<delay>2</delay>
				</li>
				<li>
					
					Try the Arrays.deepToString method.

					<delay>2</delay>
					Returns a string representation of the "deep contents" of the specified
     array.  
					<delay>2</delay>
					If the array contains other arrays as elements, the string
     representation contains their contents and so on.  
					<delay>2</delay>
					This method is
     designed for converting multidimensional arrays to strings

					<delay>2</delay>
				</li>
				<li>
					
					If you know how much elements the array has, a simple way is doing this:
String appendedString = "" + array[0] + "" + array[1] + "" + array[2] + "" + array[3]; <break/>

					<delay>2</delay>
				</li>
				<li>
					
					String[] strings = new String[25000];<break/>for (int i = 0; i &lt; 25000; i++) strings[i] = '1234567';<break/>String result;<break/>result = "";<break/>for (String s : strings) result += s;<break/>//linear +: 5s<break/>result = "";<break/>for (String s : strings) result = result.concat(s);<break/>//linear .concat: 2.5s<break/>result = String.join("", strings);<break/>//Java 8 .join: 3ms<break/>Public String join(String delimiter, String[] s)<break/>{<break/>    int ls = s.length;<break/>    switch (ls)<break/>    {<break/>        case 0: return "";<break/>        case 1: return s[0];<break/>        case 2: return s[0].concat(delimiter).concat(s[1]);<break/>        default:<break/>            int l1 = ls / 2;<break/>            String[] s1 = Arrays.copyOfRange(s, 0, l1); <break/>            String[] s2 = Arrays.copyOfRange(s, l1, ls); <break/>            return join(delimiter, s1).concat(delimiter).concat(join(delimiter, s2));<break/>    }<break/>}<break/>result = join("", strings);<break/>// Divide&amp;Conquer join: 7ms<break/>

					<delay>2</delay>
					If you don't have the choise but to use Java 6 or 7 then you should use Divide&amp;Conquer join.

					<delay>2</delay>
				</li>
				<li>
					
					Following is an example of Array to String conversion.
    
    
					<delay>2</delay>
					public class
					<delay>2</delay>
					ArrayToString
    {
        public static void main(String[] args)
        {
            
					<delay>2</delay>
					String[] strArray = new String[]{"Java", "PHP",
					<delay>2</delay>
					".NET
					<delay>2</delay>
					", "PERL", "C", "COBOL"};
        String newString = Arrays.toString(strArray);<break/>        newString = newString.substring(1, newString.length()-1);<break/>        System.out.println("New New String: " + newString);<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					From Java 8, the simplest way I think is:
    String[] array = { "cat", "mouse" };<break/>    String delimiter = "";<break/>    String result = String.join(delimiter, array);<break/>

					<delay>2</delay>
					This way you can choose an arbitrary delimiter.

					<delay>2</delay>
				</li>
				<li>
					
					String array[]={"one","two"};<break/>String s="";<break/>for(int i=0;i&lt;array.length;i++)<break/>{<break/>  s=s+array[i];<break/>}<break/>System.out.print(s);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Use Apache Commons' StringUtils library's join method.

					<delay>2</delay>
					String[] stringArray = {"a","b","c"};<break/>StringUtils.join(stringArray, ",");<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ convert array ^ strings ^ string ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Getting an array list of all images on SD card -->
			^ getting ^ array list ^ images ^ sd card 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You need to query the Image media store to retrieve the data.

					<delay>2</delay>
					Cursor c = managedQuery(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,<break/>                    new String[] { /*columns you want */, null, null, null);<break/>c.moveToFirst();<break/>while(!c.isLast()) {<break/>// add some data to your array list<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ getting ^ array list ^ images ^ sd card </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Why use two different algorithm for sorting arrays? -->
			^ use two different algorithm ^ sorting arrays 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Just a guess, but quicksort is O(n^2) in the worst case, while merge sort is stable (guaranteed O(n log n)).

					<delay>2</delay>
					The worst case for quicksort is triggered by equal values.. and equal primitives are identical, while "equal" objects may not be.

					<delay>2</delay>
				</li>
				<li>
					
					The reason for using mergesort is that they want a stable algorithm - e.g. where equal objects (by compareTo() or compare()) are at the same relative order as before.

					<delay>2</delay>
					For primitives, equality implies "non-distinguish-ability".
					<delay>2</delay>
					When sorting {5, 3, 5} to {3, 5, 5} it does not matter which of the fives was the first one before.

					<delay>2</delay>
					So we can use the quicker (and non-stable) quicksort algorithm here.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ use two different algorithm ^ sorting arrays </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Converting from HashSet to String[] -->
			^ converting ^ hashset 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					set.toArray(new String[set.size()]);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Answer of JB Nizet is correct, but in case you did this to transform to a CSV like string, with Java 8 you can now do:
Set&lt;String&gt; mySet = new HashSet&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;));<break/>System.out.println(String.join(&quot;, &quot;, mySet));<break/>Output is: a, b, c<break/>

					<delay>2</delay>
					This allows to bypass array notation (the []).

					<delay>2</delay>
				</li>
				<li>
					
					The JB Nizet's answer is correct.
					<delay>2</delay>
					In Java 15, the better answer is:
set.toArray(new String[0]); <break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ converting ^ hashset </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How does one convert a HashMap to a List in Java? -->
			^ one convert ^ hashmap ^ list ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					HashMap&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;();<break/>map.put (1, "Mark");<break/>map.put (2, "Tarryn");<break/>List&lt;String&gt; list = new ArrayList&lt;String&gt;(map.values());<break/>for (String s : list) {<break/>    System.out.println(s);<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Basically you should not mess the question with answer, because it is confusing. 

					<delay>2</delay>
					Then you could specify what convert mean and pick one of this solution
List&lt;Integer&gt; keyList = Collections.list(Collections.enumeration(map.keySet()));<break/>List&lt;String&gt; valueList = Collections.list(Collections.enumeration(map.values()));<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Assuming you have:
HashMap&lt;Key, Value&gt; map; // Assigned or populated somehow.<break/>
For a list of values:
List&lt;Value&gt; values = new ArrayList&lt;Value&gt;(map.values());<break/>
For a list of keys:

					<delay>2</delay>
					List&lt;Key&gt; keys = new ArrayList&lt;Key&gt;(map.keySet());<break/>
Note that the order of the keys and values will be unreliable with a HashMap; use a LinkedHashMap if you need to preserve one-to-one correspondence of key and value positions in their respective lists.

					<delay>2</delay>
				</li>
				<li>
					
					If you only want it to iterate over your HashMap, no need for a list:
HashMap&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;();<break/>map.put (1, "Mark");<break/>map.put (2, "Tarryn");<break/>for (String s : map.values()) {<break/>    System.out.println(s);<break/>}<break/>

					<delay>2</delay>
					Of course, if you want to modify your map structurally (i.e. more than only changing the value for an existing key) while iterating, then you better use the "copy to ArrayList" method, since otherwise you'll get a ConcurrentModificationException.
					<delay>2</delay>
					Or export as an array:
HashMap&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;();<break/>map.put (1, "Mark");<break/>map.put (2, "Tarryn");<break/>for (String s : map.values().toArray(new String[]{})) {<break/>    System.out.println(s);<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you wanna maintain the same order in your list, say:
your Map looks like:
map.put(1, "msg1")<break/>map.put(2, "msg2")<break/>map.put(3, "msg3")<break/>
and you want your list looks like

					<delay>2</delay>
					["msg1", "msg2", "msg3"]   // same order as the map<break/>

					<delay>2</delay>
					you will have to iterate through the Map:
// sort your map based on key, otherwise you will get IndexOutofBoundException<break/>Map&lt;String, String&gt; treeMap = new TreeMap&lt;String, String&gt;(map)<break/>List&lt;String&gt; list = new List&lt;String&gt;();<break/>for (treeMap.Entry&lt;Integer, String&gt; entry : treeMap.entrySet()) {<break/>    list.add(entry.getKey(), entry.getValue());<break/>}  <break/>

					<delay>2</delay>
				</li>
				<li>
					
					
  Collection Interface has 3 views
keySet
values

					<delay>2</delay>
					entrySet
Other have answered to to convert Hashmap into two lists of key and value.
					<delay>2</delay>
					Its perfectly correct
  My addition: How to convert "key-value pair" (aka entrySet)into list.

					<delay>2</delay>
					      Map m=new HashMap();<break/>          m.put(3, "dev2");<break/>          m.put(4, "dev3");<break/>      List&lt;Entry&gt; entryList = new ArrayList&lt;Entry&gt;(m.entrySet());<break/>      for (Entry s : entryList) {<break/>        System.out.println(s);<break/>      }<break/>
ArrayList has this constructor. 

					<delay>2</delay>
				</li>
				<li>
					
					Solution using Java 8 and Stream Api:
private static &lt;K, V&gt;  List&lt;V&gt; createListFromMapEntries (Map&lt;K, V&gt; map){<break/>        return map.values().stream().collect(Collectors.toList());<break/>    }<break/>

					<delay>2</delay>
					Usage: 
  public static void main (String[] args)<break/>    {<break/>        Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();<break/>        map.put(1, "one");<break/>        map.put(2, "two");<break/>        map.put(3, "three");<break/>        List&lt;String&gt; result = createListFromMapEntries(map);<break/>        result.forEach(System.out :: println);<break/>    }<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ one convert ^ hashmap ^ list ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Converting char[] to byte[] -->
			
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					char[] ch = ?<break/>new String(ch).getBytes();<break/>
or
new String(ch).getBytes("UTF-8");<break/>
to get non-default charset.

					<delay>2</delay>
					Update:
					<delay>2</delay>
					Since Java 7: new String(ch).getBytes(StandardCharsets.UTF_8);

					<delay>2</delay>
				</li>
				<li>
					
					Convert without creating String object:
import java.nio.CharBuffer;<break/>import java.nio.ByteBuffer;<break/>import java.util.Arrays;<break/>byte[] toBytes(char[] chars) {<break/>  CharBuffer charBuffer = CharBuffer.wrap(chars);<break/>  ByteBuffer byteBuffer = Charset.forName("UTF-8").encode(charBuffer);<break/>  byte[] bytes = Arrays.copyOfRange(byteBuffer.array(),<break/>            byteBuffer.position(), byteBuffer.limit());<break/>  Arrays.fill(byteBuffer.array(), (byte) 0); // clear sensitive data<break/>  return bytes;<break/>}<break/>
Usage:

					<delay>2</delay>
					char[] chars = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};<break/>byte[] bytes = toBytes(chars);<break/>/* do something with chars/bytes */<break/>Arrays.fill(chars, '\u0000'); // clear sensitive data<break/>Arrays.fill(bytes, (byte) 0); // clear sensitive data<break/>
Solution is inspired from Swing recommendation to store passwords in char[].
					<delay>2</delay>
					(See Why is char[] preferred over String for passwords?)
Remember not to write sensitive data to logs and ensure that JVM won't hold any references to it.

					<delay>2</delay>
					The code above is correct but not effective.
					<delay>2</delay>
					If you don't need performance but want security you can use it.
					<delay>2</delay>
					If security also not a goal then do simply String.getBytes.
					<delay>2</delay>
					Code above is not effective if you look down of implementation of encode in JDK.
					<delay>2</delay>
					Besides you need to copy arrays and create buffers.
					<delay>2</delay>
					Another way to convert is inline all code behind encode (example for UTF-8):

					<delay>2</delay>
					val xs: Array[Char] = "A ß € 嗨 𝄞 🙂".toArray<break/>val len = xs.length<break/>val ys: Array[Byte] = new Array(3 * len) // worst case<break/>var i = 0; var j = 0 // i for chars; j for bytes<break/>while (i &lt; len) { // fill ys with bytes<break/>  val c = xs(i)<break/>  if (c &lt; 0x80) {<break/>    ys(j) = c.toByte<break/>    i = i + 1<break/>    j = j + 1<break/>  } else if (c &lt; 0x800) {<break/>    ys(j) = (0xc0 | (c &gt;&gt; 6)).toByte<break/>    ys(j + 1) = (0x80 | (c &amp; 0x3f)).toByte<break/>    i = i + 1<break/>    j = j + 2<break/>  } else if (Character.isHighSurrogate(c)) {<break/>    if (len - i &lt; 2) throw new Exception("overflow")<break/>    val d = xs(i + 1)<break/>    val uc: Int = <break/>      if (Character.isLowSurrogate(d)) {<break/>        Character.toCodePoint(c, d)<break/>      } else {<break/>        throw new Exception("malformed")<break/>      }<break/>    ys(j) = (0xf0 | ((uc &gt;&gt; 18))).toByte<break/>    ys(j + 1) = (0x80 | ((uc &gt;&gt; 12) &amp; 0x3f)).toByte<break/>    ys(j + 2) = (0x80 | ((uc &gt;&gt;  6) &amp; 0x3f)).toByte<break/>    ys(j + 3) = (0x80 | (uc &amp; 0x3f)).toByte<break/>    i = i + 2 // 2 chars<break/>    j = j + 4<break/>  } else if (Character.isLowSurrogate(c)) {<break/>    throw new Exception("malformed")<break/>  } else {<break/>    ys(j) = (0xe0 | (c &gt;&gt; 12)).toByte<break/>    ys(j + 1) = (0x80 | ((c &gt;&gt; 6) &amp; 0x3f)).toByte<break/>    ys(j + 2) = (0x80 | (c &amp; 0x3f)).toByte<break/>    i = i + 1<break/>    j = j + 3<break/>  }<break/>}<break/>// check<break/>println(new String(ys, 0, j, "UTF-8"))<break/>
Excuse me for using Scala language.
					<delay>2</delay>
					If you have problems with converting this code to Java I can rewrite it.
					<delay>2</delay>
					What about performance always check on real data (with JMH for example).
					<delay>2</delay>
					This code looks very similar to what you can see in JDK[2] and Protobuf[3].

					<delay>2</delay>
				</li>
				<li>
					
					Edit: Andrey's answer has been updated so the following no longer applies.

					<delay>2</delay>
					Andrey's answer (the highest voted at the time of writing) is slightly
incorrect.
					<delay>2</delay>
					I would have added this as comment but I am not
reputable enough.

					<delay>2</delay>
					In Andrey's answer:
char[] chars = {'c', 'h', 'a', 'r', 's'}<break/>byte[] bytes = Charset.forName(&quot;UTF-8&quot;).encode(CharBuffer.wrap(chars)).array();<break/>
the call to array() may not return the desired value, for example:
char[] c = &quot;aaaaaaaaaa&quot;.toCharArray();<break/>System.out.println(Arrays.toString(Charset.forName(&quot;UTF-8&quot;).encode(CharBuffer.wrap(c)).array()));<break/>
output:
[97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 0]<break/>
As can be seen a zero byte has been added.
					<delay>2</delay>
					To avoid this use the following:
char[] c = &quot;aaaaaaaaaa&quot;.toCharArray();<break/>ByteBuffer bb = Charset.forName(&quot;UTF-8&quot;).encode(CharBuffer.wrap(c));<break/>byte[] b = new byte[bb.remaining()];<break/>bb.get(b);<break/>System.out.println(Arrays.toString(b));<break/>
output:
[97, 97, 97, 97, 97, 97, 97, 97, 97, 97]<break/>
As the answer also alluded to using passwords it might be worth
blanking out the array that backs the ByteBuffer (accessed via the
array() function):
ByteBuffer bb = Charset.forName(&quot;UTF-8&quot;).encode(CharBuffer.wrap(c));<break/>byte[] b = new byte[bb.remaining()];<break/>bb.get(b);<break/>blankOutByteArray(bb.array());<break/>System.out.println(Arrays.toString(b));<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You could make a method:
public byte[] toBytes(char[] data) {<break/>byte[] toRet = new byte[data.length];<break/>for(int i = 0; i &lt; toRet.length; i++) {<break/>toRet[i] = (byte) data[i];<break/>}<break/>return toRet;<break/>}<break/>
Hope this helps

					<delay>2</delay>
				</li>
				<li>
					
					private static byte[] charArrayToByteArray(char[] c_array) {<break/>        byte[] b_array = new byte[c_array.length];<break/>        for(int i= 0; i &lt; c_array.length; i++) {<break/>            b_array[i] = (byte)(0xFF &amp; (int)c_array[i]);<break/>        }<break/>        return b_array;<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback></postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- ArrayList replace element if exists at a given index? -->
			^ arraylist replace element ^ exists ^ given index 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					If you're going to be requiring different set functionaltiy, I'd advise extending ArrayList with your own class.
					<delay>2</delay>
					This way, you won't have to define your behavior in more than one place.

					<delay>2</delay>
					// You can come up with a more appropriate name<break/>public class SizeGenerousArrayList&lt;E&gt; extends java.util.ArrayList&lt;E&gt; {<break/>    @Override<break/>    public E set(int index, E element) {<break/>        this.ensureCapacity(index+1); // make sure we have room to set at index<break/>        return super.set(index,element); // now go as normal<break/>    }<break/>    // all other methods aren't defined, so they use ArrayList's version by default<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					An element is over-written if it already exists at an index, that is the default behaviour: Javadoc.

					<delay>2</delay>
					Or am I missing your point completely?

					<delay>2</delay>
				</li>
				<li>
					
					  arrayList.set(index i,String replaceElement);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Just add a break after your remove() statement

					<delay>2</delay>
				</li>
				<li>
					
					just use this method inside arraylist
list.set(/*index*/,/*value*/)<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ arraylist replace element ^ exists ^ given index </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to create an array of 20 random bytes? -->
			^ create ^ array ^ 20 random bytes 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Try the Random.nextBytes method:
byte[] b = new byte[20];<break/>new Random().nextBytes(b);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you are already using Apache Commons Lang, the  RandomUtils  makes this a one-liner:

					<delay>2</delay>
					byte[] randomBytes = RandomUtils.nextBytes(20);<break/>
Note:
					<delay>2</delay>
					this does not produce cryptographically-secure bytes.

					<delay>2</delay>
				</li>
				<li>
					
					Create a Random object with a seed and get the array random by doing:
public static final int ARRAY_LENGTH = 20;<break/>byte[] byteArray = new byte[ARRAY_LENGTH];<break/>new Random(System.currentTimeMillis()).nextBytes(byteArray);<break/>// get fisrt element<break/>System.out.println("Random byte: " + byteArray[0]);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Java 7 introduced ThreadLocalRandom which is isolated to the current thread.

					<delay>2</delay>
					This is an another rendition of maerics's solution.

					<delay>2</delay>
					final byte[] bytes = new byte[20];<break/>ThreadLocalRandom.current().nextBytes(bytes);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you want a cryptographically strong random number generator (also thread safe) without using a third party API, you can use SecureRandom.

					<delay>2</delay>
					Java 6 &amp;
					<delay>2</delay>
					7:
SecureRandom random = new SecureRandom();<break/>byte[] bytes = new byte[20];<break/>random.nextBytes(bytes);<break/>
Java 8 (even more secure):
byte[] bytes = new byte[20];<break/>SecureRandom.getInstanceStrong().nextBytes(bytes);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					For those wanting a more secure way to create a random byte array, yes the most secure way is:
byte[] bytes = new byte[20];<break/>SecureRandom.getInstanceStrong().nextBytes(bytes);<break/>

					<delay>2</delay>
					BUT your threads might block if there is not enough randomness available on the machine, depending on your OS.
					<delay>2</delay>
					The following solution will not block:

					<delay>2</delay>
					SecureRandom random = new SecureRandom();<break/>byte[] bytes = new byte[20];<break/>random.nextBytes(bytes);<break/>

					<delay>2</delay>
					This is because the first example uses /dev/random and will block while waiting for more randomness (generated by a mouse/keyboard and other sources).
					<delay>2</delay>
					The second example uses /dev/urandom which will not block.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ create ^ array ^ 20 random bytes </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to convert a Java String to an ASCII byte array? -->
			^ convert ^ java string ^ ascii byte array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Using the getBytes method, giving it the appropriate Charset (or Charset name).

					<delay>2</delay>
					Example:
String s = "Hello, there.";<break/>byte[] b = s.getBytes(StandardCharsets.US_ASCII);<break/>
(Before Java 7: byte[] b = s.getBytes("US-ASCII");)

					<delay>2</delay>
				</li>
				<li>
					
					String s = "ASCII Text";<break/>byte[] bytes = s.getBytes("US-ASCII");<break/>

					<delay>2</delay>
				</li>
				<li>
					
					There is only one character wrong in the code you tried:
Charset characterSet = Charset.forName("US-ASCII");<break/>String string = "Wazzup";<break/>byte[] bytes = String.getBytes(characterSet);<break/>               ^<break/>
Notice the upper case "String".
					<delay>2</delay>
					This tries to invoke a static method on the string class, which does not exist.
					<delay>2</delay>
					Instead you need to invoke the method on your string instance:
byte[] bytes = string.getBytes(characterSet);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Convert string to ascii values.

					<delay>2</delay>
					   String test = "ABCD";<break/>   for ( int i = 0; i &lt; test.length(); ++i ) {<break/>   char c = test.charAt( i );<break/>   int j = (int) c;<break/>   System.out.println(j);<break/>   }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					The problem with other proposed solutions is that they will either drop characters that cannot be directly mapped to ASCII, or replace them with a marker character like ?. 

					<delay>2</delay>
					You might desire to have for example accented characters converted to that same character without the accent.
					<delay>2</delay>
					There are a couple of tricks to do this (including building a static mapping table yourself or leveraging existing 'normalization' defined for unicode), but those methods are far from complete.

					<delay>2</delay>
					Your best bet is using the junidecode library, which cannot be complete either but incorporates a lot of experience in the most sane way of transliterating Unicode to ASCII.

					<delay>2</delay>
				</li>
				<li>
					
					If you happen to need this in Android and want to make it work with anything older than FroYo, you can also use EncodingUtils.getAsciiBytes():
byte[] bytes = EncodingUtils.getAsciiBytes("ASCII Text");<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you are a guava user there is a handy Charsets class:
String s = "Hello, world!";<break/>byte[] b = s.getBytes(Charsets.US_ASCII);<break/>

					<delay>2</delay>
					Apart from not hard-coding arbitrary charset name in your source code it has a much bigger advantage:
					<delay>2</delay>
					Charsets.US_ASCII is of Charset type (not String)
					<delay>2</delay>
					so you avoid checked UnsupportedEncodingException thrown only from String.getBytes(String), but not from String.getBytes(Charset).

					<delay>2</delay>
					In Java 7 there is equivalent StandardCharsets class.

					<delay>2</delay>
				</li>
				<li>
					
					Try this:
/**<break/> * @(#)demo1.java<break/> *<break/> *<break/> * @author <break/> * @version 1.00 2012/8/30<break/> */<break/>import java.util.*;<break/>public class demo1 <break/>{<break/>    Scanner s=new Scanner(System.in);<break/>    String str;<break/>    int key;<break/>    void getdata()<break/>    {<break/>        System.out.println ("plase enter a string");<break/>        str=s.next();<break/>        System.out.println ("plase enter a key");<break/>        key=s.nextInt();<break/>    }<break/>    void display()<break/>    {<break/>        char a;<break/>        int j;<break/>        for ( int i = 0; i &lt; str.length(); ++i )<break/>        {<break/>            char c = str.charAt( i );<break/>            j = (int) c + key;<break/>            a= (char) j;<break/>            System.out.print(a);  <break/>        }<break/>        public static void main(String[] args)<break/>        {<break/>            demo1 obj=new demo1();<break/>            obj.getdata();<break/>            obj.display();<break/>        }<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					In my string I have Thai characters (TIS620 encoded) and German umlauts.
					<delay>2</delay>
					The answer from agiles put me on the right path.
					<delay>2</delay>
					Instead of .getBytes
					<delay>2</delay>
					() I use now
  int len = mString.length(); // Length of the string<break/>  byte[] dataset = new byte[len];<break/>  for (int i = 0; i &lt; len; ++i) {<break/>     char c = mString.charAt(i);<break/>     dataset[i]= (byte) c;<break/>  }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					I found the solution.
					<delay>2</delay>
					Actually Base64 class is not available in Android.
					<delay>2</delay>
					Link is given below for more information.

					<delay>2</delay>
					byte[] byteArray;                                                  <break/>     byteArray= json.getBytes(StandardCharsets.US_ASCII);<break/>    String encoded=Base64.encodeBytes(byteArray);<break/>    userLogin(encoded);<break/>
Here is the link for Base64 class:
					<delay>2</delay>
					http://androidcodemonkey.blogspot.com/2010/03/how-to-base64-encode-decode-android.html

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ convert ^ java string ^ ascii byte array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Byte array to image in J2ME? -->
			^ byte array ^ image ^ j2me 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Use createImage(byte[] imageData, int imageOffset, int imageLength)
					<delay>2</delay>
					an example can be seen here 

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ byte array ^ image ^ j2me </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How can I convert a String to a char array? -->
			^ convert ^ string ^ char array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Use String#toCharArray().

					<delay>2</delay>
					char[] chars = "some string".toCharArray();<break/>

					<delay>2</delay>
				</li>
				<li>
					
					"read java docs".toCharArray();<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Use the String.getChars() method.

					<delay>2</delay>
				</li>
				<li>
					
					Use the String.toCharArray() method.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ convert ^ string ^ char array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- sorting string arraylist in android -->
			^ sorting string arraylist ^ android 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					import java.util.Collections;
then use Collections.sort();

					<delay>2</delay>
				</li>
				<li>
					
					ArrayList&lt;String&gt; names = new ArrayList&lt;String&gt;();<break/>names =fillNames() // whatever method you need to fill here;<break/>Collections.sort(names);<break/>
http://download.oracle.com/javase/6/docs/api/java/util/Collections.html#sort%28java.util.List%29
  Sorts the specified list into ascending order, according to the natural ordering of its elements.
					<delay>2</delay>
					All elements in the list must implement the Comparable interface.
					<delay>2</delay>
					Furthermore, all elements in the list must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the list).

					<delay>2</delay>
					String implements Comparable:
  java.lang Class String
  
  java.lang.Object   extended by
  java.lang.String
  
  
					<delay>2</delay>
					All Implemented Interfaces:
      Serializable, CharSequence, Comparable
http://download.oracle.com/javase/6/docs/api/java/lang/String.html

					<delay>2</delay>
				</li>
				<li>
					
					Another solution but Collections.sort() is best.
					<delay>2</delay>
					I just want to show alternative
    ArrayList&lt;String&gt; strings = new ArrayList&lt;String&gt;();<break/>    strings.add("a");<break/>    strings.add("ab");<break/>    strings.add("aa");<break/>    String[] stringsArray = new String[strings.size()];<break/>    strings.toArray(stringsArray);<break/>    Arrays.sort(stringsArray);<break/>    List&lt;String&gt; sorted = Arrays.asList(stringsArray);<break/>    System.out.println(sorted);<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ sorting string arraylist ^ android </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Checking a column in 2-Dimensional Array -->
			^ checking ^ column ^ 2 ^ dimensional array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					If you want to check one column you need one loop, if you want to check N columns you need two nested loops.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ checking ^ column ^ 2 ^ dimensional array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- In Java: List, ArrayList and Map, HashMap -->
			^ java ^ list ^ arraylist ^ map ^ hashmap 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					List and Map are interfaces their implementations are ArrayList and HashMap 

					<delay>2</delay>
				</li>
				<li>
					
					Yes.
					<delay>2</delay>
					An ArrayList is a concrete implementation of a List, and a HashMap is a concrete implementation of a Map. 

					<delay>2</delay>
				</li>
				<li>
					
					If you're asking whether or not HashMap implements the Map interface, like ArrayList implements the List interface, then yes.

					<delay>2</delay>
					public class ArrayList&lt;E&gt;<break/>extends AbstractList&lt;E&gt;<break/>implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable<break/>public class HashMap<break/>extends AbstractMap<break/>implements Map, Cloneable, Serializable<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Yes.
					<delay>2</delay>
					Just as an ArrayList is an implementation of the List interface, similarly, HashMap is an implementation of the Map interface.

					<delay>2</delay>
				</li>
				<li>
					
					I believe an ArrayList implements the List interface and is a collection of objects which you can access using an index just like an 'array'.

					<delay>2</delay>
					HashMap implements the Map interface and maps keys to values just like a 'hashtable'. 

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java ^ list ^ arraylist ^ map ^ hashmap </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Converting String array to java.util.List -->
			^ converting string array ^ java ^ util ^ list 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Use the static List list = Arrays.asList(stringArray) or you could just iterate over the array and add the strings to the list.

					<delay>2</delay>
				</li>
				<li>
					
					List&lt;String&gt; strings = Arrays.asList(new String[]{"one", "two", "three"});<break/>

					<delay>2</delay>
					This is a list view of the array, the list is partly unmodifiable, you can't add or delete elements.
					<delay>2</delay>
					But the time complexity is O(1).

					<delay>2</delay>
					If you want a modifiable a List:
List&lt;String&gt; strings = <break/>     new ArrayList&lt;String&gt;(Arrays.asList(new String[]{"one", "two", "three"}));<break/>

					<delay>2</delay>
					This will copy all elements from the source array into a new list (complexity: O(n))

					<delay>2</delay>
				</li>
				<li>
					
					import java.util.Collections;<break/>List myList = new ArrayList();<break/>String[] myArray = new String[] {"Java", "Util", "List"};<break/>Collections.addAll(myList, myArray);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					First Step you need to create a list instance through Arrays.asList();
String[] args = new String[]{"one","two","three"};<break/>List&lt;String&gt; list = Arrays.asList(args);//it converts to immutable list<break/>

					<delay>2</delay>
					Then you need to pass 'list' instance to new ArrayList();
List&lt;String&gt; newList=new ArrayList&lt;&gt;(list);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					The Simplest approach: 
String[] stringArray = {"Hey", "Hi", "Hello"};<break/>List&lt;String&gt; list = Arrays.asList(stringArray);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					On Java 14 you can do this
List&lt;String&gt; strings = Arrays.asList(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					As of Java 8 and Stream API you can use Arrays.stream and Collectors.toList:
$
					<delay>2</delay>
					code_placeholder_3
This is practical especially if you intend to perform further operations on the list.

					<delay>2</delay>
					String[] array = new String[]{&quot;a&quot;, &quot;bb&quot;, &quot;ccc&quot;};<break/>List&lt;String&gt; list = Arrays.stream(array)<break/>                          .filter(str -&gt; str.length() &gt; 1)<break/>                          .map(str -&gt; str + &quot;!&quot;)<break/>                          .collect(Collectors.toList());<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ converting string array ^ java ^ util ^ list </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How can I get the unique elements of an unordered character array in Java? -->
			^ get ^ unique elements ^ unordered character array ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					One-liner:
Set&lt;Character&gt; uniqueChars = new HashSet&lt;Character&gt;(Arrays.asList(array));<break/>
(the array will need to be Character[] not char[].
					<delay>2</delay>
					Otherwise you'd have to convert it to the wrapper array)

					<delay>2</delay>
					Note that, if this is homework, you would need a more algorithmic approach in order to show that you understand what you are doing.
					<delay>2</delay>
					The above solution may not be applicable.
					<delay>2</delay>
					But here's how it works:
the array is turned into a List.
					<delay>2</delay>
					This is O(1), as the array just backs the new, unmodifiable list.
					<delay>2</delay>
					This is done so that the array can conform the the List interface, which is required by the HashSet constructor
a HashSet
					<delay>2</delay>
					is a collection backed by a Set&lt;Character&gt; uniqueChars = new HashSet&lt;Character&gt;(Arrays.asList(array));<break/>0 (hashtable).
					<delay>2</delay>
					It computes the hashes of keys and stores them in an internal array, under an index = hash.
					<delay>2</delay>
					Thus lookup is O(1).

					<delay>2</delay>
					the Set&lt;Character&gt; uniqueChars = new HashSet&lt;Character&gt;(Arrays.asList(array));<break/>1 constructor simply iterates the passed Set&lt;Character&gt; uniqueChars = new HashSet&lt;Character&gt;(Arrays.asList(array));<break/>2 and calls Set&lt;Character&gt; uniqueChars = new HashSet&lt;Character&gt;(Arrays.asList(array));<break/>3 for each item.
					<delay>2</delay>
					Items that are the same are not allowed twice in the set (sets by definition do not allow duplicates).
					<delay>2</delay>
					This is so, because the hash of the item will be the same as an existing one, so the new one will replace the old one.
					<delay>2</delay>
					Note that items with the same hash are allowed, but not those that are also equal (Set&lt;Character&gt; uniqueChars = new HashSet&lt;Character&gt;(Arrays.asList(array));<break/>4)

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ get ^ unique elements ^ unordered character array ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Is there any use of making an array final (immutable) in Java? -->
			^ use ^ making ^ array final ^ immutable ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					There may be several.
					<delay>2</delay>
					At least, it ensures that
later code cannot point the variable 'array' to another array 

					<delay>2</delay>
					the variable 'array' can be seen by anonymous inner classes (e.g. listeners).

					<delay>2</delay>
					Importantly, it does not ensure that the contents of 'array' are immutable.

					<delay>2</delay>
				</li>
				<li>
					
					It provides an invariant that the assignment of 'array' can't be changed.  
					<delay>2</delay>
					(When looking at code I can assume 'array' won't get reassigned).  
					<delay>2</delay>
					However nothing stops an element from being changed.  
					<delay>2</delay>
					Ex.
					<delay>2</delay>
					array[2] can be changed from 33 to 25.

					<delay>2</delay>
				</li>
				<li>
					
					The reasons are the same as with any other mutable type: the reference stays the same throughout the lifecycle of the declaring object, so you can distribute it freely for example.
					<delay>2</delay>
					final is always about the reference being fixed and not the contents, which might change.

					<delay>2</delay>
					With arrays, you even get a guarantee that the array size isn't going to change, although how useful that guarantee is depends on the specific use case.

					<delay>2</delay>
				</li>
				<li>
					
					You can't.
					<delay>2</delay>
					You can only declare the array reference final, which has nothing to do with making the array immutable.
					<delay>2</delay>
					Arrays are never immutable in Java.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ use ^ making ^ array final ^ immutable ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java: A two dimensional array is stored in column-major or row-major order? -->
			^ java ^ two dimensional array ^ stored ^ column ^ major ^ row ^ major order 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Neither.
					<delay>2</delay>
					What we may sometimes think of as two-dimensional array in Java is actually an array of references to arrays.
					<delay>2</delay>
					It's not stored linearly in memory. 

					<delay>2</delay>
					The Java Language specification notes this in the introduction:
  The language supports arrays of arrays, rather than multidimensional arrays.

					<delay>2</delay>
					This has several implications.

					<delay>2</delay>
					Arrays of arrays can be jagged -- member arrays can have different lengths.

					<delay>2</delay>
					The members of an outer array are references, and can be null.

					<delay>2</delay>
					Cloning an outer array is shallow -- the member arrays are shared between the original and the clone.

					<delay>2</delay>
					From the JLS, section 10.2, "Array Variables": 
  A single variable of array type may contain references to arrays of different lengths, because an array's length is not part of its type.

					<delay>2</delay>
					From the JLS, section 10.7, "Array Members":
  A clone of a multidimensional array is shallow, which is to say that it creates only a single new array.
					<delay>2</delay>
					Subarrays are shared.

					<delay>2</delay>
				</li>
				<li>
					
					Java doesn't have multi-dimensional arrays.
					<delay>2</delay>
					It has arrays of arrays.
					<delay>2</delay>
					So for instance,
int[][]<break/>
...is an array of int[] (and of course int[] is an array of int).

					<delay>2</delay>
					Consequently, Java is neither column-major nor row-major order (but see note below about how to read a[2][3]), because while a given array's entries are stored in a contiguous block of memory, the subordinate arrays those entries point to are object references to completely separate, unrelated blocks of memory.
					<delay>2</delay>
					This also means that Java's arrays of arrays are inherently jagged: The entry at [0] might refer to a 3-slot array, the one at [1] might refer to a 4-slot array, [2] might not refer to an array at all (it could have null), and perhaps int[][]<break/>0 refers to a 6-slot array.

					<delay>2</delay>
					A picture is worth 1k-24 words and all that:
                         
					<delay>2</delay>
					+−−−−−−−−+
                   
					<delay>2</delay>
					+−−−−>| int[]  |
+−−−−−−−−−−−+      
					<delay>2</delay>
					|     +−−−−−−−−+
|  int[]
					<delay>2</delay>
					[]  |      
					<delay>2</delay>
					|     | 0: int |
+−−−−−−−−−−−+      
					<delay>2</delay>
					|     | 1: int |
| 0: int[]  |−−−−−−+     | 2: int |
| 1: int[]  |−−−−−−+     +
					<delay>2</delay>
					−−−−−−−−+
| 2: null   |      |
| 3: int[]  
					<delay>2</delay>
					|−−+   |     +−−−−−−−−+
+−−−−−−−−−−−+  |   +−−−−>| int[]  |
               
					<delay>2</delay>
					|         +−−−−−−−−+
               
					<delay>2</delay>
					|         | 0: int |
               
					<delay>2</delay>
					|         | 1: int |
               
					<delay>2</delay>
					|         | 2: int |
               
					<delay>2</delay>
					|         | 3: int |
               
					<delay>2</delay>
					|         +−−−−−−−−+
               |
               
					<delay>2</delay>
					|         +−−−−−−−−+
               +−−−−−−−−−| int[]  |
                         
					<delay>2</delay>
					−−−−−−−−+
                         | 0: int |
                         | 1: int |
                         | 2: int |
                         | 3: int |
                         | 4: int |
                         | 5: int |
                         
					<delay>2</delay>
					+−−−−−−−−+
Once you know
					<delay>2</delay>
					that, you know that (say) int[][]<break/>1 means "Get the array referenced by the entry at index
					<delay>2</delay>
					int[][]<break/>2 of int[][]<break/>3, then get the entry referenced by index int[][]<break/>4 of that subordinate array.
					<delay>2</delay>
					" I think of it as fairly similar to row-major order, but it's not quite the same thing.

					<delay>2</delay>
				</li>
				<li>
					
					In Java, you only have one dimensional arrays.

					<delay>2</delay>
					2D arrays are basically just one dimensional arrays of one dimensional arrays.

					<delay>2</delay>
					int[ ][ ] table;<break/>table = new int[3][ ];<break/>table[0] = new int[5];<break/>table[1] = new int[5];<break/>table[2] = new int[5];<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java ^ two dimensional array ^ stored ^ column ^ major ^ row ^ major order </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to use a char array in java if the size is unknown? -->
			^ use ^ char array ^ java ^ size ^ unknown 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					In general, you can use a java.util.List when you don't know the size up front.

					<delay>2</delay>
					List&lt;Character&gt; chars = new ArrayList&lt;Character&gt;();<break/>chars.add('f');<break/>chars.add('o');<break/>chars.add('o');<break/>

					<delay>2</delay>
					Depending on your needs, a StringBuilder might make more sense than a List&lt;Character&gt;.

					<delay>2</delay>
					StringBuilder sb = new StringBuilder();<break/>sb.append('f')<break/>  .append('o')<break/>  .append('o');<break/>
If you want to get really slick, use Trove for its list-of-primitives so you can work with the (third-party equivalent of) a List&lt;char&gt;.
					<delay>2</delay>
					nevermind.
					<delay>2</delay>
					Trove does not have a TCharArrayList.

					<delay>2</delay>
				</li>
				<li>
					
					Can you use a String or a StringBuilder and then convert it to a char array later?

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ use ^ char array ^ java ^ size ^ unknown </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Write byte[] to File in Java -->
			^ file ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					A File object doesn't contain the content of the file.
					<delay>2</delay>
					It is only a pointer to the file on your hard drive (or other storage medium, like an SSD, USB drive, network share).
					<delay>2</delay>
					So I think what you want is writing it to the hard drive.

					<delay>2</delay>
					You have to write the file using some classes in the Java API
BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(yourFile));<break/>bos.write(fileBytes);<break/>bos.flush();<break/>bos.close();<break/>

					<delay>2</delay>
					You can also use a Writer instead of an OutputStream.
					<delay>2</delay>
					Using a writer will allow you to write text
					<delay>2</delay>
					(String, char[]).

					<delay>2</delay>
					BufferedWriter bw = new BufferedWriter(new FileWriter(yourFile));<break/>

					<delay>2</delay>
					Since you said you wanted to keep everything in memory and don't want to write anything, you might try to use ByteArrayInputStream.
					<delay>2</delay>
					This simulates an InputStream, which you can pass to the most of the classes.

					<delay>2</delay>
					ByteArrayInputStream bais = new ByteArrayInputStream(yourBytes);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Use a FileOutputStream.

					<delay>2</delay>
					FileOutputStream fos = new FileOutputStream(objFile);<break/>fos.write(objFileBytes);<break/>fos.close();<break/>

					<delay>2</delay>
				</li>
				<li>
					
					public void writeToFile(byte[] data, String fileName) throws IOException{<break/>  FileOutputStream out = new FileOutputStream(fileName);<break/>  out.write(data);<break/>  out.close();<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Ok, you asked for it:
File file = new File("myfile.txt");<break/>// convert File to byte[]<break/>ByteArrayOutputStream bos = new ByteArrayOutputStream();<break/>ObjectOutputStream oos = new ObjectOutputStream(bos);<break/>oos.writeObject(file);<break/>bos.close();<break/>oos.close();<break/>byte[] bytes = bos.toByteArray();<break/>// convert byte[] to File<break/>ByteArrayInputStream bis = new ByteArrayInputStream(bytes);<break/>ObjectInputStream ois = new ObjectInputStream(bis);<break/>File fileFromBytes = (File) ois.readObject();<break/>bis.close();<break/>ois.close();<break/>System.out.println(fileFromBytes);<break/>

					<delay>2</delay>
					But this is pointless.
					<delay>2</delay>
					Please specify what you are trying to achieve.

					<delay>2</delay>
				</li>
				<li>
					
					See How to render PDF in Android.
					<delay>2</delay>
					It looks like you may not have any option except saving the content to a (temporary) on the SD file in order to be able to display it in the pdf viewer.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ file ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- What is a List vs. an ArrayList? -->
			^ list vs ^ arraylist 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					List is in interface while ArrayList is a class.

					<delay>2</delay>
					See ArrayList, and List.

					<delay>2</delay>
					E.g, you can't use this setup:
List&lt;String&gt; list = new List&lt;String&gt;();...
					<delay>2</delay>
					Because it's an interface.

					<delay>2</delay>
					However, this works:
ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();
Also...
					<delay>2</delay>
					You can do as duffymo says below, which is more or less the same as implementing the List interface (making your own list implementation).

					<delay>2</delay>
				</li>
				<li>
					
					A List defines the interface that ArrayList uses, that allows it to implement methods that will allow all other classes that implement List to be used together or in a similar way.
					<delay>2</delay>
					An ArrayList is always also a List, but an List isn't necessarily an ArrayList.

					<delay>2</delay>
					That is, ArrayList implements List (among a few other interfaces).

					<delay>2</delay>
				</li>
				<li>
					
					List is an interface; ArrayList is a class that implements the List interface. 

					<delay>2</delay>
					Interfaces define the method signatures that are required, but say nothing about how they are implemented.  

					<delay>2</delay>
					Classes that implement an interface promise to provide public implementations of methods with the identical signatures declared by the interface.

					<delay>2</delay>
				</li>
				<li>
					
					According to the java docs, List is just an interface, and ArrayList is one of the classes that implement it.
					<delay>2</delay>
					There is no inherent efficiency advantage to using ArralyList specifically instead of List-typed references to an ArrayList object.

					<delay>2</delay>
					However, when it comes to "efficiency", there can be a difference between different implementations of the List interface.
					<delay>2</delay>
					For instance there can be  a small efficiency difference between a LinkedList and an ArrayList, depending on how you're using them.

					<delay>2</delay>
					To quote the java docs on the ArrayList page, 
  The add operation runs in amortized constant time, that is, adding n elements requires O(n) time.
					<delay>2</delay>
					All of the other operations run in linear time (roughly speaking).
					<delay>2</delay>
					The constant factor is low compared to that for the LinkedList implementation.

					<delay>2</delay>
					In other words, the performance difference will probably be negligible, but you may see some advantage from using an ArrayList (as opposed to a LinkedList).

					<delay>2</delay>
					In case you're interested, ArrayList is implemented with an array that is resized from time to time (most likely whenever your collection doubles in size), which is quite different from the implementation of a LinkedList (see wikipedia for details).

					<delay>2</delay>
				</li>
				<li>
					
					Consider a line like the following:
List&lt;String&gt; names = new ArrayList&lt;String&gt;();<break/>

					<delay>2</delay>
					If you're new to object-oriented architectures, you might have expected instead to see something like ArrayList&lt;String&gt; names = new ArrayList&lt;String&gt;();.
					<delay>2</delay>
					After all, you've just said that it's a new ArrayList, so shouldn't you store it in a variable of type ArrayList?

					<delay>2</delay>
					Well, you certainly can do that.
					<delay>2</delay>
					However, List is an interface--like a template of sorts--that ArrayList is said to inherit.
					<delay>2</delay>
					It is a contract that says "anytime you use a List implementation, you can expect these methods to be available".
					<delay>2</delay>
					In the case of List, the methods are things like add, List&lt;String&gt; names = new ArrayList&lt;String&gt;();<break/>0, etc.

					<delay>2</delay>
					But List&lt;String&gt; names = new ArrayList&lt;String&gt;();<break/>1 is only one implementation of List&lt;String&gt; names = new ArrayList&lt;String&gt;();<break/>2.
					<delay>2</delay>
					There are others, such as List&lt;String&gt; names = new ArrayList&lt;String&gt;();<break/>3.
					<delay>2</delay>
					The two have the same interface, and can be used the same way, but work very differently behind the scenes.
					<delay>2</delay>
					Where List&lt;String&gt; names = new ArrayList&lt;String&gt;();<break/>4 is "random" access, meaning that it directly finds a specific element of the array without iterating through the whole list, List&lt;String&gt; names = new ArrayList&lt;String&gt;();<break/>5 does have to start from the first element and go one-by-one until it gets to the element you need. 

					<delay>2</delay>
					The thing is, while you do need to specify which you want when you create the object, you generally only need to communicate no more than the fact that it is a List&lt;String&gt; names = new ArrayList&lt;String&gt;();<break/>6, so you simply say that's what it is.
					<delay>2</delay>
					List&lt;String&gt; names = new ArrayList&lt;String&gt;();<break/>7 communicates that you have a collection that is intended to be in the order that it is given.
					<delay>2</delay>
					If you don't need to communicate that much, you might consider passing it around as a List&lt;String&gt; names = new ArrayList&lt;String&gt;();<break/>8, which is another interface (a super-interface of List&lt;String&gt; names = new ArrayList&lt;String&gt;();<break/>9).
					<delay>2</delay>
					Or, if all you need to communicate is that you can iterate over it, you might even call it an ArrayList&lt;String&gt; names = new ArrayList&lt;String&gt;();0.

					<delay>2</delay>
				</li>
				<li>
					
					How to use List and ArrayList, or other implementation of List, is Polymorphism and Inheritance, and also the reason why for using languages such as Java. 

					<delay>2</delay>
					In simplicity, Polymorphism is many forms while Inheritance is reuse.

					<delay>2</delay>
					There can be many kinds of concrete and ready to us List that is available to you, such as ArrayList, Vector, LinkedList and Stack.
					<delay>2</delay>
					The decision to use which comes from you, and if you look at the List API, you would notice that all of these List implementations extend in one way or another from List.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ list vs ^ arraylist </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java XML to Array -->
			^ java xml ^ array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					have a look at xstream - http://x-stream.github.io/. Very easy to use library to convert XML into java objects.

					<delay>2</delay>
				</li>
				<li>
					
					No there isn't.
					<delay>2</delay>
					An XML is a tree datastructure that has no trivial translation to a flat array.

					<delay>2</delay>
					Of course you can write this function yourself, if you know what you want.
					<delay>2</delay>
					Also there are many 3rd party libraries that allow conversion from XML to Java objects, but it's hard to recommend one without knowing what your problem exactly is.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java xml ^ array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Can Java use String as an index array key? (ex: array["a"]=1;) -->
			^ java use string ^ index array key ^ ex 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					No.

					<delay>2</delay>
					To do something like this, you have to use a Map.

					<delay>2</delay>
					Map&lt;String, Integer&gt; aMap = new HashMap&lt;String, Integer&gt;();<break/>aMap.put("a" , Integer.valueOf(1));<break/>

					<delay>2</delay>
				</li>
				<li>
					
					No, that would be a Map in Java.

					<delay>2</delay>
					(The type would be Map&lt;String,Integer&gt;.)

					<delay>2</delay>
				</li>
				<li>
					
					No - you want a map to do that:
Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();<break/>map.put("a", 2);<break/>

					<delay>2</delay>
					Then to get it:

					<delay>2</delay>
					int val = map.get("a"); //2<break/>

					<delay>2</delay>
					You can only use the square bracket syntax for arrays, not for any of the collections.
					<delay>2</delay>
					So something like:
int val = map["a"]; //Compile error<break/>
Will always be illegal.
					<delay>2</delay>
					You have to use the get() method.

					<delay>2</delay>
				</li>
				<li>
					
					No they can't.
					<delay>2</delay>
					But they can use chars the ASCII value of the alphabet will be used as the key index
Consider
    String[] a = new String['a' + 1];<break/>    a['a'] = "Hello";<break/>    int[] b = new int['a' + 3];<break/>    b['c'] = 5;<break/>    System.out.println(a[97]);<break/>    System.out.print(b[99]);<break/>

					<delay>2</delay>
					This will output
Hello<break/>5<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java use string ^ index array key ^ ex </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to create base64Binary data? -->
			^ create base64binary data 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Try commons-codec with public static byte[] encodeBase64(byte[] binaryData).

					<delay>2</delay>
				</li>
				<li>
					
					To create such data you may use the JDK built-in class sun.misc.BASE64Encoder.
					<delay>2</delay>
					Unfortunately it's not public API since nobody cared to provide a BASE64 en-/decoder in the public API - but people often use this class to circumvent that disadvantage.

					<delay>2</delay>
					base64Binary is an XML Schema data type, referring to arbitrary binary data that is to be encoded using BASE64 encoding to retrieve a "safe" string representation of that data - e.g. for embedding binary data in XML, mails etc.

					<delay>2</delay>
					W3C Definition:
  
					<delay>2</delay>
					base64Binary represents Base64-encoded arbitrary binary data.
					<delay>2</delay>
					The ·value space· of base64Binary is the set of finite-length sequences of binary octets.
					<delay>2</delay>
					For base64Binary data the entire binary stream is encoded using the Base64 Alphabet in [RFC 2045]. 

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ create base64binary data </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- convert byte[] to Object File in Java -->
			^ object file ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					The File object is just a wrapper around the name for a real file on the disk.
					<delay>2</delay>
					It does not contain any data.
					<delay>2</delay>
					You will have to write your byte array into a file first.
					<delay>2</delay>
					After the API you then call is done, you can maybe delete that file again.
					<delay>2</delay>
					Search for how to manage temporary files in Java.

					<delay>2</delay>
				</li>
				<li>
					
					java has serilazebal interface to persistent  your object;
i guess u want custom serialize method, like c strct; 
refences :
https://github.com/MisterChangRay/magic-byte
http://code.google.com/p/javastruct/wiki/HowToUseJavaStruct

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ object file ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java Array of Bytes -->
			^ java array ^ bytes 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Not sure what you meant by resized and merged 
from the documentation:
  byte: The byte data type is an 8-bit signed two's complement integer.
					<delay>2</delay>
					It has a minimum value of -128 and a maximum value of 127 (inclusive).
					<delay>2</delay>
					The byte data type can be useful for saving memory in large arrays, where the memory savings actually matters.
					<delay>2</delay>
					They can also be used in place of int where their limits help to clarify your code; the fact that a variable's range is limited can serve as a form of documentation.

					<delay>2</delay>
					Edit: If by resized/merged you are talking about the array itself, there's nothing special about a byte array compared to other arrays.

					<delay>2</delay>
				</li>
				<li>
					
					There are two ways to allocate an array.

					<delay>2</delay>
					A) allocate an empty array of a given size:
byte[] ba1 = new byte[18]; // 18 elements<break/>
B) allocate an array by specifying the contents
byte[] ba2 = {1,2,3,4,5}; // 5 elements<break/>

					<delay>2</delay>
				</li>
				<li>
					
					The size would be a byte per element.

					<delay>2</delay>
					They can not be re-sized.
					<delay>2</delay>
					However you can merge them yourself using System.arrayCopy
					<delay>2</delay>
					() by creating a new array and copying your source arrays into the new array.

					<delay>2</delay>
					Edit 1:

					<delay>2</delay>
					There is also an 8-byte overhead for the object header and a 4-byte overhead for the array length, for a total overhead of 12 bytes.
					<delay>2</delay>
					So small arrays are relatively expensive.

					<delay>2</delay>
					Check out GNU Trove and Fastutil.
					<delay>2</delay>
					They are libraries that make working with primitive collections easier.

					<delay>2</delay>
					Edit 2:

					<delay>2</delay>
					I read in one of your response that you're doing object serialization.
					<delay>2</delay>
					You might be interested in ByteBuffers.
					<delay>2</delay>
					Those make it easy to write out various primitive types to a wrapped array and get the resulting array.
					<delay>2</delay>
					Also check out Google protocol buffers if you want easily serialized structured data types.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java array ^ bytes </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java:multidimensional array problem -->
			^ java ^ multidimensional array problem 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Sure. 
array.length;<break/>array[0].length;<break/>array[1].length;<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Yes.
					<delay>2</delay>
					Length dimensions vary from row to row.
					<delay>2</delay>
					You can do matrix[i].length to get the length of row i.
					<delay>2</delay>
					If you know the matrix is square, all the row lengths will equals matrix[0].length anyways, so it doesn't matter.

					<delay>2</delay>
					If you're trying to iterate through all elements:

					<delay>2</delay>
					for(int i = 0; i &lt; matrix.length; i++){<break/>    for(int j &lt; 0; j &lt; matrix[i].length; j++){<break/>        count += matrix[i][j];<break/>    }<break/>}<break/>
The same principle can be applied for any number of dimensions.
					<delay>2</delay>
					For loops, you need 1 nested loop per dimension.
					<delay>2</delay>
					For lengths, each bracketed part is actually a new element, so 3d array
					<delay>2</delay>
					ar will yield a 2d array with ar[i], 1d with ar[i][j], and 0d (single element of the array type) with ar[i][j][k]

					<delay>2</delay>
				</li>
				<li>
					
					Yes.
@Test<break/>public void test(){<break/>    long[][][] multi = new long[3][2][1];<break/>    System.out.println(multi.length); //3<break/>    System.out.println(multi[0].length); //2<break/>    System.out.println(multi[0][0].length); //1<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Well, no, you need array[0].length to get size of second dimension, and array[0][0].length to get length of third.
					<delay>2</delay>
					Of course, arrays are not matrices, so array[0].length and array[1].length might be different, depending on the sizes of the sub-arrays you stored at array[0] resp.
					<delay>2</delay>
					array[1]

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java ^ multidimensional array problem </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to read file bytes in Java? -->
			^ read file bytes ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					    byte ch;<break/>    try {<break/>      is = new DataInputStream(new FileInputStream("fileName.dat"));<break/>      while (true) { <break/>        ch = is.readByte();<break/>   // put here in any byte array ...<break/>        System.out.flush();<break/>      }<break/>    } <break/>

					<delay>2</delay>
				</li>
				<li>
					
					FileInputStream fis = new FileInputStream("your file name");<break/>byte[] bytes = new byte[100]; // replace 100 with the desired size, of course<break/>int offset = 0;               // which element to stuff the byte into  <break/>fis.read(bytes, offset, 1);   // the 1 is how many bytes to read<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ read file bytes ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Can you create a Java Iterator over a 2d array? -->
			^ create ^ java iterator ^ 2d array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Yes, wrap the array in an object and make the object implement the iterator interface.
					<delay>2</delay>
					So it can be done.
					<delay>2</delay>
					I am not aware of any such iterator that ships with the Jdk.

					<delay>2</delay>
				</li>
				<li>
					
					Yes, it can be done, as @Scorpion says.  
					<delay>2</delay>
					In fact, the solution is probably pretty simple: no more than 10 lines of executable code ...
					<delay>2</delay>
					if I correctly understand the problem.

					<delay>2</delay>
					No, there isn't a convenience method in the JDK to do this.  
					<delay>2</delay>
					And I'm not aware of one in any of the "commons" libraries.  
					<delay>2</delay>
					(Reason: this particular problem is too specialized to be useful to more than a handful of programmers.)

					<delay>2</delay>
					This should be a sufficient answer for you to go and implement the solution yourself.

					<delay>2</delay>
					Should
					<delay>2</delay>
					/ we provide you a potted solution?  
					<delay>2</delay>
					IMO, no.

					<delay>2</delay>
					StackOverflow is not a
					<delay>2</delay>
					"we write your code for free" service.

					<delay>2</delay>
					If you do it yourself you will learn more: read the excellent "What have you tried?"
					<delay>2</delay>
					blog article.

					<delay>2</delay>
					(And even if someone did feel like writing the code for you, you didn't give a clear enough description of the problem to implement ... without making lots of guesses.)

					<delay>2</delay>
				</li>
				<li>
					
					If you implement the Iterable interface, you can use a for-each loop.
					<delay>2</delay>
					Related examples may be found here. 

					<delay>2</delay>
				</li>
				<li>
					
					I dont see the need to make a single iterator when invoking the two from the arrays works just fine as per example:
int 2dArray[][];<break/>for(int 1dArray[]: 2dArray){<break/>    for(int i: 1dArray){<break/>        //do stuff<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					import java.util.LinkedList;<break/>import java.util.Queue;<break/>public class TwoDIterator {<break/>int[][] array;<break/>int outerCursor;<break/>int lastArrayLen;<break/>int totalElems;<break/>int tracker = 1;<break/>Queue&lt;Integer&gt; myQueue = new LinkedList&lt;&gt;();<break/>public TwoDIterator(int[][] arr) {<break/>    this.array = arr;<break/>    this.outerCursor = 0;<break/>    for (int i = 0; i &lt; arr.length; i++) {<break/>        for (int j = 0; j &lt; arr[i].length; j++) {<break/>            totalElems += 1;<break/>        }<break/>    }<break/>    for (int i = 0; i &lt; array[0].length; i++) {<break/>        myQueue.add(array[0][i]);<break/>    }<break/>}<break/>public boolean hasNext() {<break/>    return array.length &gt; outerCursor &amp;&amp; totalElems &gt;= tracker;<break/>}<break/>public Integer next() {<break/>    if (myQueue.isEmpty()) {<break/>        outerCursor++;<break/>        for (int i = 0; i &lt; array[outerCursor].length; i++) {<break/>            myQueue.add(array[outerCursor][i]);<break/>        }<break/>        if (!myQueue.isEmpty()) {<break/>            tracker++;<break/>            return myQueue.remove();<break/>        }<break/>    } else {<break/>        tracker++;<break/>        return myQueue.remove();<break/>    }<break/>    return -1;<break/>}<break/>public static void main(String[] args) {<break/>    int[][] arr = { { 1, 2, 3 }, { 1, 3 }, { 1, 2, 5 } };<break/>    TwoDIterator iter = new TwoDIterator(arr);<break/>    while (iter.hasNext()) {<break/>        System.out.println(iter.next());<break/>    }<break/>}<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ create ^ java iterator ^ 2d array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to assign a value to byte array -->
			^ assign ^ value ^ byte array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Either use char[] or String.  Make sure and get the includes for String.

					<delay>2</delay>
				</li>
				<li>
					
					That's a string literal.
					<delay>2</delay>
					If you're looking to get the binary representation of the string, use one of the String.getBytes methods.

					<delay>2</delay>
				</li>
				<li>
					
					If you're trying to assign hard-coded values, you can use:
byte[] bytes = { (byte) 204, 29, (byte) 207, (byte) 217 };<break/>
Note the cast because Java bytes are signed - the cast here will basically force the overflow to a negative value, which is probably what you want.

					<delay>2</delay>
					If you're actually trying to parse a string, you need to do that - split the string into parts and parse each one.

					<delay>2</delay>
					If you're trying to convert a string into its binary representation under some particular encoding, you should use String.getBytes, e.g.
byte[] abc = "204.29.207.217".getBytes("UTF-8");<break/>
(Note that conventionally the [] is put as part of the type of the variable, not after the variable name.
					<delay>2</delay>
					While the latter is allowed, it's discouraged as a matter of style.)

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ assign ^ value ^ byte array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java array declaration without hard coding the size -->
			^ java array declaration without hard coding ^ size 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Use a List.
					<delay>2</delay>
					The size does not need to be declared on creation of the List.
					<delay>2</delay>
					The toArray() method will return an array representation of the list.
					<delay>2</delay>
					There are multiple implementations you can use but the most popular tends to be ArrayList (though it is best to map the implementation to your particular situation).

					<delay>2</delay>
				</li>
				<li>
					
					Arrays have a fixed size after creation.
					<delay>2</delay>
					The size doesn't need to be known at compile-time, but it does need to be known at creation time.
					<delay>2</delay>
					For example:
public String[] createArray(int size) {<break/>    // Not hard-coded, but array is not expandable<break/>    return new String[size];<break/>}<break/>

					<delay>2</delay>
					If you want a collection which can grow an shrink over time, look at the various List&lt;E&gt; implementations, such as ArrayList&lt;E&gt;.

					<delay>2</delay>
				</li>
				<li>
					
					Object[] will always be fixed size.  
					<delay>2</delay>
					If you need a variable length collection, try ArrayList, LinkedList, or one of the many others.

					<delay>2</delay>
					Pick the collection carefully, since they all have different performance aspects.

					<delay>2</delay>
				</li>
				<li>
					
					You can create a new array and initialize it like this.

					<delay>2</delay>
					String[] strArray = {"Initialize","Array","Like","This"};<break/>

					<delay>2</delay>
					If you want an array with a dynamic size I would recommend using an ArrayList.

					<delay>2</delay>
				</li>
				<li>
					
					For mutable arrays other container objects are used.

					<delay>2</delay>
					When using a set of objects, an ArrayList or Vector object is used.

					<delay>2</delay>
					You can also store objects with an object key e.g. "Name" =
					<delay>2</delay>
					"Ben" instead of [0] =
					<delay>2</delay>
					"Ben".

					<delay>2</delay>
					Vector v = new Vector();<break/>for(int i = 0; i &lt; 100; i++){<break/> Object o = new Object();<break/> // init object<break/> v.addElement(o);<break/>}<break/>for(int i = 0; i &lt; 100; i++){<break/> Object o = v.elementAt(i);<break/> // manipulate object<break/>}<break/>

					<delay>2</delay>
					Now you have an arbritairy list of object of undefined length.

					<delay>2</delay>
					Size found by using vector.size() method.

					<delay>2</delay>
					java.util package is required and part of J2SE 1.3 and higher.

					<delay>2</delay>
				</li>
				<li>
					
					As noted elsewhere, an array object has a fixed size.  
					<delay>2</delay>
					If there's some reason you must use an array, you can use one or both of these techniques:
Make it the larger than you need, leaving the unused
entries null.  
					<delay>2</delay>
					You may want to keep a "slotsUsed" variable.

					<delay>2</delay>
					When the array gets too small, make a bigger one and copy the
contents into it.

					<delay>2</delay>
					These are both used inside ArrayList.

					<delay>2</delay>
				</li>
				<li>
					
					Arrays are fixed in length.
					<delay>2</delay>
					I would recommend using a Collection.

					<delay>2</delay>
					Here is an article on collections:
http://en.wikipedia.org/wiki/Java_collections_framework
With these, you can add elements by using an Add() command or something similar.

					<delay>2</delay>
					As mentioned in the previous answers, an ArrayList or List are collections.

					<delay>2</delay>
				</li>
				<li>
					
					If you want an array of primitive instead of objects, you can use Trove4j.
					<delay>2</delay>
					Otherwise use an ArrayList, or CopyOnWriteArrayList to wrap an array.
					<delay>2</delay>
					There are other List implementations but these do not act like arrays for access time.

					<delay>2</delay>
				</li>
				<li>
					
					Sometimes it is useful, in case you know an upper bound of the objects your application needs,
to declare the size of an array as
static final int ARRAY_SIZE = 1000;<break/>

					<delay>2</delay>
					This goes near the beginning of the class so it can be easily changed.

					<delay>2</delay>
					In the main code instantiate the array with
Object[] objects = new Object[ARRAY_SIZE];<break/>
Also in case the array you want to use has the same size as another array consider using
Object[] objects = new Object[other_objects.length];<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java array declaration without hard coding ^ size </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to convert int [] to Big Integer? -->
			^ big integer 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Well, what about new BigInteger(byte[] val)?

					<delay>2</delay>
					To quote the API docs I linked to:
  
					<delay>2</delay>
					Translates a byte array containing the two's-complement binary representation of a BigInteger into a BigInteger.
					<delay>2</delay>
					The input array is assumed to be in big-endian byte-order: the most significant byte is in the zeroth element.

					<delay>2</delay>
				</li>
				<li>
					
					First, make sure you know in which format your int[] is meant to be interpreted.

					<delay>2</delay>
					Each int can be seen as consisting of four bytes, and these bytes together can be converted to an BigInteger.
					<delay>2</delay>
					The details are the byte order - which byte is the most and which one the least significant?

					<delay>2</delay>
					Also, do you have a signed or unsigned number?

					<delay>2</delay>
					A simple way to convert your ints to bytes (for latter use in a BigInteger constructor) would be to use ByteBuffer and wrap an IntBuffer around it.

					<delay>2</delay>
					public BigInteger toBigInteger(int[] data) {<break/>    byte[] array = new byte[data.length * 4];<break/>    ByteBuffer bbuf = ByteBuffer.wrap(array);<break/>    IntBuffer ibuf = bbuf.asIntBuffer();<break/>    ibuf.put(data);<break/>    return new BigInteger(array);<break/>}<break/>
Obvious adaptions would be to set the byte order of bbuf, or use another BigInteger constructor (for unsigned).

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ big integer </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Are there perfomance benefits with ArrayList.ensureCapacity()? -->
			^ perfomance benefits ^ arraylist 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					The performance benefit is realised in cases where you are about to add multiple elements to the list and know how many you're going to be adding.  
					<delay>2</delay>
					By calling ensureCapacity(int) you cause the underlying array to be resized once instead of potentially many times.

					<delay>2</delay>
					Note however, that in reality you should rarely need to call this method; typically you will either instantiate the ArrayList with a known capacity, or in cases where the list size is unknown you should probably be considering using a LinkedList instead.

					<delay>2</delay>
					Also note that the resize strategy of ArrayList is typically implemented in such a way that array copies are a rare operation (e.g. the capacity may increase by 50% every time the array becomes full).  
					<delay>2</delay>
					In other words, even if you do not call ensureCapacity in advance you are unlikely to notice any slow-down within your code.

					<delay>2</delay>
				</li>
				<li>
					
					An application can increase the capacity of an ArrayList instance before adding a large number of elements using the ensureCapacity operation.
					<delay>2</delay>
					This may reduce the amount of incremental reallocation.

					<delay>2</delay>
					ArrayList.ensureCapacity() Increases the capacity of this ArrayList instance, if necessary, to ensure that it can hold at least the number of elements specified by the minimum capacity argument.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ perfomance benefits ^ arraylist </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How do you avoid an ArrayList object from being modified, i.e. avoid adding and deleting its content? -->
			^ avoid ^ arraylist object ^ modified ^ e ^ avoid adding ^ deleting ^ content 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					By creating an unmodifiable list out of it:
List&lt;Object&gt; dontModify = Collections.unmodifiableList(originalList);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					It depends on the exact requirements:

					<delay>2</delay>
					Collections.unmodifiableList(arrayList) gives you an unmodifiable view of the original list - that's probably what you need

					<delay>2</delay>
					guava's ImmutableList makes a list that is immutable (and not a view)
					<delay>2</delay>
					(you'd have to copy the ArrayList elements to the immutable list)

					<delay>2</delay>
				</li>
				<li>
					
					You don't give the ArrayList to anything you don't trust - instead, you use Collections.unmodifiableList to create an immutable wrapper around the existing list, and give untrusted code that instead.

					<delay>2</delay>
					Note that this only gives a wrapper around the existing list - anything with access to the original list can still modify it.
					<delay>2</delay>
					If you want to create a completely immutable list, you can either use a dedicated class (e.g. ImmutableList in Guava) or create a copy of the original list, wrap that copy using Collections.unmodifiableList, and throw away the reference to the mutable list (so only the immutable wrapper knows about it).

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ avoid ^ arraylist object ^ modified ^ e ^ avoid adding ^ deleting ^ content </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java - It's possible add an int and an String in the array? -->
			^ java ^ possible add ^ int ^ string ^ array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					No, Java is a strongly-typed language.
					<delay>2</delay>
					So you cannot add a String and an int to the same array if the array is typed as either String or int.

					<delay>2</delay>
					However if your array is typed as Object, you can add a String and an Integer (an integer literal will be autoboxed) to that same array.
					<delay>2</delay>
					This is not recommended and is probably a sign that you should think more about your design.
					<delay>2</delay>
					The first question you need to ask yourself is why you need to do this.
					<delay>2</delay>
					If you do have a valid reason, then it would be better to convert from one to the other instead of having an array typed as Object.

					<delay>2</delay>
					Having a catch-call array where you can shove in any object in a bad idea for many reasons:
You are enforcing no separation between the objects.
					<delay>2</delay>
					Are the objects actually related to each other?
					<delay>2</delay>
					If so you type then using an interface or create an abstract class that each of the types extend.

					<delay>2</delay>
					Since you have no separation between the objects, anything you pull out of the array is an Object.
					<delay>2</delay>
					How would you know what it is?
					<delay>2</delay>
					You need to inspect its type explicitly.
					<delay>2</delay>
					This is an extremely cumbersome and unmaintainable design. 

					<delay>2</delay>
					You essentially end up losing type-safety and will not be able to benefit from type-mismatch errors that will show up during compilation.
					<delay>2</delay>
					This will hide possible errors in your code where you may have forgotten to inspect the type, or where you are casting an object to the wrong type.
					<delay>2</delay>
					This can lead to all kinds of nightmarish bugs.

					<delay>2</delay>
					Your code is going to be littered with explicit checks and casts and will be unmaintainable (by you or anyone else).

					<delay>2</delay>
					Your code leaks abstraction everywhere.
					<delay>2</delay>
					No one can look at the array and realize what the array contains.
					<delay>2</delay>
					Anyone who uses your code needs to remember an overwhelming amount of detail as to what types of objects the array can contain. 

					<delay>2</delay>
					Obfuscation is never a valid reason.
					<delay>2</delay>
					Code should be clear, easy to read, easy to maintain, and easy to understand (for you and for anyone else who will read your code).
					<delay>2</delay>
					Any code that looks obfuscated or is "clever" either needs to be rewritten or documented extensively to explain the reason for its "cleverness".
					<delay>2</delay>
					As far as obfuscating the source, it is a non-issue since you're going to be distributing the String0 files anyway.
					<delay>2</delay>
					You can run that through a decompiler to look at the source code.
					<delay>2</delay>
					There is nothing you can do at the source level to satisfactorily obfuscate your code; you're only going to make it difficult for you or anyone else to maintain.
					<delay>2</delay>
					Obfuscation can be done at the byte-code level and so that doesn't really apply to this situation.

					<delay>2</delay>
				</li>
				<li>
					
					Yes it is possible, but it is not good practice.

					<delay>2</delay>
					Object[] myObjects = new Object[] {array1[i], array2[i], "name1", value1, value2, "name2",  value1, value....};<break/>

					<delay>2</delay>
					It must be array of objects

					<delay>2</delay>
				</li>
				<li>
					
					In your string array you could have "123" and then convert it to an int later when you need it.

					<delay>2</delay>
				</li>
				<li>
					
					You can't add a primitive types (including int) to an array with Objects such as String.  
					<delay>2</delay>
					However, autoboxing of int to Integer will make this possible if you declare an Object[] array.

					<delay>2</delay>
					Object[] array = new Object[2];<break/>array[0] = "Hello";<break/>array[1] = 42;<break/>

					<delay>2</delay>
					Though I wouldn't recommend doing this if modeling this String and int as attributes of a class would work.

					<delay>2</delay>
				</li>
				<li>
					
					Yes it definitely is possible, just have an array of raw objects.

					<delay>2</delay>
					For example:
Object[] arr = new Object[10];<break/>arr[0] = 10; // boxed to Integer class<break/>arr[1] = "foo"; // String class<break/>
Then you can use instanceof to determine the type of object stored at a particular index.

					<delay>2</delay>
					For example:

					<delay>2</delay>
					if (arr[0] instanceof Integer) ((Integer) arr[0]) += 10;<break/>
Note that this is not necessarily a good practise to get used to, but it does have applications.

					<delay>2</delay>
				</li>
				<li>
					
					Strictly speaking:
					<delay>2</delay>
					No.

					<delay>2</delay>
					Otherwise:
					<delay>2</delay>
					Yes for most practical purposes:
Object[] array = { 42, "foo" };<break/>
Please note, that the 42 is not an int but an `Integer´.
					<delay>2</delay>
					But due to autoboxing and unboxing you wont notice the difference.
					<delay>2</delay>
					The tradeoff is of course performance and garbage collector overhead.

					<delay>2</delay>
					Also the array must be of type Object[], not of type String[] nor of type int[].

					<delay>2</delay>
				</li>
				<li>
					
					You can use java.util.ArrayList to do this.
					<delay>2</delay>
					You will need to make sure that you check carefully what you are getting when you pull items out though.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java ^ possible add ^ int ^ string ^ array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Get mimetype from byte array without external lib -->
			^ get mimetype ^ byte array without external lib 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					There is a way to do that using Java 7, but it is kind of clumsy (um tanto "desajeitado"):  

					<delay>2</delay>
					write the bytes to a (temporary) file,  
use Files.probeContentType(Path) to check the contents of that file
if the bytes came from a file you could use probeContentType directly on it.  

					<delay>2</delay>
					EDIT:
not very useful, at least on Windows: probeContentType seams to primarily use the file extension to determine the file type [:-|

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ get mimetype ^ byte array without external lib </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to escape ArrayIndexOutOfBoundsException? -->
			^ escape arrayindexoutofboundsexception 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Use iterators or enhanced for-loops to abstract away the explicit use of array indexes:
Iterator&lt;Object&gt; myIterator = Arrays.asList(arrayOfObjects).iterator();<break/>while(myIterator.hasNext()) {<break/>    doSomething(myIterator.next());<break/>}<break/>
or
for(Object o : arrayOfObjects) {<break/>    doSomething(o);<break/>}<break/>
Update:  you've updated the question; now it has an ArrayList.  
					<delay>2</delay>
					Iterators and enhanced for-loops work with ArrayLists (and many other collections), too:
for(Question myQuestion : q) {<break/>    doSomethingWithAQuestion(myQuestion);<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					int i = 0;<break/>List&lt;Object&gt; list = getListOfUnknownSize();<break/>while(list != null &amp;&amp; i &lt; list.size()) {<break/>    process(list.get(i));<break/>    i++;<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ escape arrayindexoutofboundsexception </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to create a list with specific size of elements -->
			^ create ^ list ^ specific size ^ elements 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You can use Collections.nCopies.

					<delay>2</delay>
					Note however that the list returned is immutable.
					<delay>2</delay>
					In fact, the docs says "it the newly allocated data object is tiny (it contains a single reference to the data object)".

					<delay>2</delay>
					If you need a mutable list, you would do something like
List&lt;String&gt; hellos = new ArrayList&lt;String&gt;(Collections.nCopies(1000, "Hello"));<break/>

					<delay>2</delay>
					If you want 1000 distinct objects, you can use
List&lt;YourObject&gt; objects = Stream.generate(YourObject::new)<break/>                                 .limit(1000)<break/>                                 .collect(Collectors.toList());<break/>
Again, there is not guarantees about the capabilities of the resulting list implementation.
					<delay>2</delay>
					If you need, say an ArrayList, you would do
                                 ...<break/>                                 .collect(ArrayList::new);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Fastest : int[] myList = new int[1000] will contain 1000 elements equal to zero.
					<delay>2</delay>
					But I'm sure it doesn't suit your needs.
					<delay>2</delay>
					Tell us more of what you need
					<delay>2</delay>
					and I might be able to help :)

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ create ^ list ^ specific size ^ elements </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java - How do I make a String array with values? -->
			^ java ^ make ^ string array ^ values 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You could do something like this
String[] myStrings = { "One", "Two", "Three" };<break/>
or in expression
functionCall(new String[] { "One", "Two", "Three" });<break/>
or
String myStrings[];<break/>myStrings = new String[] { "One", "Two", "Three" };<break/>

					<delay>2</delay>
				</li>
				<li>
					
					By using the array initializer list syntax, ie:
String myArray[] = { "one", "two", "three" };<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You want to initialize an array.
					<delay>2</delay>
					(For more info - Tutorial)
int []ar={11,22,33};<break/>String []stringAr={"One","Two","Three"};<break/>
From the JLS

					<delay>2</delay>
					The [] may appear as part of the type at the beginning of the declaration, or as part of the declarator for a particular variable, or both, as in this example:
byte[] rowvector, colvector, matrix[];<break/>
This declaration is equivalent to:
byte rowvector[], colvector[], matrix[][];<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Another way to create an array with String apart from
String[] strings =  { "abc", "def", "hij", "xyz" };<break/>
is to use split.  
					<delay>2</delay>
					I find this more readable if there are lots of Strings.

					<delay>2</delay>
					String[] strings =  "abc,def,hij,xyz".split(",");<break/>
or the following is good if you are parsing lines of strings from another source.

					<delay>2</delay>
					String[] strings =  ("abc\n" +<break/>                     "def\n" +<break/>                     "hij\n" +<break/>                     "xyz").split("\n");<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Another way is with Arrays.setAll, or Arrays.fill:
String[] v = new String[1000];<break/>Arrays.setAll(v, i -&gt; Integer.toString(i * 30));<break/>//v =&gt; ["0", "30", "60", "90"... ]<break/>Arrays.fill(v, "initial value");<break/>//v =&gt; ["initial value", "initial value"... ]<break/>
This is more usefull for initializing (possibly large) arrays where you can compute each element from its index.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java ^ make ^ string array ^ values </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- The best way to convert array elements as keys in a new dictionary -->
			^ best way ^ convert array elements ^ keys ^ new dictionary 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					This isn't much to go on, but let's see: 
Say you have an int[10] and you want to store them in a HashMap (Dictionaries aren't used much these days).
					<delay>2</delay>
					You could do this:
Map&lt;Integer, Integer&gt; dict = new HashMap&lt;Integer, Integer&gt;();<break/>for(int i = 0; i &lt; array.length; i++) {<break/>    dict.put(i,array[i]); // autoboxing takes care of primitives<break/>}<break/>

					<delay>2</delay>
					If you were looking to use the actual values in the array as the keys in the dictionary, then you have to ask yourself "
					<delay>2</delay>
					Where are my dictionary values coming from?
					<delay>2</delay>
					For example, if you wanted the values to be the index, you could just reverse the above
dict.put(array[i],i);<break/>

					<delay>2</delay>
					Perhaps you have another array with some values in it.

					<delay>2</delay>
					code_placeholder_5
Simply put, you have a put method.
					<delay>2</delay>
					The first parameter is going to be the key, the second parameter is going to be the value.
					<delay>2</delay>
					As long as you're iterating over the array you'll have your keys; then it's just a matter of deciding what values go in there.

					<delay>2</delay>
				</li>
				<li>
					
					Integer[] keys = {1, 2, 3};<break/>HashMap&lt;Integer, Object&gt; map = new HashMap&lt;Integer, Object&gt;();<break/>Collections.addAll( map.keySet(), keys );<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ best way ^ convert array elements ^ keys ^ new dictionary </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Merge 3 arraylist to one -->
			^ merge 3 arraylist ^ one 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Use ArrayList.addAll().
					<delay>2</delay>
					Something like this should work (assuming lists contain String objects; you should change accordingly).

					<delay>2</delay>
					List&lt;String&gt; combined = new ArrayList&lt;String&gt;();<break/>combined.addAll(firstArrayList);<break/>combined.addAll(secondArrayList);<break/>combined.addAll(thirdArrayList);<break/>
Update
I can see by your comments that you may actually be trying to create a 2D list.
					<delay>2</delay>
					If so, code such as the following should work:
List&lt;List&lt;String&gt;&gt; combined2d = new ArrayList&lt;List&lt;String&gt;&gt;();<break/>combined2d.add(firstArrayList);<break/>combined2d.add(secondArrayList);<break/>combined2d.add(thirdArrayList);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					What about using java.util.Arrays.asList to simplify merging?

					<delay>2</delay>
					List&lt;String&gt; one = Arrays.asList("one","two","three");<break/>List&lt;String&gt; two = Arrays.asList("four","five","six");<break/>List&lt;String&gt; three = Arrays.asList("seven","eight","nine");<break/>List&lt;List&lt;String&gt;&gt; merged = Arrays.asList(one, two, three);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Using Java 8 Streams:
List of List
List&lt;List&lt;String&gt;&gt; listOfList = Stream.of(list1, list2, list3).collect(Collectors.toList());<break/>
List of Strings

					<delay>2</delay>
					List&lt;String&gt; list = Stream.of(list1, list2, list3).flatMap(Collection::stream).collect(Collectors.toList());<break/>

					<delay>2</delay>
					Using Java 9 List.of static factory method
					<delay>2</delay>
					(Warning: this list is immutable and disallows null)

					<delay>2</delay>
					List&lt;List&lt;String&gt;&gt; = List.of​(list1, list2, list3);<break/>
Where list1, list2, list3 are of type List&lt;String&gt;

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ merge 3 arraylist ^ one </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Creating multiple arrays from users input -->
			^ creating multiple arrays ^ users input 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You can use java collections for this.
					<delay>2</delay>
					That way you no need to worry about the size being entered by the user.
					<delay>2</delay>
					I suggest Multimap.

					<delay>2</delay>
				</li>
				<li>
					
					My suggestion would be something like a List.
					<delay>2</delay>
					So, as an example, if a user enters 5, you'd have a List&lt;Object[]&gt; which we could call l.
					<delay>2</delay>
					Then you could add a new Object[] for however many times the user entered, which in this case is 5.
					<delay>2</delay>
					This is an addendum to Pangea's answer, which is actually sufficient and includes a really good suggestion to use Java's Collection Classes.
					<delay>2</delay>
					You can read more about Lists and an implementation of a List called List0 here and here respectively.

					<delay>2</delay>
				</li>
				<li>
					
					Assumed you want to create 5 int arrays of size 7
					<delay>2</delay>
					you could so:
int a=7;<break/>int b=5;<break/>int name[][] = new int[b][a]; <break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ creating multiple arrays ^ users input </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Running time of lastIndexOf for an ArrayList in java -->
			^ running time ^ lastindexof ^ arraylist ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					the average execution time is proportional to number of elements.
					<delay>2</delay>
					That is, this method is an O(n) operation, where n is number of elements.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ running time ^ lastindexof ^ arraylist ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- List Properties and Convert to String[] -->
			^ list properties ^ convert 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Properties implements Map which has a keySet() method which returns a Set with all keys.
					<delay>2</delay>
					The Set in turn has a toArray() method which allows you to get the values as a plain array.

					<delay>2</delay>
					So, this should do:
String[] keys = properties.keySet().toArray(new String[0]);<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ list properties ^ convert </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java equivalent of C# Array.GetLength(i) -->
			^ java equivalent ^ c ^ array ^ getlength 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					No, because Java doesn't have multi-dimensional arrays.
					<delay>2</delay>
					It only has jagged arrays, i.e. arrays of arrays.

					<delay>2</delay>
				</li>
				<li>
					
					No.
					<delay>2</delay>
					Java doesn't have multi-dimensional arrays.  
					<delay>2</delay>
					What it has is arrays of arrays (etc) but each level can be a different size.

					<delay>2</delay>
					int[][] ints = { { 1 }, {1,2,3}, {5,6} };<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Like others have said.
					<delay>2</delay>
					Java does not have true multidimensional arrays but instead has arrays of arrays.
					<delay>2</delay>
					In order to get the length of a particular array you just need to get the length member variable for that array:
int[][] ints = { { 1 }, {1,2,3}, {5,6} };<break/>ints[0].length == 1<break/>ints[1].length == 3<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java equivalent ^ c ^ array ^ getlength </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Get Filename from Byte Array -->
			^ get filename ^ byte array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					No.
					<delay>2</delay>
					You can take a guess at a mimetype from the content data itself, but the filename is not in there.

					<delay>2</delay>
				</li>
				<li>
					
					The header field that you may be looking for is called Content-Disposition.
					<delay>2</delay>
					If you're downloading an attachment, then there may be a file name in that field:
Content-Disposition: attachment;filename=abc.txt<break/>

					<delay>2</delay>
					But there's no guarantee that you'll have such a file name available.
					<delay>2</delay>
					Also, this may only apply to HTTP and E-Mail content.
					<delay>2</delay>
					From your question, it's not clear where your data's origin is...

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ get filename ^ byte array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to extract file extension from byte array -->
			^ extract file extension ^ byte array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					
  Maybe I need to save additional column in my DB for file extension.

					<delay>2</delay>
					That is a better solution than attempting to deduce a mimetype based on the database content, for (at least)
					<delay>2</delay>
					the following reasons:
If you have a mime type from the document source, you can store and use that.

					<delay>2</delay>
					You could (potentially) ask the user to specify a mimetype when they lodge the document.

					<delay>2</delay>
					If you have to use some heuristic-based scheme for figuring out a mimetype:
you can do the work once before creating the table row, rather than N times after extracting it, and
you can report cases where the heuristic gives no good answer, and maybe ask the user to say what the file type really is.

					<delay>2</delay>
					(I'm making some assumptions that may not be warranted, but the question doesn't give any clues on how the larger system is intended to work.)

					<delay>2</delay>
				</li>
				<li>
					
					If this is for storing a file that is uploaded:
create a column for the filename extension
create a column for the mime type as sent by the browser

					<delay>2</delay>
					If you don't have the original file, and you only have bytes, you have a couple of good solutions.

					<delay>2</delay>
					If you're able to use a library, look at using mime-util to inspect the bytes:
http://technopaper.blogspot.com/2009/03/identifying-mime-using-mime-util.html

					<delay>2</delay>
					If you have to build your own byte detector, here are many of the most popular starting bytes:
"BC" =&gt; bitcode,<break/>"BM" =&gt; bitmap,<break/>"BZ" =&gt; bzip,<break/>"MZ" =&gt; exe,<break/>"SIMPLE"=&gt; fits,<break/>"GIF8" =&gt; gif,<break/>"GKSM" =&gt; gks,<break/>[0x01,0xDA].pack('c*') =&gt; iris_rgb,<break/>[0xF1,0x00,0x40,0xBB].pack('c*') =&gt; itc,<break/>[0xFF,0xD8].pack('c*') =&gt; jpeg,<break/>"IIN1" =&gt; niff,<break/>"MThd" =&gt; midi,<break/>"%PDF" =&gt; pdf,<break/>"VIEW" =&gt; pm,<break/>[0x89].pack('c*') + "PNG" =&gt; png,<break/>"%!" =&gt; postscript,<break/>"Y" + [0xA6].pack('c*') + "j" + [0x95].pack('c*') =&gt; sun_rasterfile,<break/>"MM*" + [0x00].pack('c*') =&gt; tiff,<break/>"II*" + [0x00].pack('c*') =&gt; tiff,<break/>"gimp xcf" =&gt; gimp_xcf,<break/>"#FIG" =&gt; xfig,<break/>"/* XPM */" =&gt; xpm,<break/>[0x23,0x21].pack('c*') =&gt; shebang,<break/>[0x1F,0x9D].pack('c*') =&gt; compress,<break/>[0x1F,0x8B].pack('c*') =&gt; gzip,<break/>"PK" + [0x03,0x04].pack('c*') =&gt; pkzip,<break/>"MZ" =&gt; dos_os2_windows_executable,<break/>".ELF" =&gt; unix_elf,<break/>[0x99,0x00].pack('c*') =&gt; pgp_public_ring,<break/>[0x95,0x01].pack('c*') =&gt; pgp_security_ring,<break/>[0x95,0x00].pack('c*') =&gt; pgp_security_ring,<break/>[0xA6,0x00].pack('c*') =&gt; pgp_encrypted_data,<break/>[0xD0,0xCF,0x11,0xE0].pack('c*') =&gt; docfile<break/>

					<delay>2</delay>
				</li>
				<li>
					
					It turned out that there is a decent method in JDK's URLConnection class, please refer to the following answer: Getting A File&#39;s Mime Type
					<delay>2</delay>
					In Java

					<delay>2</delay>
					If one needs to extract file extension from byte array instead of file, one should simply use java.io.ByteArrayInputStream (class to read bytes specifically from byte arrays) instead of java.io.FileInputStream (class to read bytes specifically from files) like in the following example:

					<delay>2</delay>
					byte[] content = ;<break/>InputStream is = new ByteArrayInputStream(content);<break/>String mimeType = URLConnection.guessContentTypeFromStream(is);<break/> //...close stream<break/>
Hope this helps...

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ extract file extension ^ byte array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How do you access an array or variable declared or initialized in a nested loop from outside of the loop? -->
			^ access ^ array ^ variable declared ^ initialized ^ nested loop ^ loop ^ outside 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You cannot.
					<delay>2</delay>
					You must declare the array outside the loop.
					<delay>2</delay>
					This may seem strange at first but what if the condition for the loop to run even once is never met?
					<delay>2</delay>
					How could you possibly then access an array which was never even created?

					<delay>2</delay>
				</li>
				<li>
					
					You cannot.
					<delay>2</delay>
					Java uses block scope, so variables declared within any block (such as a loop) are not accessible from outside.
					<delay>2</delay>
					You'll need to assign them to something that has an outer scope.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ access ^ array ^ variable declared ^ initialized ^ nested loop ^ loop ^ outside </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Would java.io.ByteArrayOutputStream.toByteArray() return null? -->
			^ would java ^ io ^ bytearrayoutputstream 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					No, it never will.
					<delay>2</delay>
					It would never make sense to return null, and if you look at the implementation it definitely won't.
					<delay>2</delay>
					(I realize it's generally better to rely on the documented guarantees than the implementation, but I see no reason to suppose it would ever return null here.)

					<delay>2</delay>
					In particular, the documentation states:
  Creates a newly allocated byte array.
and
  Returns: the current contents of this output stream, as a byte array.

					<delay>2</delay>
					Those wouldn't be correct if it returned null, would it?

					<delay>2</delay>
				</li>
				<li>
					
					It would return null in one way ;)

					<delay>2</delay>
					ByteArrayOutputStream baos = new ByteArrayOutputStream()<break/>{<break/>    public byte[] toByteArray()<break/>    {<break/>        return null;<break/>    }<break/>};<break/>System.out.println(baos.toByteArray());<break/>
OUTPUT:
null<break/>

					<delay>2</delay>
				</li>
				<li>
					
					No it wouldn't.
					<delay>2</delay>
					Ever.
					<delay>2</delay>
					Look into the code
					<delay>2</delay>
					ByteArrayOutputStream.toByteArray:
public synchronized byte toByteArray()[] {<break/>    return Arrays.copyOf(buf, count);<break/>}<break/>
Arrays.copyOf:
public static byte[] copyOf(byte[] original, int newLength) {<break/>    byte[] copy = new byte[newLength];<break/>    System.arraycopy(original, 0, copy, 0,<break/>                     Math.min(original.length, newLength));<break/>    return copy;<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ would java ^ io ^ bytearrayoutputstream </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Getting values from arraylists and saving -->
			^ getting values ^ arraylists ^ saving 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Use get(index), set(index, object), insert(index, object) and add(object) methods for this.

					<delay>2</delay>
					Example:
List&lt;String&gt; list0 = new ArrayList&lt;String&gt;();<break/>list0.add("this");<break/>list0.add("is");<break/>list0.add("an");<break/>list0.add("answer");<break/>List&lt;String&gt; list1 = new ArrayList&lt;String&gt;();<break/>list1.add(list0.get(1));<break/>list1.add(list0.get(3));<break/>list1.insert(1, list0.get(0));<break/>
The resulting list1 will be: "is", "this", "answer".

					<delay>2</delay>
				</li>
				<li>
					
					use Intent for passing value to another class(extends activity) intentObj.putExtras() will help.

					<delay>2</delay>
					to put:
ArrayList&lt;String&gt; arrayList= new ArrayList&lt;String&gt;();<break/>arrayList.add("hello");<break/>arrayList.add("there");<break/>Intent intent = new Intent(getApplicationContext(), secondClass.class);<break/>        intent.putStringArrayListExtra("pass_list", arrayList);<break/>        startActivity(intent);<break/>
to get
ArrayList&lt;String&gt; arrayList= getIntent().getStringArrayListExtra("pass_list");<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can use Collection class's addAll method to add all elements of an arraylist to another.

					<delay>2</delay>
					See the documentation http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html#addAll%28java.util.Collection%29

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ getting values ^ arraylists ^ saving </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to move elements of Java ArrayList to file in java -->
			^ move elements ^ java arraylist ^ java ^ file 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Make your class implement Serializable.

					<delay>2</delay>
					Open an ObjectOutputStream wrapping a FileOutputStream
write the entire List with writeObject
					<delay>2</delay>
					()
close the ObjectOutputStream.

					<delay>2</delay>
				</li>
				<li>
					
					Make sure that your list elements implement the Serializable interface and then you can use the ObjectOutputStream to write objects to file and the ObjectInputStream to read them back in. 

					<delay>2</delay>
					Another option you can take a look at is using XStream.
					<delay>2</delay>
					You can see how you can use it here.

					<delay>2</delay>
					The advantage of using XStream instead of object streams is that using XML will provide you with something which is human readable, it can be processed by other platforms and also does not require you to implement the Serializable interface, which uses the serialVersionUID to store the items to a file.
					<delay>2</delay>
					This could cause items which where written prior to some change to your class not being loaded.
					<delay>2</delay>
					Take a look here for more information.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ move elements ^ java arraylist ^ java ^ file </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How can I restrict the arraylist to accept only a specfic type of object prior to generic -->
			^ restrict ^ arraylist ^ accept ^ specfic type ^ object prior ^ generic 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Write a wrapper function that accepts only the allowed type, and hide the collection.
					<delay>2</delay>
					That was standard best-practice pre-Java-5.

					<delay>2</delay>
					private final List strings = new ArrayList();<break/>public void add(String s)<break/>{<break/>    strings.add(s);<break/>}<break/>public String remove(String s)<break/>{<break/>    return (String) strings.remove(s);<break/>}<break/>// etc...<break/>

					<delay>2</delay>
					Yes, this sucks.

					<delay>2</delay>
					Might I ask: is there a reason you're not using generics?
					<delay>2</delay>
					They are bytecode-compatible with Java 1.4

					<delay>2</delay>
				</li>
				<li>
					
					Two options, (I am assuming C# here, but all applies to pretty much all OO languages).

					<delay>2</delay>
					1) Inherit from collection type of choice (or its interfaces), override all methods to throw exception on wrong type, something like this:
<break/>public class MyType<break/>{<break/>    // Your type here<break/>}<break/>public class MyTypeCollection : ArrayList<break/>{<break/>    public override int Add(object value)<break/>    {<break/>        if (!(value is MyType))<break/>        {<break/>            throw new ArgumentException("value must be of type MyType");<break/>        }<break/>        return base.Add(value);<break/>    }<break/>    public int Add(MyType myType)<break/>    {<break/>        return base.Add(myType);<break/>    }<break/>    // Other overrides here<break/>}<break/>
or
2) (probably better), create your own type altogether and implement interfaces as desirable for collections and use a non-generic, non-typed collection internally.
					<delay>2</delay>
					Something like this:
<break/>public class MyTypeCollection2 : IEnumerable<break/>{<break/>    private readonly ArrayList _myList = new ArrayList();<break/>    public void Add(MyType myType)<break/>    {<break/>        _myList.Add(myType);<break/>    }<break/>    // Other collection methods<break/>    public IEnumerator GetEnumerator()<break/>    {<break/>        yield return _myList.Cast&lt;MyType&gt;();<break/>    }<break/>}<break/>
Make sure to implement all interfaces you will care about.
					<delay>2</delay>
					In the .NET Framework the interfaces implemented for ArrayList are: IList, ICloneable
Hope this helps.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ restrict ^ arraylist ^ accept ^ specfic type ^ object prior ^ generic </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to show text randomly chosen from list when button is pressed? -->
			^ show text randomly chosen ^ list ^ button ^ pressed 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					There is a simple solution for it.
					<delay>2</delay>
					You make use of the Random() class or you use Math.random() to iterate through your string as an array of characters.
					<delay>2</delay>
					Then you just choose random bits of it, until it's gone.

					<delay>2</delay>
					All you have to make sure of though, is that the arrays size is always checked so that you don't hit an OutOfBoundsException 

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ show text randomly chosen ^ list ^ button ^ pressed </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Avoiding duplicate integers in an integer array -->
			^ avoiding duplicate integers ^ integer array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					
  without using any of the collections i.e. Arraylist or Set etc.?

					<delay>2</delay>
					Just check through array before inserting,   
you could use insertion sort and do the binarysearch it would be little faster

					<delay>2</delay>
				</li>
				<li>
					
					
Write a method that adds the value to the array.

					<delay>2</delay>
					Before adding, scan the array if the value exists.

					<delay>2</delay>
					Skip the adding if it does exist.

					<delay>2</delay>
					Use only that method to add values to the array.

					<delay>2</delay>
					Ideally bundle the array and the method in a class.
					<delay>2</delay>
					Voila: encapsulation!

					<delay>2</delay>
				</li>
				<li>
					
					If your problem is to return an Integer[], and not any other collection, you could however use a Set&lt;Integer&gt; privately to avoid duplicated values, and then return Set&lt;Integer&gt;.toArray(new Integer[0]).

					<delay>2</delay>
					That's the simplest way IMHO...

					<delay>2</delay>
					For example:
private Set&lt;Integer&gt; intSet = new HashSet&lt;Integer&gt;();<break/>public void setIntArray(Integer[] i){<break/>    intSet = new HashSet&lt;Integer&gt;(Arrays.asList(i));<break/>}<break/>public Integer[] getIntArray(){<break/>    return intSet.toArray(new Integer[0]);<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can create another array, let's call it exists, of type boolean.
					<delay>2</delay>
					Then each time you add an integer to your main list check if exists[newNumber].
					<delay>2</delay>
					If the value is true it already exists, otherwise add the number to the integer array and set the boolean value to true. 

					<delay>2</delay>
					This solution works well if the number range has a small bound.
					<delay>2</delay>
					Note, my example also assumes the integer is positive.
					<delay>2</delay>
					Some optimization is to use a long[] array and use each bit as a flag.

					<delay>2</delay>
				</li>
				<li>
					
					First Assuming the Array is a buffer and has extra Space. 

					<delay>2</delay>
					Simply loop through it checking each value.
					<delay>2</delay>
					Such As
    for(int i=0;  i&lt;endpointer  &amp;&amp;i &lt; buffer.length  ; i++){<break/>        if(buffer[i]==valueToPutInArray){<break/>            valueExists=true;<break/>            break;<break/>        }<break/>    }<break/>    if(!valueExists)    {<break/>        buffer[endpointer++]=valueToPutInArray;<break/>    }<break/>
If the Array is must be reallocated then you have to do something like this:
    int i=0;<break/>    Integer[] outputArray = new Integer[buffer.length+1];<break/>    for(Integer value : buffer) {<break/>        if(value==valueToPutInArray){<break/>            valueExists=true;<break/>            break;<break/>        }<break/>        outputArray[i++]=value;<break/>    }<break/>    if(!valueExists)    {<break/>        outputArray[i]=valueToPutInArray;<break/>    }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					I would suggest first you perform Arrays.
					<delay>2</delay>
					Sort( int[] ).
					<delay>2</delay>
					Then use Arrays.binarySearch( int [] ,int ) to check whether the element exist or not.

					<delay>2</delay>
					According to javadoc:

					<delay>2</delay>
					/**<break/> * Sorts the specified array of ints into ascending numerical order.<break/> * The sorting algorithm is a tuned quicksort, adapted from Jon<break/> * L. Bentley and M. Douglas McIlroy's "Engineering a Sort Function",<break/> * Software-Practice and Experience, Vol. 23(11) P. 1249-1265 (November<break/> * 1993).  This algorithm offers n*log(n) performance on many data sets<break/> * that cause other quicksorts to degrade to quadratic performance.<break/> *<break/> * @param a the array to be sorted<break/> */<break/>public static void sort(int[] a) {<break/>sort1(a, 0, a.length);<break/>}<break/>
and for BinarySearch:

					<delay>2</delay>
					 /**<break/> * Searches the specified array of ints for the specified value using the<break/> * binary search algorithm.  The array must be sorted (as<break/> * by the {@link #sort(int[])} method) prior to making this call.  If it<break/> * is not sorted, the results are undefined.  If the array contains<break/> * multiple elements with the specified value, there is no guarantee which<break/> * one will be found.<break/> *<break/> * @param a the array to be searched<break/> * @param key the value to be searched for<break/> * @return index of the search key, if it is contained in the array;<break/> *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The<break/> *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the<break/> *         key would be inserted into the array: the index of the first<break/> *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all<break/> *         elements in the array are less than the specified key.  Note<break/> *         that this guarantees that the return value will be &amp;gt;= 0 if<break/> *         and only if the key is found.<break/> */<break/>public static int binarySearch(int[] a, int key) {<break/>return binarySearch0(a, 0, a.length, key);<break/>}<break/>

					<delay>2</delay>
					And one you know whether the element exist or not, rest is easy for you.

					<delay>2</delay>
				</li>
				<li>
					
					The solution depends on your requirement.
					<delay>2</delay>
					If you have a small array size (n&lt;10^6), scanning through the array on every insertion would suffice, but if you have a large array and frequent insertions, I would propose a different solution.

					<delay>2</delay>
					Scanning through an array on every insertion would require a complexity of O(n).
					<delay>2</delay>
					For small numbers, the overhead is ignorable, but as the size of array increases, traversal on every insertion is inefficient.

					<delay>2</delay>
					If you need performance and if memory is not your constraint, you can take a boolean array and initialize all elements to false.
					<delay>2</delay>
					Then whenever you get a number, make its index value in the boolean array to true, And while inserting, check whether the boolean value at the index number of the element being inserted.

					<delay>2</delay>
					Here is the code to initialize the boolean array
					<delay>2</delay>
					(initializing it would make all elements false):

					<delay>2</delay>
					boolean [] duplicateValuesArray = new boolean[Integer.MAX_VALUE];<break/>
Here is the function which inserts an element in the array:
    public void insertElement(int elementToBeInserted) {<break/>        if(!duplicateValuesArray[elementToBeInserted])  //check if element already in array<break/>            duplicateValuesArray[elementToBeInserted] = true;<break/>            mainArray[index++] = elementToBeInserted;<break/>    }<break/>

					<delay>2</delay>
					In this way, whenever you get a number, value for that index in the boolean array is set to true, and while insertion, everytime the index is checked, if value is true, that element exists in the array, do not insert it.

					<delay>2</delay>
					The complexity for this is much lower if you have a large mainArray
					<delay>2</delay>
					(n>10^6)
					<delay>2</delay>
					and you have frequent insertions.
					<delay>2</delay>
					This is because, initializing a boolean array is one time O(n) complexity, and after that, checking for the element in the boolean array and insertion of element is just O(1) operation, happens in constant time. 

					<delay>2</delay>
					Thus effective complexity is reduced to just initializing the boolean array.
					<delay>2</delay>
					And even in terms of memory footprint, I wouldn't mind because a boolean primitive just occupies one bit in the memory.

					<delay>2</delay>
					P.S
					<delay>2</delay>
					: Basically it is a memory vs performance trade off, and this is the Universal Computing Trade off, found everywhere.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ avoiding duplicate integers ^ integer array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Using a List and importing java.awt.* at the same time -->
			^ using ^ list ^ importing java ^ awt ^ time 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					From a quick Google search

					<delay>2</delay>
					The class name List is now ambiguous because there are two classes java.awt.List and java.util.List.
					<delay>2</delay>
					You can resolve the ambiguity by adding a specific import of the class name:
import java.awt.*;<break/>import java.util.*;<break/>import java.util.List;<break/>

					<delay>2</delay>
					However, if you need to refer to both java.awt.List and java.util.List in the same source file, then you have crossed the limits of the import mechanism.
					<delay>2</delay>
					You can use an import statement to shorten one of the names to List, but you need to reference the other by its full name whenever it occurs in the source text.

					<delay>2</delay>
				</li>
				<li>
					
					The problem is java.awt also has a List inside it, so the compiler doesn't know which one you are using when you call List.

					<delay>2</delay>
					I think you'll have call your list like so:
java.util.List list = new java.util.List();<break/>

					<delay>2</delay>
					So this way the compiler knows which 'List' you are referring to.

					<delay>2</delay>
				</li>
				<li>
					
					There is an ambiguity in the naming conventions of List in  class awt and util, so we can handle it in 2 ways:

					<delay>2</delay>
					Use import
import java.awt.*;
import java.util.List;
import java.util.*;
Use the full path, as mentioned in Head
					<delay>2</delay>
					First Java,"either use import or the full name"
java.util.List&lt;String&gt; list = new java.util.ArrayList&lt;String&gt;();

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ using ^ list ^ importing java ^ awt ^ time </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How can I create an array of classes in Java? -->
			^ create ^ array ^ classes ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Something like:
Class[] classes = new Class[] {Class1.class, Class2.class};<break/>

					<delay>2</delay>
					Though I'm not quite sure what your question is...

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ create ^ array ^ classes ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to create 400 dimensional array in java -->
			^ create 400 dimensional array ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You could use Array.newInstance, but:
  The number of dimensions of the new array must not exceed the number of array dimensions supported by the implementation (typically 255).

					<delay>2</delay>
					But I believe it would be better for you to create better abstractions for your domain.
					<delay>2</delay>
					Dealing with such an array would be difficult.
					<delay>2</delay>
					Maybe you can give more information about what you're trying to achieve so that a better answer can be provided.

					<delay>2</delay>
				</li>
				<li>
					
					The simple answer is by typing lots of []'s.  
					<delay>2</delay>
					(But the practical limit is 255.  
					<delay>2</delay>
					This is imposed by the JVM specification (in Section 4.3.2) rather than the JLS; see Maximum number of dimensions in a Java array)

					<delay>2</delay>
					But you really wouldn't want to do this:

					<delay>2</delay>
					Your code will be horrible to read and maintain.  
					<delay>2</delay>
					Each time you need to fetch an element you have to supply 400 index expressions.

					<delay>2</delay>
					A 400 dimensional array that was represented this way would take a ridiculous amount of memory ...

					<delay>2</delay>
					If you are serious about this, you should look into some kind of sparse representation.  
					<delay>2</delay>
					But even then, conventional array computations are hardly going to be practical.

					<delay>2</delay>
				</li>
				<li>
					
					Creating a 400 dimensional array would be harder to maintain/read in the long run and would also waste a lot of memory for you.
					<delay>2</delay>
					I would suggest that you create a class to store your data and start adding the objects of this class to any of the implementation of the java.util.List interface. 

					<delay>2</delay>
					This way you're storing your data in a much more readable format as well.

					<delay>2</delay>
				</li>
				<li>
					
					What you can do is use a BigInteger to encode the 400 dimensions as an integer and use this as a key to a HashMap or TreeMap.
					<delay>2</delay>
					Your array needs to be very, very, very sparse or you will quickly reach your memory limit.
					<delay>2</delay>
					Even 400 dimensions of size 2 is 2.6e120

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ create 400 dimensional array ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Converting a double[] array into string[] array -->
			^ converting 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You'll need to create a target array of equal size to the original array, and iterate over it, converting element by element.

					<delay>2</delay>
					Example:
double[] d = { 2.0, 3.1 };<break/>String[] s = new String[d.length];<break/>for (int i = 0; i &lt; s.length; i++)<break/>    s[i] = String.valueOf(d[i]);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					As already mentioned you have to iterate and convert every item from double to String.

					<delay>2</delay>
					Alternatively it's also possible to avoid an explicit iteration and do the following:
// source array<break/>Double[] d_array = new Double[] { 1, 2, 3, 4 };<break/>// create a string representation like [1.0, 2.0, 3.0, 4.0]<break/>String s = Arrays.toString(d_array);<break/>// cut off the square brackets at the beginning and at the end<break/>s = s.substring(1, s.length - 1);<break/>// split the string with delimiter ", " to produce an array holding strings<break/>String[] s_array = s.split(", ");<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ converting </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Android equivalent for org.apache.commons.io.IOUtils.toByteArray -->
			^ android equivalent ^ org ^ apache ^ commons ^ io ^ ioutils ^ tobytearray 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Try Guava.
					<delay>2</delay>
					I haven't tested it but seems like it has what you need.
					<delay>2</delay>
					toByteArray is listed in their IO tools.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ android equivalent ^ org ^ apache ^ commons ^ io ^ ioutils ^ tobytearray </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java - adding elements to list while iterating over it -->
			^ java ^ adding elements ^ list ^ iterating 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Create a new list, and populate that one.

					<delay>2</delay>
					List&lt;MyType&gt; originalList = ...<break/>List&lt;MyType&gt; newList = new ArrayList&lt;&gt;(originalList);<break/>for(MyType type : originalList)<break/>{<break/>  // Some decisions<break/>  newList.add(new MyType());<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					There are three approaches to avoid above exception
You can convert the list to an array and then iterate on the array.
					<delay>2</delay>
					This approach works well for small or medium size list but if the list is large then it will affect the performance a lot.

					<delay>2</delay>
					You can lock the list while iterating by putting it in a synchronized block.
					<delay>2</delay>
					This approach is not recommended because it will cease the benefits of multithreading.

					<delay>2</delay>
					If you are using JDK1.5 or higher then you can use ConcurrentHashMap and CopyOnWriteArrayList classes.
					<delay>2</delay>
					It is the recommended approach.

					<delay>2</delay>
				</li>
				<li>
					
					Instead of using an iterator, you can use a for loop with an index.  
					<delay>2</delay>
					For example:
int originalLength = list.length();<break/>for (int i = 0; i &lt; originalLength; i++) {<break/>  MyType mt = list.get(i);<break/>  //... processing<break/>  //... insertions<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You want to use a ListIterator.  
					<delay>2</delay>
					You can get one of these from any kind of list, though for efficiency you probably want to get one from a LinkedList.

					<delay>2</delay>
					import java.util.*;<break/>class TestListIterator {<break/>  public static void main(String[]args) {<break/>    List&lt;Integer&gt; L = new LinkedList&lt;Integer&gt;();<break/>    L.add(0);<break/>    L.add(1);<break/>    L.add(2);<break/>    for (ListIterator&lt;Integer&gt; i = L.listIterator(); i.hasNext(); ) {<break/>      int x = i.next();<break/>      i.add(x + 10);<break/>    }<break/>    System.out.println(L);<break/>  }<break/>}<break/>
Prints [0, 10, 1, 11, 2, 12].

					<delay>2</delay>
				</li>
				<li>
					
					You may use a ListIterator which has support for a remove/add method during the iteration itself.

					<delay>2</delay>
					ListIterator&lt;Book&gt; iter = books.listIterator();<break/>while(iter.hasNext()){<break/>    if(iter.next().getIsbn().equals(isbn)){<break/>        iter.add(new Book(...));<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java ^ adding elements ^ list ^ iterating </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Which comes first in a 2D array, rows or columns? -->
			^ comes first ^ 2d array ^ rows ^ columns 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Instinctively one thinks geometrically:
					<delay>2</delay>
					horizontal (X) axis and then vertical (Y) axis.
					<delay>2</delay>
					This is not, however, the case with a 2D array, rows come first and then columns.

					<delay>2</delay>
					Consider the following analogy: in geometry one walks to the ladder (X axis) and climbs it (Y axis).
					<delay>2</delay>
					Conversely, in Java one descends the ladder (rows) and walks away (columns).

					<delay>2</delay>
				</li>
				<li>
					
					Java is considered "row major", meaning that it does rows first.
					<delay>2</delay>
					This is because a 2D array is an "array of arrays".

					<delay>2</delay>
					For example:  
int[ ][ ] a = new int[2][4];  // Two rows and four columns.<break/>a[0][0] a[0][1] a[0][2] a[0][3]<break/>a[1][0] a[1][1] a[1][2] a[1][3]<break/>

					<delay>2</delay>
					It can also be visualized more like this:
a[0] -&gt;  [0] [1] [2] [3]<break/>a[1] -&gt;  [0] [1] [2] [3]<break/>

					<delay>2</delay>
					The second illustration shows the "array of arrays" aspect.
					<delay>2</delay>
					The first array contains {a[0] and a[1]}, and each of those is an array containing four elements, {[0][1][2][3]}.

					<delay>2</delay>
					TL;DR summary:

					<delay>2</delay>
					Array[number of arrays][how many elements in each of those arrays]<break/>
For more explanations, see also Arrays - 2-dimensional.

					<delay>2</delay>
				</li>
				<li>
					
					In Java, there are no multi-dimension arrays.
					<delay>2</delay>
					There are arrays of arrays.
					<delay>2</delay>
					So:
int[][] array = new int[2][3];<break/>

					<delay>2</delay>
					It actually consists of two arrays, each has three elements.

					<delay>2</delay>
				</li>
				<li>
					
					While Matt B's may be true in one sense, it may help to think of Java multidimensional array without thinking about geometeric matrices at all.  
					<delay>2</delay>
					Java multi-dim arrays are simply arrays of arrays, and each element of the first-"dimension" can be of different size from the other elements, or in fact can actually store a null "sub"-array.  
					<delay>2</delay>
					See comments under this question 

					<delay>2</delay>
				</li>
				<li>
					
					In java the rows are done first, because a 2 dimension array is considered two separate arrays.
					<delay>2</delay>
					Starts with the first row 1 dimension array.

					<delay>2</delay>
				</li>
				<li>
					
					All depends on your visualization of the array.
					<delay>2</delay>
					Rows and Columns are properties of visualization (probably in your imagination) of the array, not the array itself. 

					<delay>2</delay>
					It's exactly the same as asking is number "5" red or green?

					<delay>2</delay>
					I could draw it red
					<delay>2</delay>
					, I could draw it greed right?
					<delay>2</delay>
					Color is not an integral property of a number.
					<delay>2</delay>
					In the same way representing 2D array as a grid of rows and columns is not necessary for existence of this array. 

					<delay>2</delay>
					2D array has just first dimention and second dimention, everything related to visualizing those is purely your flavour.

					<delay>2</delay>
					When I have char array char[80][25], I may like to print it on console rotated so that I have 25 rows of 80 characters that fits the screen without scroll. 

					<delay>2</delay>
					I'll try to provide viable example when representing 2D array as rows and columns
					<delay>2</delay>
					doesn't make sense at all
					<delay>2</delay>
					: Let's say I need an array of 1 000 000 000 integers.
					<delay>2</delay>
					My machine has 8GB of RAM, so I have enough memory for this, but if you try executing var a = new int[1000000000], you'll most likely get OutOfMemory exception.
					<delay>2</delay>
					That's because of memory fragmentation - there is no consecutive block of memory of this size.
					<delay>2</delay>
					Instead you you can create 2D array 10 000
					<delay>2</delay>
					x 100 000
					<delay>2</delay>
					with your values.
					<delay>2</delay>
					Logically it is 1D array, so you'd like to draw and imagine it as a single sequence of values, but due to technical implementation it is 2D.

					<delay>2</delay>
				</li>
				<li>
					
					The best way to remember if rows or columns come first would be writing a comment and mentioning it.

					<delay>2</delay>
					Java does not store a 2D Array as a table with specified rows and columns, it stores it as an array of arrays, like many other answers explain.
					<delay>2</delay>
					So you can decide, if the first or second dimension is your row.
					<delay>2</delay>
					You just have to read the array depending on that.

					<delay>2</delay>
					So, since I get confused by this all the time myself, I always write a comment that tells me, which dimension of the 2d Array is my row, and which is my column.

					<delay>2</delay>
				</li>
				<li>
					
					In c++ (distant, dusty memory)
					<delay>2</delay>
					I think it was a little easier to look at the code and understand arrays than it is in Java sometimes.  
					<delay>2</delay>
					Both are row major.  
					<delay>2</delay>
					This illustration worked for me in helping to understand.

					<delay>2</delay>
					Given this code for a 2d array of strings...
    String[][] messages; <break/>    messages = new String[][] {<break/>        {&quot;CAT&quot;,&quot;DOG&quot;,&quot;YIN&quot;,&quot;BLACK&quot;,&quot;HIGH&quot;,&quot;DAY&quot;},<break/>        {&quot;kitten&quot;,&quot;puppy&quot;,&quot;yang&quot;,&quot;white&quot;,&quot;low&quot;,&quot;night&quot;} <break/>    };<break/>    <break/>    int row = messages.length;<break/>    int col = messages[0].length;<break/>    <break/>
Naming my ints as if it were a 2d array (row, col)
					<delay>2</delay>
					we see the values.

					<delay>2</delay>
					row = (int) 2<break/>col = (int) 6<break/>

					<delay>2</delay>
					The last two lines of code, where we try to determine size and set them to row and col does not look all that intuitive and its not necessarily right.

					<delay>2</delay>
					What youre really dealing with here is this (note new variable names to illustrate):
int numOfArraysIn = messages.length;<break/>int numOfElementsIn0 = messages[0].length;<break/>int numOfElementsIn1 = messages[1].length;<break/>
Where messages.length tells you messages holds two arrays.
					<delay>2</delay>
					An array of arrays.

					<delay>2</delay>
					AND then messages[x].length yields the size of each of the individual
					<delay>2</delay>
					arrays 0     String[][] messages; <break/>    messages = new String[][] {<break/>        {&quot;CAT&quot;,&quot;DOG&quot;,&quot;YIN&quot;,&quot;BLACK&quot;,&quot;HIGH&quot;,&quot;DAY&quot;},<break/>        {&quot;kitten&quot;,&quot;puppy&quot;,&quot;yang&quot;,&quot;white&quot;,&quot;low&quot;,&quot;night&quot;} <break/>    };<break/>    <break/>    int row = messages.length;<break/>    int col = messages[0].length;<break/>    <break/>0 inside     String[][] messages; <break/>    messages = new String[][] {<break/>        {&quot;CAT&quot;,&quot;DOG&quot;,&quot;YIN&quot;,&quot;BLACK&quot;,&quot;HIGH&quot;,&quot;DAY&quot;},<break/>        {&quot;kitten&quot;,&quot;puppy&quot;,&quot;yang&quot;,&quot;white&quot;,&quot;low&quot;,&quot;night&quot;} <break/>    };<break/>    <break/>    int row = messages.length;<break/>    int col = messages[0].length;<break/>    <break/>1.

					<delay>2</delay>
					    String[][] messages; <break/>    messages = new String[][] {<break/>        {&quot;CAT&quot;,&quot;DOG&quot;,&quot;YIN&quot;,&quot;BLACK&quot;,&quot;HIGH&quot;,&quot;DAY&quot;},<break/>        {&quot;kitten&quot;,&quot;puppy&quot;,&quot;yang&quot;,&quot;white&quot;,&quot;low&quot;,&quot;night&quot;} <break/>    };<break/>    <break/>    int row = messages.length;<break/>    int col = messages[0].length;<break/>    <break/>2

					<delay>2</delay>
					When we print with a for each loop....
    String[][] messages; <break/>    messages = new String[][] {<break/>        {&quot;CAT&quot;,&quot;DOG&quot;,&quot;YIN&quot;,&quot;BLACK&quot;,&quot;HIGH&quot;,&quot;DAY&quot;},<break/>        {&quot;kitten&quot;,&quot;puppy&quot;,&quot;yang&quot;,&quot;white&quot;,&quot;low&quot;,&quot;night&quot;} <break/>    };<break/>    <break/>    int row = messages.length;<break/>    int col = messages[0].length;<break/>    <break/>3
Trying to drop the brackets and print like this gives an error
    String[][] messages; <break/>    messages = new String[][] {<break/>        {&quot;CAT&quot;,&quot;DOG&quot;,&quot;YIN&quot;,&quot;BLACK&quot;,&quot;HIGH&quot;,&quot;DAY&quot;},<break/>        {&quot;kitten&quot;,&quot;puppy&quot;,&quot;yang&quot;,&quot;white&quot;,&quot;low&quot;,&quot;night&quot;} <break/>    };<break/>    <break/>    int row = messages.length;<break/>    int col = messages[0].length;<break/>    <break/>4

					<delay>2</delay>
					The above is important to understand while setting up loops that use     String[][] messages; <break/>    messages = new String[][] {<break/>        {&quot;CAT&quot;,&quot;DOG&quot;,&quot;YIN&quot;,&quot;BLACK&quot;,&quot;HIGH&quot;,&quot;DAY&quot;},<break/>        {&quot;kitten&quot;,&quot;puppy&quot;,&quot;yang&quot;,&quot;white&quot;,&quot;low&quot;,&quot;night&quot;} <break/>    };<break/>    <break/>    int row = messages.length;<break/>    int col = messages[0].length;<break/>    <break/>5 to limit the step thru the array.

					<delay>2</delay>
				</li>
				<li>
					
					In TStringGrid cells property Col come first.

					<delay>2</delay>
					Property Cells[ACol, ARow: Integer]: string read GetCells write SetCells;<break/>

					<delay>2</delay>
					So the assignment StringGrid1.cells[2, 1] := 'abcde';
					<delay>2</delay>
					the value is displayed in the third column second row.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ comes first ^ 2d array ^ rows ^ columns </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Retrieving elemnts from an ArrayList by specifying the indexes -->
			^ retrieving elemnts ^ arraylist ^ specifying ^ indexes 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Yes you can use the subList method:

					<delay>2</delay>
					List&lt;...&gt; list2 = list1.subList(startIndex, endIndex);<break/>

					<delay>2</delay>
					This returns a view on that part of the original list, it does not copy the data.

					<delay>2</delay>
					If you want a copy:
List&lt;...&gt; list2 = new ArrayList&lt;...&gt; (list1.subList(startIndex, endIndex));<break/>

					<delay>2</delay>
				</li>
				<li>
					
					/create an ArrayList object<break/>    ArrayList arrayList = new ArrayList();<break/>    //Add elements to Arraylist<break/>    arrayList.add("1");<break/>    arrayList.add("2");<break/>    arrayList.add("3");<break/>    arrayList.add("4");<break/>    arrayList.add("5");<break/>    /*<break/>       To get a sub list of Java ArrayList use<break/>       List subList(int startIndex, int endIndex) method.<break/>       This method returns an object of type List containing elements from<break/>       startIndex to endIndex - 1.<break/>    */<break/>    List lst = arrayList.subList(1,3);<break/>    //display elements of sub list.<break/>    System.out.println("Sub list contains : ");<break/>    for(int i=0; i&lt; lst.size() ; i++)<break/>      System.out.println(lst.get(i));<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ retrieving elemnts ^ arraylist ^ specifying ^ indexes </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Is it possible to initialize array in an interface? -->
			^ possible ^ initialize array ^ interface 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Why don't you just try it out?

					<delay>2</delay>
					public interface Example {<break/>    int[] values = { 2, 3, 5, 7, 11 };<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Yes, but only if it's static.
					<delay>2</delay>
					In fact, any variables declared in an interface will automatically be static.

					<delay>2</delay>
					public interface ITest {<break/>    public static String[] test = {"1", "2"}; // this is ok<break/>    public String[] test2 = {"1", "2"}; // also ok, but will be silently converted to static by the compiler<break/>}<break/>

					<delay>2</delay>
					You can't have static initializers though.

					<delay>2</delay>
					public interface ITest {<break/>    public static String[] test;<break/>    static {<break/>        // this is not OK. No static initializers allowed in interfaces.<break/>    }<break/>}<break/>

					<delay>2</delay>
					Obviously, you can't have constructors in interfaces.

					<delay>2</delay>
				</li>
				<li>
					
					Yes, it's possible.
					<delay>2</delay>
					See the code:
public interface Test {<break/>  int[] a= {1,2,3};<break/>}<break/>public class Main {<break/>  public static void main(String[] args) {<break/>    int i1 = Test.a[0];<break/>    System.out.println(i1);<break/>  }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					
  Simple question - Is it posible to initalize array in an interface?

					<delay>2</delay>
					Yes.
  
					<delay>2</delay>
					This works
					<delay>2</delay>
					but i want to initialize array by "for" intsruction.
					<delay>2</delay>
					Ok thanks for help 

					<delay>2</delay>
					That's not a simple question
					<delay>2</delay>
					;)

					<delay>2</delay>
					You can't do this strictly because you can't add a static block to an interface.
					<delay>2</delay>
					But you can have a nested class or enum.

					<delay>2</delay>
					IMHO, that could be more confusing than useful as follows:
public interface I {<break/>    int[] values = Init.getValue();<break/>    enum Init {;<break/>        static int[] getValue() {<break/>            int[] arr = new int[5];<break/>            for(int i=0;i&lt;arr.length;i++)<break/>                arr[i] = i * i;<break/>            return arr;<break/>        }<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Firstly, I agreed with existing answers.

					<delay>2</delay>
					Further, I don’t think it’s a good idea to define data in an interface.

					<delay>2</delay>
					See &quot;Effective Java&quot;:
Item 19
					<delay>2</delay>
					: Use interfaces only to define types

					<delay>2</delay>
					The constant interface pattern is a poor use of interface.

					<delay>2</delay>
					To export constants in interface is bad idea.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ possible ^ initialize array ^ interface </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java: How to convert String[] to List or Set -->
			^ java ^ list ^ set 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					The easiest way would be:
String[] myArray = ...;<break/>List&lt;String&gt; strs = Arrays.asList(myArray);<break/>
using the handy Arrays utility class.
					<delay>2</delay>
					Note, that you can even do
List&lt;String&gt; strs = Arrays.asList("a", "b", "c");<break/>

					<delay>2</delay>
				</li>
				<li>
					
					java.util.Arrays.asList(new String[]{"a", "b"})<break/>

					<delay>2</delay>
				</li>
				<li>
					
					The easiest way is through  
Arrays.asList(stringArray);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					It's a old code, anyway, try it:
import java.util.Arrays;<break/>import java.util.List;<break/>import java.util.ArrayList;<break/>public class StringArrayTest<break/>{<break/>   public static void main(String[] args)<break/>   {<break/>      String[] words = {"word1", "word2", "word3", "word4", "word5"};<break/>      List&lt;String&gt; wordList = Arrays.asList(words);<break/>      for (String e : wordList)<break/>      {<break/>         System.out.println(e);<break/>      }<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Arrays.asList() would do the trick here.

					<delay>2</delay>
					String[] words = {"ace", "boom", "crew", "dog", "eon"};   <break/>List&lt;String&gt; wordList = Arrays.asList(words);  <break/>
For converting to Set, you can do as below
Set&lt;T&gt; mySet = new HashSet&lt;T&gt;(Arrays.asList(words)); <break/>

					<delay>2</delay>
				</li>
				<li>
					
					String[] w = {"a", "b", "c", "d", "e"};  <break/>List&lt;String&gt; wL = Arrays.asList(w);  <break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you really want to use a set:
String[] strArray = {"foo", "foo", "bar"};  <break/>Set&lt;String&gt; mySet = new HashSet&lt;String&gt;(Arrays.asList(strArray));<break/>System.out.println(mySet);<break/>
output:
[foo, bar]<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Collections.addAll provides the shortest (one-line) receipt 
Having
String[] array = {"foo", "bar", "baz"}; <break/>Set&lt;String&gt; set = new HashSet&lt;&gt;();<break/>
You can do as below
Collections.addAll(set, array); <break/>

					<delay>2</delay>
				</li>
				<li>
					
					Whilst this isn't strictly an answer to this question I think it's useful.

					<delay>2</delay>
					Arrays and Collections can bother be converted to Iterable which can avoid the need for performing a hard conversion.

					<delay>2</delay>
					For instance I wrote this to join lists/arrays of stuff into a string with a seperator
public static &lt;T&gt; String join(Iterable&lt;T&gt; collection, String delimiter) {<break/>    Iterator&lt;T&gt; iterator = collection.iterator();<break/>    if (!iterator.hasNext())<break/>        return "";<break/>    StringBuilder builder = new StringBuilder();<break/>    T thisVal = iterator.next();<break/>    builder.append(thisVal == null? "": thisVal.toString());<break/>    while (iterator.hasNext()) {<break/>        thisVal = iterator.next();<break/>        builder.append(delimiter);<break/>        builder.append(thisVal == null? "": thisVal.toString());<break/>    }<break/>    return builder.toString();<break/>}<break/>

					<delay>2</delay>
					Using iterable means you can either feed in an ArrayList or similar aswell as using it with a String... parameter without having to convert either.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java ^ list ^ set </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Converting byte[] or String to Dom Document -->
			^ string ^ dom document 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You need a DocumentBuilder and to call parse() on it using an InputSource configured with the string of XML via a StringReader.

					<delay>2</delay>
					Don't call parse() directly with the string, since it'll interpret that string as a URI referencing the XML!

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ string ^ dom document </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Memory allocation in array of java -->
			^ memory allocation ^ array ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Java matrices are arrays of arrays, for example first row can be 10-elements while second row cen be 40 element long.
					<delay>2</delay>
					I think it is not contiguous when not being square-matrix.
					<delay>2</delay>
					But you can be sure when iterating through last index-block it is contiguous.

					<delay>2</delay>
					 a[100][500][64]<break/> a[5][5][0 to 63] contiguous<break/> a[5][0 to 5][5] not contiguous<break/> a[0 to 5][5][5] not contiguous and maybe there will be cache-critical stalls<break/>

					<delay>2</delay>
				</li>
				<li>
					
					There is no way of telling, since even using JNI insulates you from the actual implementation.

					<delay>2</delay>
					That being said, it is probably true that most practical implementations allocate array elements as contiguous internal blocks of memory.

					<delay>2</delay>
				</li>
				<li>
					
					The Java specs do not require either choice, and in fact do not offer any way of observing either choice.

					<delay>2</delay>
					If I write a JVM in Javascript, for example, arrays would probably be non-contiguous.

					<delay>2</delay>
					That said, I would strongly assume that most actual JVMs do use contiguous memory.

					<delay>2</delay>
				</li>
				<li>
					
					In most JVMs the entire heap is continous, so you can reasonably assume that arrays are allocated continously.

					<delay>2</delay>
					Note: Even if an Array of references are continuous, but the objects they reference could be anywhere.  
					<delay>2</delay>
					They will probably be together but they might not me.

					<delay>2</delay>
					e.g.

					<delay>2</delay>
					String[] strings = "a,b,c,d,e,f".split(",");<break/>
Strings is an array of references, the individual String objects and their char[] objects could be anywhere.
					<delay>2</delay>
					Note: all the Strings are likely to use the same char[]

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ memory allocation ^ array ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Optimal way to sort an array -->
			^ optimal way ^ sort ^ array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Use some kind of QuickSort or MergeSort
if you want to implement fast sorting on your own.

					<delay>2</delay>
					Otherwise use the built in java sort functions.

					<delay>2</delay>
				</li>
				<li>
					
					When you have the the Power bring it to good use...
					<delay>2</delay>
					Why reinvent the wheel ???
Use  Arrays.sort() to sort the Array.

					<delay>2</delay>
					- If what you hold in the Array is some kind of object and it needs to be sorted in More than One way.... then first convert it in to a ArrayList (or List) using Arrays.asList(array)
Eg:
Song[] dog = new Song[10];<break/> ArrayList&lt;Song&gt; list = new ArrayList&lt;Song&gt;(Arrays.asList(arr));<break/>
Then use java.util.Comparator Interface, to sort the Object on basis of more than one attribute. 

					<delay>2</delay>
					Eg:
          Class Song can be sorted on the basis of its track title or Singer and more using Comparator Interface.

					<delay>2</delay>
					- Using Collections are lot more flexible than Array.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ optimal way ^ sort ^ array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Why java allows private String[][] var[] -->
			
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					The code is the same as this:
private String[][][] var;<break/>
All these forms are equivalent:
private String[][][] var;<break/>private String[][] var[];<break/>private String[] var[][];<break/>private String var[][][];<break/>

					<delay>2</delay>
					And they all mean the same: a three-dimensional array of strings.
					<delay>2</delay>
					The String var[][][] syntax may seem a bit weird, but it's like that for making C/C++ programmers feel right at home in Java (that's how you normally declare an array type in C/C++).

					<delay>2</delay>
					In Java, the String[][][] var syntax is preferred, as it makes clear that the type of var is String[][][], in the other syntax and its different variations the type information is split before and after the variable - although it's perfectly legal from the compiler's view point, it's harder to read.

					<delay>2</delay>
					Even weirder, all these method declarations are legal and equivalent:
String[][][] m()  {return null;}<break/>String[][] m() [] {return null;}<break/>String[] m() [][] {return null;}<break/>String m() [][][] {return null;}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Oscar's answer is pretty good.
					<delay>2</delay>
					If one were to read String[][] var[] in English, one would say "var is an array of two-dimensional String arrays" thus "var is a three-dimensional String array"

					<delay>2</delay>
				</li>
				<li>
					
					The Java Language Specification says 
  "Brackets are allowed in declarators as a nod to the tradition of C
  and C++.
					<delay>2</delay>
					The general rules for variable declaration, however, permit
  brackets to appear on both the type and in declarators, so that the
  local variable declaration"
in JLS 10.2 .
					<delay>2</delay>
					In my opinion square brackets ([]) in "types" make more sense of an array than that is in declared variables.
					<delay>2</delay>
					But in order to confirm to the tradition of C/C++ it was done as the text says in JLS.
					<delay>2</delay>
					Another thing is , mixing the square bracket with both types and variables would be confusing to the readers/programmers. 

					<delay>2</delay>
				</li>
				<li>
					
					This is an example that shows you when the [] position makes a difference.

					<delay>2</delay>
					String[] arr, arr2[];<break/>

					<delay>2</delay>
					The arr is an array of String whereas the arr2 is an array of arrays of String.

					<delay>2</delay>
					It can as you see be beneficial if you want to declare different arrays on the same line.

					<delay>2</delay>
					And in your example it could have been another var2 declared on the same line:
private String[][] var[], var2;<break/>

					<delay>2</delay>
				</li>
				<li>
					
					According to the JLS 10.2 in the section about Array's:
  The [] may appear as part of the type at the beginning of the declaration, or as part of the declarator for a particular variable, or both.
  
  
					<delay>2</delay>
					For example:
  
  byte[] rowvector, colvector, matrix[];
  This declaration is equivalent to:
  
  byte rowvector[], colvector[], matrix[][];
(Emphasis mine)
Note especially the last example where it says byte[] matrix[] is equivalent to byte matrix[][]. 

					<delay>2</delay>
					So no, it is not a bug, simply a design choice. 

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback></postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Array of 400 ints -->
			^ array ^ 400 ints 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Do like below as you can do this kind of assignment during initialization only.

					<delay>2</delay>
					Also note, there is no dimension parameter required(allowed)
					<delay>2</delay>
					in this case
    int[] newArray = new int[]{8,2,22,97,38,15,0,40,0,75,4,5,7,78,52,12,50,77,91,8,49,49,99,40,17,81,18,57,60,87,17,40,98,43,69,48,4,56,62,0,81,49,31,73,55,79,14,29,93,71,40,67,53,88,30,3,49,13,36,65,52,70,95,23,4,60,11,42,69,24,68,56,1,32,56,71,37,2,36,91,22,31,16,71,51,67,63,89,41,92,36,54,22,40,40,28,66,33,13,80,24,47,32,60,99,3,45,2,44,75,33,53,78,36,84,20,35,17,12,50,32,98,81,28,64,23,67,10,26,38,40,67,59,54,70,66,18,38,64,70,67,26,20,68,2,62,12,20,95,63,94,39,63,8,40,91,66,49,94,21,24,55,58,5,66,73,99,26,97,17,78,78,96,83,14,88,34,89,63,72,21,36,23,9,75,0,76,44,20,45,35,14,0,61,33,97,34,31,33,95,78,17,53,28,22,75,31,67,15,94,3,80,4,62,16,14,9,53,56,92,16,39,5,42,96,35,31,47,55,58,88,24,0,17,54,24,36,29,85,57,86,56,0,48,35,71,89,7,5,44,44,37,44,60,21,58,51,54,17,58,19,80,81,68,5,94,47,69,28,73,92,13,86,52,17,77,4,89,55,40,4,52,8,83,97,35,99,16,7,97,57,32,16,26,26,79,33,27,98,66,88,36,68,87,57,62,20,72,3,46,33,67,46,55,12,32,63,93,53,69,4,42,16,73,38,25,39,11,24,94,72,18,8,46,29,32,40,62,76,36,20,69,36,41,72,30,23,88,34,62,99,69,82,67,59,85,74,4,36,16,20,73,35,29,78,31,90,1,74,31,49,71,48,86,81,16,23,57,5,54,1,70,54,71,83,51,54,69,16,92,33,48,61,43,52,1,89,19,67,48};<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Have you tried this syntax?

					<delay>2</delay>
					        int[] newArray = new int[] {8,2,22,97,38,15,0,40,0,75,4,5,7,78,52,12,50,77,91,8,49,49,99,40,17,81,18,57,60,87,17,40,98,43,69,48,4,56,62,0,81,49,31,73,55,79,14,29,93,71,40,67,53,88,30,3,49,13,36,65,52,70,95,23,4,60,11,42,69,24,68,56,1,32,56,71,37,2,36,91,22,31,16,71,51,67,63,89,41,92,36,54,22,40,40,28,66,33,13,80,24,47,32,60,99,3,45,2,44,75,33,53,78,36,84,20,35,17,12,50,32,98,81,28,64,23,67,10,26,38,40,67,59,54,70,66,18,38,64,70,67,26,20,68,2,62,12,20,95,63,94,39,63,8,40,91,66,49,94,21,24,55,58,5,66,73,99,26,97,17,78,78,96,83,14,88,34,89,63,72,21,36,23,9,75,0,76,44,20,45,35,14,0,61,33,97,34,31,33,95,78,17,53,28,22,75,31,67,15,94,3,80,4,62,16,14,9,53,56,92,16,39,5,42,96,35,31,47,55,58,88,24,0,17,54,24,36,29,85,57,86,56,0,48,35,71,89,7,5,44,44,37,44,60,21,58,51,54,17,58,19,80,81,68,5,94,47,69,28,73,92,13,86,52,17,77,4,89,55,40,4,52,8,83,97,35,99,16,7,97,57,32,16,26,26,79,33,27,98,66,88,36,68,87,57,62,20,72,3,46,33,67,46,55,12,32,63,93,53,69,4,42,16,73,38,25,39,11,24,94,72,18,8,46,29,32,40,62,76,36,20,69,36,41,72,30,23,88,34,62,99,69,82,67,59,85,74,4,36,16,20,73,35,29,78,31,90,1,74,31,49,71,48,86,81,16,23,57,5,54,1,70,54,71,83,51,54,69,16,92,33,48,61,43,52,1,89,19,67,48};<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can't assign an array that way.
					<delay>2</delay>
					Instead, you should use the proper initialization syntax:
int[] newArray = new int[]{1,2,3,4,...};<break/>

					<delay>2</delay>
					NetBeans is complaining because newArray = {1,2,3,4,...} is bad syntax.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ array ^ 400 ints </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Is there a way to initialize an array with an enumeration of integers in Java -->
			^ way ^ initialize ^ array ^ enumeration ^ integers ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Not using built-in language features.
					<delay>2</delay>
					You can easily write a method to do it, of course, but there's nothing built-in - and I suspect that it's sufficiently rarely useful that it's not in many third party utility libraries (such as Guava) either.

					<delay>2</delay>
				</li>
				<li>
					
					I don't think so, but you could use a simple for-loop:
int foo[n];<break/>for(int i = 0; i &lt; n; i++) foo[i] = i;<break/>

					<delay>2</delay>
					And if you want a method try something like this:

					<delay>2</delay>
					public void initialize(int[] array, int start, int end) {<break/>    int array_length = array.length;<break/>    if (end &gt; array_length) end = array_length;<break/>    for (int i = start; i &lt; end; i++) {<break/>        array[i - start] = i;<break/>    }<break/>}<break/>// In any other point in your code<break/>int foo[] = new int[6];<break/>initialize(foo, 0, 10);<break/>

					<delay>2</delay>
					Another way would be to make a Range class to add this functionality:

					<delay>2</delay>
					import java.util.Arrays;<break/>import java.util.Iterator;<break/>import java.util.List;<break/>public class Range implements Iterable&lt;Integer&gt; {<break/>    Integer array[];<break/>    public Range(int size) {<break/>        this(0, size - 1);<break/>    }<break/>    public Range(int start, int end) {<break/>        array = new Integer[end - start];<break/>        for (int i = start; i &lt; end; i++) {<break/>            array[i - start] = i;<break/>        }<break/>    }<break/>    public List&lt;Integer&gt; asList() {<break/>        return Arrays.asList(array);<break/>    }<break/>    @Override<break/>    public Iterator&lt;Integer&gt; iterator() {<break/>        return Arrays.asList(array).iterator();<break/>    }<break/>}<break/>
Here is an usage example:

					<delay>2</delay>
					Range range = new Range(4, 10);<break/>for (int i : range) {<break/>    System.out.println(i);<break/>}<break/>

					<delay>2</delay>
					I'm sure that this code can be improved but it isn't worth it.

					<delay>2</delay>
				</li>
				<li>
					
					int n = 10;<break/>int[] arr = new int[n+1];<break/>
for loops has flexible syntax, so you can do even this:
for ( int i = 0; i &lt; arr.length; arr[i] = i++ );<break/>
P.S. 

					<delay>2</delay>
					If you want less code than above, you can do this:
int i = 0;<break/>for ( int c : arr ) { arr[i] = i++; }<break/>
P.P.S. 
Despite the fact that these pieces of code are laconic, for me they seems unclear, and smells bad.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ way ^ initialize ^ array ^ enumeration ^ integers ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to detect special characters like ^A in a byte array -->
			^ detect special characters like ^ byte array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					If you don't use a fancy encoding all uppercase letters will have values from 65 to 90 and all lowercase letters are between 97 and 122.
					<delay>2</delay>
					(See ASCII Encoding).
					<delay>2</delay>
					All bytes with other values are not letters of the alphabet.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ detect special characters like ^ byte array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- C++ to java array conversions -->
			^ java array conversions 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					jshortArray convertShortArrayToJNI(JNIEnv* env, short* arr, size_t count) {<break/>  jshortArray retval = env-&gt;NewShortArray(count);<break/>  env-&gt;SetShortArrayRegion(retval,0,count,arr);<break/>  return retval;<break/>}<break/>

					<delay>2</delay>
					You don't need to free the retval.
					<delay>2</delay>
					It is a "local reference", which means that it will be freed by JVM as soon as you return through JNI from the recent call.
					<delay>2</delay>
					Unless you are calling it from a native thread, of course...

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java array conversions </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How do you store three different objects in a list array in Java -->
			^ store three different objects ^ list array ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					The best and also Object Oriented approach is to Create a class with surname, forename and result as attributes(instance variables) like below:
class Student{<break/>private String surname;<break/>private String forename;<break/>private String result;<break/>public Details(String surname, String forename, String res){<break/>   //initialize properties here<break/>  }<break/>}<break/>
now, create a List which only accepts Student Object.

					<delay>2</delay>
					List&lt;Student&gt; list = new ArrayList&lt;Student&gt;();<break/>list.add(new Student("surname", "forname", "pass"));<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ store three different objects ^ list array ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- An array only allowing certain values 0-9 & A-F for Java -->
			^ array ^ allowing certain values 0 ^ 9 ^ f ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You can restrict user to enter another value by this: (This program is for if You are taking values from user).
					<delay>2</delay>
					This will asks for number until you enter number within 0 to 9.

					<delay>2</delay>
					You can make your code according to this.
					<delay>2</delay>
					(This is just for your reference, How can you restrict user to enter wrong thing)
Scanner scan=new Scanner(System.in);<break/>int i=-1;<break/>i=scan.nextInt();<break/>while(i&lt;=0 &amp;&amp; i&gt;=9){<break/>    i=scan.nextInt();<break/>}<break/>
EDIT

					<delay>2</delay>
					As per your comment, In that case you need to change this as:
String s="";<break/>while(!s.matches("^[0-9A-F]+$")){<break/>    s=scan.nextLine();<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					I would create a class to hold the RGB values and have it check that the correct values are entered.  
					<delay>2</delay>
					See the test code below....
					<delay>2</delay>
					you can expand as you need to handle more cases.

					<delay>2</delay>
					import java.util.*;<break/>public class jtest<break/>{<break/>  public static void main(String args[])<break/>  {<break/>    new jtest();<break/>  }<break/>  public jtest()<break/>  {<break/>    ArrayList&lt;RGB&gt; RGBarray = new ArrayList&lt;RGB&gt;();<break/>    try<break/>    {<break/>    RGBarray.add(new RGB("F"));<break/>    RGBarray.add(new RGB("J"));<break/>    }<break/>    catch(BadRGBValueException BRGBVE)<break/>    {<break/>      BRGBVE.printStackTrace();<break/>    }<break/>  }<break/>  class BadRGBValueException extends Exception<break/>  {<break/>    public BadRGBValueException(String message)<break/>    {<break/>      super(message);<break/>    }<break/>  }<break/>  class RGB<break/>  {<break/>    public RGB(String input) throws BadRGBValueException<break/>    {<break/>      if (!input.matches("^[0-9A-F]+$"))<break/>      {<break/>        throw new BadRGBValueException(input + " is not a valid RGB value");<break/>      }<break/>      value = input;<break/>    }<break/>    private String value = null;<break/>  }<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ array ^ allowing certain values 0 ^ 9 ^ f ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to fill an array of characters from user input? -->
			^ fill ^ array ^ characters ^ user input 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					
  I googled it a lot and found nothing!
					<delay>2</delay>
					Could someone help me with
  filling an array of characters from user input, please?

					<delay>2</delay>
					My Google said, try this one..
Option 1 :
    import java.io.*;<break/>   class array {<break/>    public static void main(String args[]) throws IOException {<break/>        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));<break/>        String tmp = br.readLine();<break/>        int length = tmp.length();<break/>        char c[] = new char[length];<break/>        tmp.getChars(0, length, c, 0);<break/>        CharArrayReader input1 = new CharArrayReader(c);<break/>        int i;<break/>        System.out.print("input1 is:");<break/>        while ((i = input1.read()) != -1) {<break/>            System.out.print((char) i);<break/>        }<break/>    }<break/>}<break/>
Option 2:
class array<break/>{<break/>    public static void main(String args[])<break/>    {<break/>        Scanner sc=new Scanner(System.in);<break/>        System.out.println("Please enter elements...");<break/>        char[] a=sc.next().toCharArray();<break/>        System.out.println("Array elements are : ");<break/>        for (int i=0;i&lt;a.length;i++)<break/>            System.out.println(a[i]);<break/>    }<break/>}<break/>

					<delay>2</delay>
					But, in this case, it won't accept after space character.

					<delay>2</delay>
					Before, start your coding in Java, you must know these terms :
BufferedReader
Exception handling

					<delay>2</delay>
				</li>
				<li>
					
					If you want to be able to read a word and split it into an array of characters you can use.

					<delay>2</delay>
					char[] chars = scanner.next().toCharArray();<break/>

					<delay>2</delay>
				</li>
				<li>
					
					   /* program below takes an string from user, splits into character and display as array of characters. */  <break/>     package com.demo.mum;<break/>        import java.io.BufferedReader;<break/>        import java.io.IOException;<break/>        import java.io.InputStreamReader;<break/>        /**<break/>         * @author cyruses<break/>         * <break/>         */<break/>        public class CharacterArray {<break/>            public static void main(String args[]) throws IOException {<break/>                BufferedReader br = new BufferedReader(new InputStreamReader(System.in));<break/>                System.out.println("Enter the string:");<break/>                String tmp = br.readLine();<break/>                int strLen = tmp.length();<break/>                char c[] = new char[strLen];<break/>                for (int i = 0; i &lt; c.length; i++) {<break/>                    c[i] = tmp.charAt(i);<break/>                }<break/>                System.out.println("Displaying character Array");<break/>                for (int i = 0; i &lt; c.length; i++) {<break/>                    System.out.println(c[i]);<break/>                }<break/>        }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					This code is part of my program for linear searching, I fixed the issue I was facing.
					<delay>2</delay>
					But I want explanation about why I was getting exception on charAt(x) and not on charAt(0).

					<delay>2</delay>
					        System.out.println("Enter Your Data in character");<break/>        for(x=0;x&lt;char_array.length;x++)<break/>        {<break/>        Scanner input_list_char = new Scanner(System.in);<break/>        char_array[x]=input_list_char.next().charAt(0); //it works<break/>        char_array[x]=input_list_char.next().charAt(x); // give me exception<break/>
}

					<delay>2</delay>
				</li>
				<li>
					
					To input a character array from user
import java.io.*;<break/>class CharArrayInput {<break/>public static void main(String args[]) throws IOException {<break/>    /*using InputReader and BufferedReader class <break/>      to fill array of characters from user input.<break/>    */<break/>    InputStreamReader ir = new InputStreamReader(System.in);<break/>    BufferedReader br = new BufferedReader(ir);<break/>    //Take size of array from user.<break/>    System.out.println("Please enter size of array")<break/>    int n = Integer.parseInt(br.readLine());<break/>    //Declare a character array<break/>    char arr[] = new char[n];<break/>    //loop to take input of array elements<break/>    for(int i=0; i &lt; n; i++){<break/>    arr[i] = (char)br.read();<break/>    }   <break/>   }<break/>  }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					//more fun ...............
public class test3 {<break/>    public static void main(String args[])<break/>    {<break/>        char crr[]=new char[100];<break/>        Scanner inputs=new Scanner(System.in);<break/>        System.out.println("enter the string");<break/>        for(int i=0;i&lt;10;i++)<break/>        {<break/>            char c=inputs.next().charAt(0);<break/>            crr[i]= c;<break/>        }<break/>        for(int i=0;i&lt;10;i++)<break/>        {<break/>            System.out.println(" " +crr[i]);<break/>        }<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can't take input directly in charArray using nextChar() because there is no nextChar() in Java.
					<delay>2</delay>
					You first have to take input in String then fetch character one by one.

					<delay>2</delay>
					import java.util.*;<break/>class CharArray{<break/>    public static void main(String[] args)<break/>    { <break/>    Scanner scan=new Scanner(System.in); <break/>    char ch[]=new char[11];<break/>    String s = scan.nextLine();<break/>    for(int i=0;i&lt;=10;i++)  <break/>    ch[i]=s.charAt(i);  //Input in CharArray<break/>    System.out.println("Output of CharArray: ");<break/>        for(int i=0;i&lt;=10;i++) <break/>        System.out.print(ch[i]); //Output of CharArray<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ fill ^ array ^ characters ^ user input </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Converting a file to short array and vice versa -->
			^ converting ^ file ^ short array ^ vice versa 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					I really doubt if SHORT if possible.
					<delay>2</delay>
					Nevertheless, you can check out Apache Commons File Utils for reading file as byte[] and vice verse.

					<delay>2</delay>
					public static byte[] readFileToByteArray(File file) throws IOException<break/>

					<delay>2</delay>
				</li>
				<li>
					
					The snippet below reads a file using FileInputStream, and writes the file to the given path using FileOutputStream.

					<delay>2</delay>
					Java Code:
byte[] fileBArray = new byte[(int)file.length()];<break/>FileInputStream fis = new FileInputStream(file);<break/>fis.read(fileBArray);<break/>FileOutputStream fos = new FileOutputStream("C:\\abc.jpg");<break/>fos.write(fileBArray);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					This is better example:
import java.io.BufferedInputStream;<break/>import java.io.BufferedOutputStream;<break/>import java.io.ByteArrayOutputStream;<break/>import java.io.File;<break/>import java.io.FileInputStream;<break/>import java.io.FileNotFoundException;<break/>import java.io.FileOutputStream;<break/>import java.io.IOException;<break/>import java.io.InputStream;<break/>import java.io.OutputStream;<break/>/**  <break/> Converting binary data into different forms.<break/> &lt;P&gt;Reads binary data into memory, and writes it back out.<break/> (If your're actually copying a file, there are better ways to do this.)<break/> &lt;P&gt;Buffering is used when reading and writing files, to minimize the number <break/> of interactions with the disk.<break/>*/<break/>public final class BytesStreamsAndFiles {<break/>  /** Change these settings before running this class. */<break/>  private static final String INPUT_FILE_NAME = "C:\\TEMP\\cottage.jpg";<break/>  private static final String OUTPUT_FILE_NAME = "C:\\TEMP\\cottage_copy.jpg";<break/>  /** Run the example. */<break/>  public static void main(String... aArgs) {<break/>    BytesStreamsAndFiles test = new BytesStreamsAndFiles();<break/>    //read in the bytes<break/>    byte[] fileContents = test.read(INPUT_FILE_NAME);<break/>    //test.readAlternateImpl(INPUT_FILE_NAME);<break/>    //write it back out to a different file name<break/>    test.write(fileContents, OUTPUT_FILE_NAME);<break/>  }<break/>  /** Read the given binary file, and return its contents as a byte array.*/ <break/>  byte[] read(String aInputFileName){<break/>    log("Reading in binary file named : " + aInputFileName);<break/>    File file = new File(aInputFileName);<break/>    log("File size: " + file.length());<break/>    byte[] result = new byte[(int)file.length()];<break/>    try {<break/>      InputStream input = null;<break/>      try {<break/>        int totalBytesRead = 0;<break/>        input = new BufferedInputStream(new FileInputStream(file));<break/>        while(totalBytesRead &lt; result.length){<break/>          int bytesRemaining = result.length - totalBytesRead;<break/>          //input.read() returns -1, 0, or more :<break/>          int bytesRead = input.read(result, totalBytesRead, bytesRemaining); <break/>          if (bytesRead &gt; 0){<break/>            totalBytesRead = totalBytesRead + bytesRead;<break/>          }<break/>        }<break/>        /*<break/>         the above style is a bit tricky: it places bytes into the 'result' array; <break/>         'result' is an output parameter;<break/>         the while loop usually has a single iteration only.<break/>        */<break/>        log("Num bytes read: " + totalBytesRead);<break/>      }<break/>      finally {<break/>        log("Closing input stream.");<break/>        input.close();<break/>      }<break/>    }<break/>    catch (FileNotFoundException ex) {<break/>      log("File not found.");<break/>    }<break/>    catch (IOException ex) {<break/>      log(ex);<break/>    }<break/>    return result;<break/>  }<break/>  /**<break/>   Write a byte array to the given file. <break/>   Writing binary data is significantly simpler than reading it. <break/>  */<break/>  void write(byte[] aInput, String aOutputFileName){<break/>    log("Writing binary file...");<break/>    try {<break/>      OutputStream output = null;<break/>      try {<break/>        output = new BufferedOutputStream(new FileOutputStream(aOutputFileName));<break/>        output.write(aInput);<break/>      }<break/>      finally {<break/>        output.close();<break/>      }<break/>    }<break/>    catch(FileNotFoundException ex){<break/>      log("File not found.");<break/>    }<break/>    catch(IOException ex){<break/>      log(ex);<break/>    }<break/>  }<break/>  /** Read the given binary file, and return its contents as a byte array.*/ <break/>  byte[] readAlternateImpl(String aInputFileName){<break/>    log("Reading in binary file named : " + aInputFileName);<break/>    File file = new File(aInputFileName);<break/>    log("File size: " + file.length());<break/>    byte[] result = null;<break/>    try {<break/>      InputStream input =  new BufferedInputStream(new FileInputStream(file));<break/>      result = readAndClose(input);<break/>    }<break/>    catch (FileNotFoundException ex){<break/>      log(ex);<break/>    }<break/>    return result;<break/>  }<break/>  /**<break/>   Read an input stream, and return it as a byte array.  <break/>   Sometimes the source of bytes is an input stream instead of a file. <break/>   This implementation closes aInput after it's read.<break/>  */<break/>  byte[] readAndClose(InputStream aInput){<break/>    //carries the data from input to output :    <break/>    byte[] bucket = new byte[32*1024]; <break/>    ByteArrayOutputStream result = null; <break/>    try  {<break/>      try {<break/>        //Use buffering? No. Buffering avoids costly access to disk or network;<break/>        //buffering to an in-memory stream makes no sense.<break/>        result = new ByteArrayOutputStream(bucket.length);<break/>        int bytesRead = 0;<break/>        while(bytesRead != -1){<break/>          //aInput.read() returns -1, 0, or more :<break/>          bytesRead = aInput.read(bucket);<break/>          if(bytesRead &gt; 0){<break/>            result.write(bucket, 0, bytesRead);<break/>          }<break/>        }<break/>      }<break/>      finally {<break/>        aInput.close();<break/>        //result.close(); this is a no-operation for ByteArrayOutputStream<break/>      }<break/>    }<break/>    catch (IOException ex){<break/>      log(ex);<break/>    }<break/>    return result.toByteArray();<break/>  }<break/>  private static void log(Object aThing){<break/>    System.out.println(String.valueOf(aThing));<break/>  }<break/>}<break/>
for more detail go to : Reading and writing binary files

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ converting ^ file ^ short array ^ vice versa </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- JList - get number of selected elements in multi-select list -->
			^ jlist ^ get number ^ selected elements ^ multi ^ select list 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					JList.getSelectedIndices().length would give you the array length  :)
					<delay>2</delay>
					Refer Javadocs mate

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ jlist ^ get number ^ selected elements ^ multi ^ select list </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Convert String to array of integer in java -->
			^ convert string ^ array ^ integer ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Try this:
String[] array = "1,2,3,4,5".split(",");<break/>int[] result = new result[array.length];<break/>for (int i = 0; i &lt; array.length; i++) {<break/>    try {<break/>         result[i] = Integer.parseInt(array[i]);<break/>    } catch (NumberFormatException nfe) {};<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Use StringTokenizer which will split string by comma and then put those values/tokens in array of integers.

					<delay>2</delay>
					public static int[] getIntegers(String numbers) {<break/>    StringTokenizer st = new StringTokenizer(numbers, ",");<break/>    int[] intArr = new int[st.countTokens()];<break/>    int i = 0;<break/>    while (st.hasMoreElements()) {<break/>        intArr[i] = Integer.parseInt((String) st.nextElement());<break/>        i++;<break/>    }<break/>    return intArr;<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					From zvzdhk:
String[] array = "1,2,3,4,5".split(",");<break/>
Then, parse your integers:
int[] ints = new int[array.length];<break/>for(int i=0; i&lt;array.length; i++)<break/>{<break/>    try {<break/>        ints[i] = Integer.parseInt(array[i]);           <break/>    } catch (NumberFormatException nfe) {<break/>        //Not an integer <break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					String [] str = "1,2,3,4,5".split(",");<break/>int arrayInt[] = new int[str.length];<break/>for (int i = 0; i &lt; str.length; i++) <break/>    arrayInt[i]=Integer.valueOf(str[i]);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					With Guava you can do this in one line:
int[] array = Ints.toArray(Lists.newArrayList(Ints.stringConverter().convertAll(Splitter.on(",").split("1,2,3,4,5"))));<break/>

					<delay>2</delay>
					or so (if you don't require an array):
Iterable&lt;Integer&gt; ints = Ints.stringConverter().convertAll(Splitter.on(",").split("1,2,3,4,5"));<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ convert string ^ array ^ integer ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Quick array conversion from Java to C++ -->
			^ quick array conversion ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You would do it like so:
int array[][3] = {{0,0,0},{1,0,0}};<break/>

					<delay>2</delay>
					Only the first dimension may be omitted.

					<delay>2</delay>
				</li>
				<li>
					
					Like this:
int array[2][3] = {{0,0,0},{1,0,0}};<break/>
Or this, because the first dimension is optional:
int array[][3] = {{0,0,0},{1,0,0}};<break/>

					<delay>2</delay>
					And by the way, in Java the idiomatic way to declare the same array is this:
int[][] array = {{0,0,0},{1,0,0}}; // [][] goes before the variable name<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ quick array conversion ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Store my values as strings in the next row of the array? two-dimensional array? -->
			^ store ^ values ^ strings ^ next row ^ array ^ two ^ dimensional array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					As in your previous post you will have a problem with exceeding the bounds of your 10 x 4 array.

					<delay>2</delay>
					Consider using ArrayList of String Arrays instead.  
					<delay>2</delay>
					ArrayList (unlike array) can grow.

					<delay>2</delay>
					See if this small (unrelated sample) gives you enough hints:
import java.util.*;<break/>public class ListOfStrings {<break/>    public static void main(String[] args) {<break/>        ArrayList&lt;String[]&gt; los = new ArrayList&lt;String[]&gt;();<break/>        for(int i = 0; i&lt;=10; ++i) {<break/>            String[] str = {Integer.toString(i), "a" +i, "b"+i, "c" + i};<break/>            los.add(str);<break/>        }<break/>        for(String[] strArray : los) {<break/>            System.out.println();<break/>            for(String str : strArray) {<break/>                System.out.print(str + "\t");<break/>            }<break/>        }<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you absolutely have to use your two-dimensional array, then you will need nested loops to print it out.
for
for(int i=0; i &lt; FutureValueArray.length; ++i) {<break/>   System.out.println("whatever you print before each row);<break/>   for(int j=0; j &lt; utureValueArray[i]; ++j) {<break/>      Sytem.out.print(utureValueArray[i][j] + "\t");<break/>   }<break/>}<break/>
for each
for(String[] row : FutureValueArray) {<break/>   System.out.println("whatever you print before each row);<break/>   for(String cell : row) {<break/>      Sytem.out.print(cell + "\t"); <break/>   }<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ store ^ values ^ strings ^ next row ^ array ^ two ^ dimensional array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Hash Table Size Setting -->
			^ hash table size setting 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					No, you don't.
					<delay>2</delay>
					A quality implementation (Hashtable/HashMap) will resize itself automatically as the number of elements increases.

					<delay>2</delay>
					If you are talking about your own implementation, the answer depends on whether the hash table is capable of increasing the number of buckets as its size grows.

					<delay>2</delay>
					If you are worried about the performance implications of the resizing, the correct approach is to profile this in the context of your overall application.

					<delay>2</delay>
				</li>
				<li>
					
					No, in fact is bad to have it fixed to a certain value.

					<delay>2</delay>
					For more info you can start here with Wikipedia.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ hash table size setting </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Does the contains() method in Java ArrayList use binary search? -->
			^ java arraylist use binary search 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					No, you need to use Collections to use binary search, usually after sorting it.  
					<delay>2</delay>
					An ArrayList doesn't know anything about its ordering, and you have to know a list is sorted before you can use binary search.

					<delay>2</delay>
					Alternately, you could use TreeSet, which is as efficient as using a binary search.

					<delay>2</delay>
				</li>
				<li>
					
					No, it doesn't use binary search as lists don't have to be sorted.

					<delay>2</delay>
					Use the utility methods of the Collections class to first sort the list and then to perform a binary search.

					<delay>2</delay>
				</li>
				<li>
					
					No, it would mean adding a overhead at each insertion
					<delay>2</delay>
					so it's not included.

					<delay>2</delay>
					Here's the source code : it just tests all values :
218     public boolean contains(Object o) {<break/>219         return indexOf(o) &gt;= 0;<break/>220     }<break/>229     public int indexOf(Object o) {<break/>230         if (o == null) {<break/>231             for (int i = 0; i &lt; size; i++)<break/>232                 if (elementData[i]==null)<break/>233                     return i;<break/>234         } else {<break/>235             for (int i = 0; i &lt; size; i++)<break/>236                 if (o.equals(elementData[i]))<break/>237                     return i;<break/>238         }<break/>239         return -1;<break/>240     }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					No, you need to use Collections to use binary search, usually after sorting it. 

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java arraylist use binary search </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to write an array to allocate space for 5 things -->
			^ write ^ array ^ allocate space ^ 5 things 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You can do it like this:
private Object[] myObjects = new Object[5];<break/>
Change the type as needed.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ write ^ array ^ allocate space ^ 5 things </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How do you get the user to name an array in Java? -->
			^ get ^ user ^ name ^ array ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Normally you can't change the name of a variable (be it an array, or any other data type) after you've defined it, it's set in stone in the source code of the program.
					<delay>2</delay>
					Perhaps you meant something else?

					<delay>2</delay>
				</li>
				<li>
					
					You can achieve the desired effect by mapping a String to the array using Map&lt;String,Array&gt;.
					<delay>2</delay>
					See this answer for more details:
					<delay>2</delay>
					Assigning variables with dynamic names in Java

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ get ^ user ^ name ^ array ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Storing values of string array in variables in java -->
			^ storing values ^ string array ^ variables ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					If you want to access any of the words in the array, then you can do so.
					<delay>2</delay>
					You do not need to give them all variable names.
					<delay>2</delay>
					For instance, say you have your words array.

					<delay>2</delay>
					To print the 3rd word in the word array to the console:
System.out.println(words[2]);<break/>

					<delay>2</delay>
					Noting that the first element in an array is element 0.

					<delay>2</delay>
				</li>
				<li>
					
					You already have your values stored as variables, they are called :
word[0]<break/>word[1]<break/>word[2]<break/>word[3]<break/>word[4]<break/>word[5]<break/>
…

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ storing values ^ string array ^ variables ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to find the maximum value in an array? -->
			^ find ^ maximum value ^ array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Iterate over the Array.
					<delay>2</delay>
					First initialize the maximum value to the first element of the array and then for each element optimize it if the element under consideration is greater.

					<delay>2</delay>
				</li>
				<li>
					
					If you can change the order of the elements:
 int[] myArray = new int[]{1, 3, 8, 5, 7, };<break/> Arrays.sort(myArray);<break/> int max = myArray[myArray.length - 1];<break/>

					<delay>2</delay>
					If you can't change the order of the elements:
int[] myArray = new int[]{1, 3, 8, 5, 7, };<break/>int max = Integer.MIN_VALUE;<break/>for(int i = 0; i &lt; myArray.length; i++) {<break/>      if(myArray[i] &gt; max) {<break/>         max = myArray[i];<break/>      }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Have a max int and set it to the first value in the array.
					<delay>2</delay>
					Then in a for loop iterate through the whole array and see if the max int is larger than the int at the current index.

					<delay>2</delay>
					int max = array.get(0);<break/>for (int i = 1; i &lt; array.length; i++) {<break/>    if (array.get(i) &gt; max) {<break/>      max = array.get(i);<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ find ^ maximum value ^ array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- When do methods like JNI GetDoubleArrayElements set isCopy to true or false? -->
			^ methods like jni getdoublearrayelements set iscopy ^ true ^ false 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					I think it's more a matter of which JVM implementation does copying and which does pinning, not what runtime conditions might determine that choice, although I can certainly imagine that say an object in permgen space might be more amenable to being pinned than a brand new one.

					<delay>2</delay>
					The decision is the JVM's, not yours.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ methods like jni getdoublearrayelements set iscopy ^ true ^ false </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- how to print list of buffered image in java -->
			^ print list ^ buffered image ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					In case of printing several graphics images, one per page, use the page index to iterate through these pages and print one on each page.
					<delay>2</delay>
					For example, if several images are represented in the following array:
BufferedImage[] images = new BufferedImage[10];<break/>
then use the print() method as shown in the following code fragment:
public int print(Graphics graphics,<break/>           PageFormat pageFormat, int pageIndex)<break/>           throws PrinterException {<break/>    if (pageIndex &lt; images.length) {<break/>        graphics.drawImage(images[pageIndex], 100, 100, null);<break/>        return PAGE_EXISTS;<break/>    } else {<break/>        return NO_SUCH_PAGE:<break/>    }<break/>}<break/>

					<delay>2</delay>
					If the document is continuous, the application must calculate how much content can fit on each page, and break the page at that point.
					<delay>2</delay>
					If text document consists of many lines, then an application must calculate how many of these lines can fit entirely on a page.
					<delay>2</delay>
					The Point class creates a point representing a location in (x,y)

					<delay>2</delay>
					To calculate the height of a single line of text, use the FontMetrics class.

					<delay>2</delay>
					Font font = new Font("Serif", Font.PLAIN, 10);<break/>FontMetrics metrics = graphics.getFontMetrics(font);<break/>int lineHeight = metrics.getHeight();<break/>

					<delay>2</delay>
					The PageFormat parameter describes the printable area of the page.
					<delay>2</delay>
					In particular, to find the vertical span of the page use the following code fragment:

					<delay>2</delay>
					double pageHeight = pageFormat.getImageableHeight();<break/>
Use the following code fragment to calculate the number of lines that fit on a page and the number of page breaks:
$
					<delay>2</delay>
					code_placeholder_5
Use the print() method to calculate the printable area for the following reasons:
Text measurement depends on the FontRenderContext and this is implicit in the FontMetrics object returned by the printer graphics which is not available except inside the print() method.

					<delay>2</delay>
					The page format may not be disclosured until printing occurs.
					<delay>2</delay>
					Since if the user selected a landscape mode in the print dialog, then this setting needs to be accounted for.
					<delay>2</delay>
					The PageFormat object passed into the print() method provides this information.

					<delay>2</delay>
					The page break positions are used as represented in the following code fragment:

					<delay>2</delay>
					/* Draw each line that is on this page.<break/> * Increment 'y' position by lineHeight<break/> * for each line.<break/> */<break/>int y = 0; <break/>int start = (pageIndex == 0) ? 0 : pageBreaks[pageIndex-1];<break/>int end   = (pageIndex == pageBreaks.length)<break/>                 ? textLines.length : pageBreaks[pageIndex];<break/>for (int line=start; line&lt;end; line++) {<break/>    y += lineHeight;<break/>    g.drawString(textLines[line], 0, y);<break/>}<break/>

					<delay>2</delay>
					If a document contains 100 lines and only 48 lines fit on a page, then an application prints 3 pages with page breaks after 48 and 96 lines of text.
					<delay>2</delay>
					The remaining 4 lines are printed on the last page.
					<delay>2</delay>
					The complete code for this example is in PaginationExample.java.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ print list ^ buffered image ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Getting top 3 highest values in arraylist? -->
			^ getting top 3 highest values ^ arraylist 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You need to write your own comparator and use Collections.sort(list, comparator) on your ArrayList, which will bring the top 3 integers to the top(this is purely based on the logic in your comparator).

					<delay>2</delay>
				</li>
				<li>
					
					use Collections.sort to sort and retrieve the first three values

					<delay>2</delay>
				</li>
				<li>
					
					Put all the elements into a TreeSet using TreeSet(Collection c) constructor then use TreeSet.descendingIterator to get the first 3 elements.
					<delay>2</delay>
					A list may contain duplicates,  using TreeSet guarantees that you retrieve 3 distinct largest values.

					<delay>2</delay>
				</li>
				<li>
					
					List&lt;Integer&gt; list;<break/>Collections.sort(list);<break/>List&lt;Integer&gt; top3 = new ArrayList&lt;Integer&gt;(list.subList(list.size() -3, list.size()));<break/>
I could have simply used the subList, but the list returned from subList() is a view on the base list, so changes made there would be reflected in top3.

					<delay>2</delay>
				</li>
				<li>
					
					Make use of List#subList(int fromIndex,int toIndex) 
  Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive. 

					<delay>2</delay>
					yourList.subList(yourList.size() -n, yourList.size());<break/>

					<delay>2</delay>
					As per sublist docs 

					<delay>2</delay>
				</li>
				<li>
					
					It depends on the size of the list and what performance you want.
					<delay>2</delay>
					If the list is "small" then any of the earlier solutions will suffice, depending on your requirements.

					<delay>2</delay>
					If the list is "large" and performance is important, then you should iterate through the list and keep the 3 largest as you go.

					<delay>2</delay>
					Another trade-off is your time and bugs vs using libraries.
					<delay>2</delay>
					An of the library approaches mentioned will work in less of your programmer-time than a custom-coded solution

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ getting top 3 highest values ^ arraylist </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Why is it important to learn about Arrays when we have ArrayLists? -->
			^ important ^ learn ^ arrays ^ arraylists 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Arrays and ArrayLists serve different, though sometimes overlapping, purposes.

					<delay>2</delay>
					But aside from that, the simple fact is that you don't code in a vacuum, and so you're going to use APIs that involve arrays, so learning about them isn't optional.
					<delay>2</delay>
					Arrays are an absolutely fundamental structure in computer science.

					<delay>2</delay>
				</li>
				<li>
					
					Check out this comparison.

					<delay>2</delay>
					As you can see, there are important differences between the two constructs.
					<delay>2</delay>
					You'll find APIs using one or the other (or both), and you have to understand the pros/cons and the functional differences between the two.

					<delay>2</delay>
					One particular difference is that a native array can store primitives without the inefficiencies of boxing/unboxing.
					<delay>2</delay>
					That's significant when you have sizeable arrays representing data streams / data sets.

					<delay>2</delay>
					Note also that an ArrayList is not covariant.
					<delay>2</delay>
					That is, an Integer[] is a Number[], but an ArrayList&lt;Integer&gt; is not a ArrayList&lt;Number&gt;.
					<delay>2</delay>
					See here for more details.

					<delay>2</delay>
				</li>
				<li>
					
					It is very important to have a proper foundation in programming fundamentals.
					<delay>2</delay>
					These fundamentals include things like variable types, functions, arguments, arrays, and so on.
					<delay>2</delay>
					Without a proper foundation, everything else you learn can collapse since you don't have a proper foundation.
					<delay>2</delay>
					In other words, lets say you want to learn a language, you could start to learn whole phrases by memorization, but it is nice to get some words rolling off the tongue and start digesting and piecing how you can make sentences out of words instead of brute forcing it and memorizing all the sentences you need.

					<delay>2</delay>
				</li>
				<li>
					
					It is important for you to learn arrays if you wish to have a better understanding of what happens "behind the scenes", or if you want to learn a lower level language like C or assembly languages.

					<delay>2</delay>
					May I ask where you are learning Java?
					<delay>2</delay>
					Is this for school/college?
					<delay>2</delay>
					If so, please try to get something out of working with Arrays, because they will be used in courses like Data Structures and especially if you start using a language that doesn't have an ArrayList equivalent.

					<delay>2</delay>
					Learn all you can about it.
					<delay>2</delay>
					Understanding what's happening is rewarding.

					<delay>2</delay>
				</li>
				<li>
					
					There are many things you can do with arrays that you can't do with ArrayLists.  
					<delay>2</delay>
					For example,
Read multiple bytes or code-units from a file using a byte[] or a char[]
Call a native numeric or graphics library that deals with vectors, or matrices represented as float[]s or double[]s

					<delay>2</delay>
					You can use other non-primitive-array abstractions instead of ArrayList, but sometimes the best way to represent a contiguous region of memory divided into numeric units is using an array.

					<delay>2</delay>
				</li>
				<li>
					
					String []array = { "I","DO","NOT","RESIZE" };<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ important ^ learn ^ arrays ^ arraylists </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Split the String into a String array -->
			^ split ^ string ^ string array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Try this:
String arr[] = "George\nWashington".split("\\n"));<break/>

					<delay>2</delay>
				</li>
				<li>
					
					String[] array = arr.split("\\n");<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ split ^ string ^ string array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Syntax for adding values to the arraylist of array -->
			^ syntax ^ adding values ^ arraylist ^ array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					int[] row = list.get(rowNumber);<break/>row[columnNumber] = value;<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can insert a specified element at a specified position using the add method.

					<delay>2</delay>
				</li>
				<li>
					
					Vector&lt;int[]&gt; vector=new Vector&lt;int[]&gt;();<break/>vector.get(0)[0]=1;<break/>

					<delay>2</delay>
				</li>
				<li>
					
					you can use set as described here
Vector&lt;int[]&gt; v = new Vector&lt;int[]&gt;[10];<break/>v.set(0, new int[10]);<break/>
and then get a value
int[] curr = c.get(0);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					list.add(int index, String Element);

					<delay>2</delay>
				</li>
				<li>
					
					you can add elements to arraylist using  add   metheod.

					<delay>2</delay>
					    int[] x={1,2,3,4,5};<break/> ArrayList&lt;int[]&gt; demo = new  ArrayList&lt;int[]&gt;();<break/>    demo.add(x);<break/>
you can,  inserts the specified element at the specified position in this list. 

					<delay>2</delay>
					  add(int index, E element)<break/>
index : index at which the specified element is to be inserted.

					<delay>2</delay>
					element element to be inserted here must be integer array 
   demo.add(5, x);<break/>
element inserted in 5th position in arraylist

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ syntax ^ adding values ^ arraylist ^ array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Why is there array copy method in class System? -->
			^ array copy method ^ class system 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					It's there for historical reasons: it's there since JDK 1.0, while the Java class Arrays where this method logically belongs has not been introduced until Java 1.2 release.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ array copy method ^ class system </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java library that perform sorting of primitives array with custom comparator -->
			^ java library ^ perform sorting ^ primitives array ^ custom comparator 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You can use Comparator on the Objects only.
					<delay>2</delay>
					You can't on the primitive types.

					<delay>2</delay>
					By using ArrayUtils class you can convert primitive array to wrapper and vice-versa .

					<delay>2</delay>
					So Use Apache Commons ArrayUtils class.  
Integer objectArray = ArrayUtils.toObject(array);   <break/>Arrays.sort(objectArray,new MyComparator());<break/>int[] sortedArray = ArraysUtils.toPrimitive(objectArray);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Well, this doesn't require an answer
					<delay>2</delay>
					but I think I must make you understand the reason behind this.

					<delay>2</delay>
					All the basic data types or primitive data types can only be compared in the order of their natural ordering.
					<delay>2</delay>
					This is enforced by the language specification.

					<delay>2</delay>
					Natural Ordering: means that the obvious way how a group is arranged in nature.
					<delay>2</delay>
					For e.g. if you consider natural numbers it is always true that 1 &lt; 2 &lt; 3 &lt; ... &lt; 10 and same is the case with other primitives like char etc.

					<delay>2</delay>
					This also makes a lot of sense and helps in optimization, because the primitive data types are used in the language in lot of places (like loop counters, switch statements etc) and the compiler can actually optimize a lot of things if it can assume the natural order of a type of variables.

					<delay>2</delay>
					There are many more points, but I am sure you got the reason why Arrays default sort doesn't provide custom Comparator for primitive data types.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java library ^ perform sorting ^ primitives array ^ custom comparator </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to convert Byte array to ByteArrayOutputStream -->
			^ convert byte array ^ bytearrayoutputstream 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					byte[] bytes = ....;<break/>ByteArrayOutputStream baos = new ByteArrayOutputStream(bytes.length);<break/>baos.write(bytes, 0, bytes.length);<break/>
Method description:
  Writes len bytes from the specified byte array starting at offset off to this byte array output stream.

					<delay>2</delay>
				</li>
				<li>
					
					You can't display a ByteArrayOutputStream.  
					<delay>2</delay>
					What I suspect you are trying to do is
byte[] bytes = ...<break/>String text = new String(bytes, "UTF-8"); // or some other encoding.<break/>// display text.<break/>

					<delay>2</delay>
					You can make ByteArrayOutputStream do something similar but this is not obvious, efficient or best practice (as you cannot control the encoding used)

					<delay>2</delay>
				</li>
				<li>
					
					With JDK/11, you can make use of the writeBytes(byte b[]) API which eventually calls the  write(b, 0, b.length) as suggested in the answer by Josh.

					<delay>2</delay>
					/**<break/> * Writes the complete contents of the specified byte array<break/> * to this {@code ByteArrayOutputStream}.<break/> *<break/> * @apiNote<break/> * This method is equivalent to {@link #write(byte[],int,int)<break/> * write(b, 0, b.length)}.<break/> *<break/> * @param   b     the data.<break/> * @throws  NullPointerException if {@code b} is {@code null}.<break/> * @since   11<break/> */<break/>public void writeBytes(byte b[]) {<break/>    write(b, 0, b.length);<break/>}<break/>

					<delay>2</delay>
					The sample code would simply transform into --
byte[] bytes = new byte[100];<break/>ByteArrayOutputStream baos = new ByteArrayOutputStream(bytes.length);<break/>baos.writeBytes(bytes);<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ convert byte array ^ bytearrayoutputstream </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Is there a function that can sort my integer array values from smallest to largest? -->
			^ function ^ sort ^ integer array values ^ smallest ^ largest 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Very easy:
int[] intarray;<break/>// ...<break/>Arrays.sort(intarray);<break/>

					<delay>2</delay>
					If you have a List instead:
List&lt;Integer&gt; numbers;<break/>// ...<break/>Collections.sort(numbers);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					int[] x= new int[] {1,2,3,4,0,-3};<break/>Arrays.sort(x);<break/>for(int temp: x) {<break/>    System.out.println( temp);<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ function ^ sort ^ integer array values ^ smallest ^ largest </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to edit elements in array of class type in java? -->
			^ edit elements ^ array ^ class type ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Object[] myArray = new Object7;

					<delay>2</delay>
					Object myObject = myArray[5]; // get object at index 5 then make changes to your object

					<delay>2</delay>
				</li>
				<li>
					
					Create the array:
type[] arrayName = new type[size];<break/>
Example:
int[] someNumbers = new int[10]; // array with 10 slots<break/>

					<delay>2</delay>
					To get an element, simply use arrayName[index].
					<delay>2</delay>
					Arrays are 0-based, so getting the 5th element is done by someNumbers[4].

					<delay>2</delay>
					Let's say we have an array of Persons and you want to change a person address.

					<delay>2</delay>
					Person personObj = arrayOfPersons[3]; // get the 4th person<break/>personObj.setAddress("New York");<break/>

					<delay>2</delay>
					That's it!
					<delay>2</delay>
					You're done!

					<delay>2</delay>
					Additional notes:
You will get an ArrayIndexOutOfBoundsException if you try to access an element outside the array(using a negative index or an index greater or equal that the array length).

					<delay>2</delay>
				</li>
				<li>
					
					Do you mean to add extra properties to this class?

					<delay>2</delay>
					I suppose you have an array 
String[] data = new String[]{"a", "b", "c"}
To add extra properties,
					<delay>2</delay>
					may be you can try to create a wrapper:
class Wrapper&lt;T&gt; {<break/>    private T origin<break/>    public String name;<break/>    public String desc<break/>    public Wrapper(T data) {<break/>        origin = data;<break/>    }<break/>}<break/>
To add extra properties:
Map&lt;String, Wrapper&gt; extraProperties = new HashMap&lt;String, Wrapper&gt;();<break/>Wrapper&lt;String&gt; w = new Wrapper&lt;String&gt;(data[1]);<break/>w.name = "a name";<break/>w.desc = "description"<break/>extraProperties.put(data[1], w);<break/>

					<delay>2</delay>
					To access the extra properties:
if(extraProperties.contains(data[1])) {<break/>    extraProperties.get(data[1]).name<break/>    extraProperties.get(data[1]).desc<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					
  how can I assign a name and description for element 1?

					<delay>2</delay>
					That depends on your class, but here's a (bad) example:
YourClass[] array = .... ;           // wherever it comes from<break/>array[1].name = "World";             // if name is a member of your class<break/>array[1].setDescription("whatever"); // if there is a setter for description<break/>
Note that element 1 is the second element of the array as indeces start with 0.

					<delay>2</delay>
				</li>
				<li>
					
					For example your object here is of a class type Car.
					<delay>2</delay>
					And your Car object has a method called setNumberPlate(String x) which is something like : 
void setNumberPlate (String str)<break/>{<break/>   //numberPlate is a String data member of your Car class<break/>   numberPlate = str;<break/>}<break/>

					<delay>2</delay>
					The reason you need to have a method is because its a good practice to keep the data members of your class private.
					<delay>2</delay>
					So, for example, here's the class : 

					<delay>2</delay>
					Class Car<break/>{<break/>   private String numberPlate;<break/>   public void setNumberPlate(String str)<break/>   {<break/>      numberPlate = str;<break/>   }<break/>}<break/>

					<delay>2</delay>
					Then you can access this method in another class.

					<delay>2</delay>
					If you store your objects in an object0, then this is what you do.

					<delay>2</delay>
					object1

					<delay>2</delay>
					object2

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ edit elements ^ array ^ class type ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to put a text file into a string array? -->
			^ put ^ text file ^ string array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Please refer to this article: 
http://www.mkyong.com/java/how-to-read-file-from-java-bufferedreader-example/
specifically:
    BufferedReader br = null;<break/>    try {<break/>        String sCurrentLine;<break/>        br = new BufferedReader(new FileReader("C:\\testing.txt"));<break/>        while ((sCurrentLine = br.readLine()) != null) {<break/>            System.out.println(sCurrentLine);<break/>        }<break/>    } catch (IOException e) {<break/>        e.printStackTrace();<break/>    } <break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ put ^ text file ^ string array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- I need an array or ArrayList that accepts objects of any type -->
			^ need ^ array ^ arraylist ^ accepts objects ^ type 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					List&lt;Object&gt; array = new ArrayList&lt;Object&gt;();<break/>

					<delay>2</delay>
					Each class is of the type object, so this should do it.

					<delay>2</delay>
				</li>
				<li>
					
					You can create a method that accepts any type of array just like this:
public &lt;T&gt; void MyMethod(List&lt;T&gt; mylist){<break/>    System.out.println(mylist);<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					To answer the heading of your question,
Object is superset of all objects.
					<delay>2</delay>
					So you can achieve it by creating an array of Object types.
					<delay>2</delay>
					You can insert any type into that array.

					<delay>2</delay>
					eg.

					<delay>2</delay>
					ArrayList&lt;Object&gt; list = new ArrayList&lt;Object();<break/>

					<delay>2</delay>
					To answer your question i.e. to create a method which can accept any number of arrays of any type use variable arguments.

					<delay>2</delay>
					eg.

					<delay>2</delay>
					public void method(Object ... params) { &lt;your code&gt;  }  <break/>// This method will accept any number of parameters of any type.<break/>// If it is specific to ArrayLists, use ArrayList&lt;Object&gt; as the parameter type.<break/>

					<delay>2</delay>
				</li>
				<li>
					
					
  Takes in arrays, and makes them all the length of the longest one
ArrayList of arrays is a good way to do it.
					<delay>2</delay>
					Arrays.copyOf pads the shorter arrays with null
void f(ArrayList&lt;Object[]&gt; list){<break/>        int maxLen = 0;<break/>        for(int i=0;i&lt;list.size();i++){<break/>            maxLen = Math.max(maxLen, list.get(i).length);<break/>        }<break/>        for(int i=0;i&lt;list.size();i++){<break/>            if(list.get(i).length &lt; maxLen)<break/>            list.set(i, Arrays.copyOf(list.get(i), maxLen));<break/>        }<break/>    }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Since all arrays are objects you can make the method take varargs of Object.
					<delay>2</delay>
					Here's how to do literally what you are asked.
					<delay>2</delay>
					This could be somewhat simplified if you exclude arrays of primitives (forcing wrapper types like Integer[] and Boolean[]) so the parameter was Object[]....
					<delay>2</delay>
					Then you would not need reflection and the big long if/else block and could return a List&lt;Object[]&gt;.
					<delay>2</delay>
					In that case the method would be much shorter.
					<delay>2</delay>
					Otherwise this kind of thing is very inconvenient.

					<delay>2</delay>
					import java.lang.reflect.Array;<break/>import java.util.Arrays;<break/>import java.util.List;<break/>import java.util.ArrayList;<break/>public static List&lt;Object&gt; conform(Object... arrays) {<break/>    ArrayList&lt;Object&gt; out = new ArrayList&lt;Object&gt;(arrays.length);<break/>    int longest = 0;<break/>    for (Object a : arrays) {<break/>        if (!a.getClass().isArray()) {<break/>            throw new IllegalArgumentException(a + " not an array");<break/>        }<break/>        int length = Array.getLength(a);<break/>        if (length &gt; longest) longest = length;<break/>    }<break/>    for (Object a : arrays) {<break/>        if (a instanceof Object[]) {<break/>            out.add(Arrays.copyOf((Object[])a, longest));<break/>        } else if (a instanceof boolean[]) {<break/>            out.add(Arrays.copyOf((boolean[])a, longest));<break/>        } else if (a instanceof char[]) {<break/>            out.add(Arrays.copyOf((char[])a, longest));<break/>        } else if (a instanceof byte[]) {<break/>            out.add(Arrays.copyOf((byte[])a, longest));<break/>        } else if (a instanceof short[]) {<break/>            out.add(Arrays.copyOf((short[])a, longest));<break/>        } else if (a instanceof int[]) {<break/>            out.add(Arrays.copyOf((int[])a, longest));<break/>        } else if (a instanceof long[]) {<break/>            out.add(Arrays.copyOf((long[])a, longest));<break/>        } else if (a instanceof float[]) {<break/>            out.add(Arrays.copyOf((float[])a, longest));<break/>        } else if (a instanceof double[]) {<break/>            out.add(Arrays.copyOf((double[])a, longest));<break/>        }<break/>    }<break/>    return out;<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ need ^ array ^ arraylist ^ accepts objects ^ type </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to start iterating through ArrayList from set index? -->
			^ start iterating ^ arraylist ^ set index 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You can always utilize the subList(int, int) method
list.subList(100,list.size()).iterator();<break/>

					<delay>2</delay>
				</li>
				<li>
					
					There are many ways to do this.
					<delay>2</delay>
					In this examples I assume your list holds Integers.

					<delay>2</delay>
					You can use ListIterator 
ListIterator&lt;Integer&gt; it = list.listIterator(100);<break/>while (it.hasNext()) {<break/>    System.out.println(it.next());<break/>}<break/>
or with for (to keep iterator scoped inside loop)
for (ListIterator&lt;Integer&gt; lit = list.listIterator(100); lit.hasNext();) {<break/>    System.out.println(lit.next());<break/>}<break/>
or normal for loop but start from i=100
for (int i=100; i&lt;list.size(); i++){<break/>    System.out.println(list.get(i));<break/>}<break/>
or just create subList and iterate over it
					<delay>2</delay>
					like you normally do
for (Integer i : list.subList(100, list.size())){<break/>    System.out.println(i);<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Try like this to iterate over a range:
for(int i=100; i&lt; myArrayLst.size(); i++){<break/>    System.out.println(myLst.get(i));<break/>  }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Use a ListIterator.
					<delay>2</delay>
					And read the API documentation, thank you.

					<delay>2</delay>
					ListIterator&lt;YourType&gt; iter = list.listIterator(start);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Use ListIterator
ListIterator&lt;Type&gt; iter = list.listIterator(start);<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ start iterating ^ arraylist ^ set index </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Method for converting boolean array to binary java -->
			^ method ^ converting boolean array ^ binary java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					If you want to serialize boolean array, check this: How to convert boolean array to binary and vice versa in Java?

					<delay>2</delay>
					If you want to use bits instead of booleans, check BitSet class:
					<delay>2</delay>
					http://docs.oracle.com/javase/7/docs/api/java/util/BitSet.html
  
					<delay>2</delay>
					This class implements a vector of bits that grows as needed.
					<delay>2</delay>
					Each
  component of the bit set has a boolean value.
					<delay>2</delay>
					The bits of a BitSet are
  indexed by nonnegative integers.
					<delay>2</delay>
					Individual indexed bits can be
  examined, set, or cleared.
					<delay>2</delay>
					One BitSet may be used to modify the
  contents of another BitSet through logical AND, logical inclusive OR,
  and logical exclusive OR operations.
  
  
					<delay>2</delay>
					By default, all bits in the set initially have the value false.

					<delay>2</delay>
					You can use these methods:
BitSet#set(int) to set the bit to true at specified position.

					<delay>2</delay>
					BitSet#clear(int) to set the bit to false at specified position.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ method ^ converting boolean array ^ binary java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Random values generating -->
			^ random values generating 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					System.out.println("Oh cool, " + petName[i]
					<delay>2</delay>
					+ " is a very unique name!");

					<delay>2</delay>
				</li>
				<li>
					
					You need to use the array index to fetch the value. 

					<delay>2</delay>
					Just as you are storing the value in the array using indexes using petName[i] = JOptionPane.showInputDialog("What is your pet called?");, you need to retrieve values from the array using  Use petName[index]

					<delay>2</delay>
				</li>
				<li>
					
					Petname is an string array, so you need to use petname[0] to get the name of the pet.

					<delay>2</delay>
					But since a pet only has one name, I think it would be better to use a simple String as the pet's name.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ random values generating </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to declare an imageIcon array? -->
			^ declare ^ imageicon array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Say like this:
ImageIcon[][] arr = new ImageIcon[10][5];<break/>
Note that after this line, the array elements will be uninitialized (they will be all equal to null).

					<delay>2</delay>
					If you want to initialize them, you need to loop through your array and call some of the ImageIcon constructors e.g.
arr[i][j] = new ImageIcon();<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ declare ^ imageicon array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- compare int before its placed into an array? -->
			^ compare int ^ placed ^ array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Use a Set&lt;Integer&gt;, duplicates will not be stored.

					<delay>2</delay>
				</li>
				<li>
					
					The best way is called LinkedHashSet&lt;Integer&gt; if you need order or just Set&lt;Integer&gt; (any implementation) if you don't

					<delay>2</delay>
				</li>
				<li>
					
					    boolean duplicate = false;<break/>    int input = 5;<break/>    int[] a = new int[5];<break/>    for(int x : a){<break/>        if(x == input){<break/>            duplicate = true;<break/>            break;<break/>        }<break/>    }<break/>    if(!duplicate){<break/>        a[pos] = input;<break/>    }<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ compare int ^ placed ^ array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to remove all names from the array list before a certain string? -->
			^ remove ^ names ^ array list ^ certain string 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Iterate through the list and keep removing the elements till you find that String.
for (int i=0; i&lt;list.size(); i++) {<break/>  if (!(list.get(i).equal("String"))) {<break/>    list.remove(0);<break/>  }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You should be able to achieve this by using indexOf and subList. 

					<delay>2</delay>
					Consider reading the linked documentation for more information.

					<delay>2</delay>
					Code example:
list.subList(0, list.indexOf(searched_string)).clear();<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Get the index of the newly added element.  
					<delay>2</delay>
					Use this index to get a sublist and pass the sublist to the removeAll method:
Removing
//addition = newly added String     <break/>list.removeAll(new ArrayList&lt;String&gt;(list.subList(0,list.indexOf(addition))));<break/>
Full Example
public class ArrayListSortDelete {<break/>    public static void main(String[] args) {<break/>        String addition = "BB";<break/>        List&lt;String&gt; list = new ArrayList(Arrays.asList(new String[] { "A", "B", "C", "D" }));<break/>        list.add(addition);<break/>        Collections.sort(list);<break/>        System.out.println("Before");<break/>        for (String s : list) {<break/>            System.out.println(s);<break/>        }<break/>            //new ArrayList&lt;String&gt;() avoids concurrent modification.<break/>        list.removeAll(new ArrayList&lt;String&gt;(list.subList(0,list.indexOf(addition))));<break/>        System.out.println("After:");<break/>        for (String s : list) {<break/>            System.out.println(s);<break/>        }<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					This should be alright
ArrayList&lt;String&gt; yourList;<break/>String query;    <break/>int index = yourList.indexOf(query);<break/>for (int a=0; a&lt;index; a++) {<break/>    yourList.remove(0);<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Though Kevin Bowersox have given an answer, I am here to give you an alternative  :)

					<delay>2</delay>
					Another way to interpret your problem is:

					<delay>2</delay>
					Given an array list, and a new element, remove all elements in the array list that is less than the new element, then put the new element in the list and sort the list.

					<delay>2</delay>
					Here is one way:
ArrayList&lt;String&gt; oList = .....;<break/>List&lt;String&gt; newList = new LinkedList&lt;String&gt;(); // tmp list to store the result<break/>String newElement = ...;<break/>for (String s: oList) {<break/>    if (s.compareTo(newElement) &gt;= 0) { //  s &gt;= newElement<break/>        newList.add(s);<break/>    }<break/>}<break/>newList.add(newElement);<break/>// put the result back to oList<break/>oList.clear();<break/>oList.putAll(newList);<break/>// sort the result<break/>Collections.sort(oList);<break/>// now oList contains what you want<break/>

					<delay>2</delay>
					You may even do it in-place in the oList without help of a temp list (but remove of arrayList is not efficient).

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ remove ^ names ^ array list ^ certain string </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How do i make an arraylist in one class point to the same arraylist in another class? Java -->
			^ make ^ arraylist ^ one class point ^ another class ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Pass the arraylist in constructor of another class. 

					<delay>2</delay>
				</li>
				<li>
					
					Pass a reference of the ArrayList from one class to another.
					<delay>2</delay>
					This can be done through a method parameter such as a setter method or a constructor parameter.

					<delay>2</delay>
					e.g.,
Class1.java
public Class1 {<break/>  private ArrayList&lt;String&gt; myArrayList = new ArrayList&lt;String&gt;();<break/>  private Class2 class2 = new Class2();<break/>  public Class1() {<break/>    myArrayList.add("foo");<break/>    myArrayList.add("bar");<break/>    class2.setMyArrayList(myArrayList);<break/>}<break/>
Class2.java
public Class2 {<break/>  private ArrayList&lt;String&gt; myArrayList;<break/>  public void setMyArrayList(ArrayList&lt;String&gt; myArrayList) {<break/>    this.myArrayList = myArrayList;<break/>  }<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ make ^ arraylist ^ one class point ^ another class ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- why is it that we can't use ArrayList.get(-1) to get the last element of the ArrayList in java? it works in python though -->
			^ use arraylist ^ arraylist ^ get ^ last element ^ java ^ works ^ python though 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					If you want that behaviour:
List&lt;T&gt; snake = new ArrayList&lt;&gt;(){<break/>    @Override<break/>    public T get(int i) {<break/>        return super.get((i + size()) % size());<break/>   }<break/>};<break/>

					<delay>2</delay>
					This will work for any value of i.

					<delay>2</delay>
				</li>
				<li>
					
					First, Java is not Python (although Jython implements Python in Java).
					<delay>2</delay>
					Second, you should read the JavaDoc on ArrayList -
					<delay>2</delay>
					that is it throws an Exception,
IndexOutOfBoundsException - if the index is out of range (index &lt; 0 || index &gt;= size())<break/>

					<delay>2</delay>
					Finally, you can do this
myList.get(myList.size() - 1);<break/>
to get this last element in your List (e.g. myList).

					<delay>2</delay>
				</li>
				<li>
					
					Not answering why it is not possible, as that is not in the scope of StackOverflow.

					<delay>2</delay>
					However, it is possible in the following way when using Java 8:
Optional&lt;E&gt; optE = eCollection.stream().reduce((previous, current) -&gt; current);

					<delay>2</delay>
					And if it exists, you can get it via optE.get(), once you have tested presence with optE.isPresent().

					<delay>2</delay>
					However, I am pretty sure this incurs a performance penalty as you are reducing the stream, while you really just want to inspect the last value.

					<delay>2</delay>
					I have some hopes it will be added in Java 9, if enough people complain when using Java 8.
					<delay>2</delay>
					Because in my example you cannot do it as easy as getting the first element, which would be:
Optional&lt;E&gt; optE = eCollection.stream().findFirst().

					<delay>2</delay>
					Edit, also note for practical purposes that other operations proceed the findFirst() call.
					<delay>2</delay>
					For example a filter() call.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ use arraylist ^ arraylist ^ get ^ last element ^ java ^ works ^ python though </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java Check Position of Array is not "" (Empty) -->
			^ java check position ^ array ^ empty 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					String array[] = new String {" ", "hi", "there", " ", "how"};<break/>
use a for cicle:
int empty<break/>for(int i=0; i&lt;=array.length(); i++){<break/>    if(array[i].equals(" ") || array[i].equals("")){<break/>        empty++;<break/>    }<break/>}<break/>System.out.println("empty values: " + empty);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					This is a very simple one-liner.

					<delay>2</delay>
					java.util.Collections.frequency(java.util.Arrays.asList(myArray), "");<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java check position ^ array ^ empty </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Suppression problems with generically typed Arrays -->
			^ suppression problems ^ generically typed arrays 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					It's because arrays generally don't go well with generic types.
					<delay>2</delay>
					The most common way people handle data structures with generic types is to use Lists. 

					<delay>2</delay>
					So for example, you would create a List&lt;T&gt; object rather than an array.
					<delay>2</delay>
					One reason why arrays don't go well with generics and gives you the type safety warning is because arrays are co-variant:
					<delay>2</delay>
					meaning that they can contain sub-types. 

					<delay>2</delay>
					For example, an array of objects can contain longs and ints, which would fail at run-time when you tried to call items from the array.
					<delay>2</delay>
					With Lists, it prevents you from inserting subtypes at compile time that could cause your code to fail at run-time. 

					<delay>2</delay>
					So a rule of thumb would be to use a List instead of an array, but if you're really intent on using arrays and are sure that you will not be inserting any sub-types into the array, then you can add the line @SuppressWarnings("unchecked") above the line that you gave.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ suppression problems ^ generically typed arrays </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Searching a list -->
			^ searching ^ list 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You are comparing the whole array A with the string.

					<delay>2</delay>
					try comparing the individual elements.

					<delay>2</delay>
					if (A[compCount -1].equals(animal)) {<break/>  System.out.println("String " + animal + " was found using " + compCount + " comparisions.");<break/>  break;<break/> }<break/>
Also note that you should break after printing.

					<delay>2</delay>
					Also it would be better still to use equalsIgnoreCase

					<delay>2</delay>
				</li>
				<li>
					
					Try this,
String[] A = {"cat", "dog", "mouse", "fox", "bear", "wolf", "eagle", "moose", "parrot", "rabbit"};<break/>String animal = (args[0]);<break/>if(Arrays.asList(A).contains(animal))<break/>   {<break/>      System.out.println(" String " + animal + " was found using " + compCount + " comparisions. ");<break/>   }<break/>   else<break/>   {<break/>      System.out.println(" String " + animal + " could not be found, and " + compCount + " comparisons were performed. ");<break/>   }<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ searching ^ list </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java replacing char at index -->
			^ java replacing char ^ index 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You could accomplish this by using substring() to pick apart and recreate the string, but another way is to just convert it to a char[] and operate on that, e.g.:
char[] data = captureString[0].toCharArray();<break/>data[strOneRand] = Character.toUpperCase(data[strOneRand]); // or whatever<break/>String outputFinal = new String(data);<break/>

					<delay>2</delay>
					An example of accomplishing this with substring() can be found in the accepted answer of Replace a character at a specific index in a string?.
					<delay>2</delay>
					An example of doing it with a StringBuilder can be found there as well.

					<delay>2</delay>
				</li>
				<li>
					
					you just need to do this 
char[] charArray = captureString[0].toCharArray();<break/>charArray[strOneRand] = THE_NEW_CHARECTOR_YOU_WANT_TO_REPLACE;<break/>String outputFinal = String.copyValueOf(charArray);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					you can also use the utility class StringBuilder like this:
    StringBuilder resultString = new StringBuilder(captureString[0]);<break/>    char replaceMe = captureString[0].charAt(strOneRand);<break/>    resultString.setCharAt(strOneRand, Character.toUpperCase(replaceMe));<break/>    System.out.println(resultString.toString());<break/>

					<delay>2</delay>
					The assignment is just for clarification, good luck!

					<delay>2</delay>
				</li>
				<li>
					
					String a = captureString[0].substring(0,strOneRand);<break/>String b = captureString[0].substring(strOneRand,strOneRand+1).toUpperCase;<break/>String c = captureString[0].substring(strOneRand+1);<break/>System.out.println(a+b+c);<break/>
replace method will make the first occurrence of chosen character to upper case.

					<delay>2</delay>
					if input string is "aaaaa", you will always get "Aaaaa".

					<delay>2</delay>
				</li>
				<li>
					
					Here is what I would do in your situation:
public void replaceChar(String strPassed, int index){<break/>    char strArray[] = strPassed.toCharArray(); <break/>    strArray[index] = (char)(strArray[index] - 32);<break/>    strPassed[0] = new String(strArray);<break/>}<break/>

					<delay>2</delay>
					and then wherever I wanted to convert the character into UpperCase:
replaceChar(capturString[0], strOneRand);<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java replacing char ^ index </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Arraylist index calculation java -->
			^ arraylist index calculation java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Without actual code:
iterate thorough the array 
count the 1s you found 
if you found a 0 then start over the count 
check after increasing the counter: if the counter reaches 3 then return with true 
if you reached the end of the array and no more elements then return with false
Something like this, I hope I could help.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ arraylist index calculation java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to convert a Java 8 Stream to an Array? -->
			^ convert ^ java 8 stream ^ array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					The easiest method is to use the toArray(IntFunction&lt;A[]&gt; generator) method with an array constructor reference.
					<delay>2</delay>
					This is suggested in the API documentation for the method.

					<delay>2</delay>
					String[] stringArray = stringStream.toArray(String[]::new);<break/>
What it does is find a method that takes in an integer (the size) as argument, and returns a String[], which is exactly what (one of the overloads of) new String[] does.

					<delay>2</delay>
					You could also write your own IntFunction:
Stream&lt;String&gt; stringStream = ...;<break/>String[] stringArray = stringStream.toArray(size -&gt; new String[size]);<break/>

					<delay>2</delay>
					The purpose of the IntFunction&lt;A[]&gt; generator is to convert an integer, the size of the array, to a new array.

					<delay>2</delay>
					Example code:
Stream&lt;String&gt; stringStream = Stream.of("a", "b", "c");<break/>String[] stringArray = stringStream.toArray(size -&gt; new String[size]);<break/>Arrays.stream(stringArray).forEach(System.out::println);<break/>
Prints:
a<break/>b<break/>c<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you want to get an array of ints, with values from 1 to 10, from a Stream&lt;Integer&gt;, there is IntStream at your disposal.

					<delay>2</delay>
					Here we create a Stream with a Stream.of method and convert a Stream&lt;Integer&gt; to an IntStream using a mapToInt.
					<delay>2</delay>
					Then we can call IntStream's toArray method.

					<delay>2</delay>
					Stream&lt;Integer&gt;0

					<delay>2</delay>
					Here is the same thing, without the Stream&lt;Integer&gt;1, using only the Stream&lt;Integer&gt;2:
Stream&lt;Integer&gt;3

					<delay>2</delay>
				</li>
				<li>
					
					You can create a custom collector that convert a stream to array. 

					<delay>2</delay>
					public static &lt;T&gt; Collector&lt;T, ?, T[]&gt; toArray( IntFunction&lt;T[]&gt; converter )<break/>{<break/>    return Collectors.collectingAndThen( <break/>                  Collectors.toList(), <break/>                  list -&gt;list.toArray( converter.apply( list.size() ) ) );<break/>}<break/>
and a quick use
List&lt;String&gt; input = Arrays.asList( ..... );<break/>String[] result = input.stream().<break/>         .collect( CustomCollectors.**toArray**( String[]::new ) );<break/>

					<delay>2</delay>
				</li>
				<li>
					
					     Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3, 4, 5, 6);<break/>     Integer[] integers = stream.toArray(it-&gt;new Integer[it]);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can convert a java 8 stream to an array using this simple code block:
 String[] myNewArray3 = myNewStream.toArray(String[]::new);<break/>

					<delay>2</delay>
					But let's explain things more, first, let's  Create a list of string filled with three values:

					<delay>2</delay>
					String[] stringList = {"Bachiri","Taoufiq","Abderrahman"};<break/>
Create a stream from the given Array :

					<delay>2</delay>
					Stream&lt;String&gt; stringStream = Arrays.stream(stringList);<break/>
we can now perform some operations on this stream
					<delay>2</delay>
					Ex:
Stream&lt;String&gt; myNewStream = stringStream.map(s -&gt; s.toUpperCase());<break/>
and finally convert it to a java 8 Array using these methods:
1-Classic method (Functional interface)

					<delay>2</delay>
					IntFunction&lt;String[]&gt; intFunction = new IntFunction&lt;String[]&gt;() {<break/>    @Override<break/>    public String[] apply(int value) {<break/>        return new String[value];<break/>    }<break/>};<break/>String[] myNewArray = myNewStream.toArray(intFunction);<break/>
2 -Lambda expression
 String[] myNewArray2 = myNewStream.toArray(value -&gt; new String[value]);<break/>

					<delay>2</delay>
					3- Method reference

					<delay>2</delay>
					String[] myNewArray3 = myNewStream.toArray(String[]::new);<break/>
Method reference Explanation:

					<delay>2</delay>
					It's another way of writing a lambda expression that it's strictly equivalent to the other. 

					<delay>2</delay>
				</li>
				<li>
					
					Using the toArray(IntFunction&lt;A[]&gt; generator) method is indeed a very elegant and safe way to convert (or more correctly, collect) a Stream into an array of the same type of the Stream.

					<delay>2</delay>
					However, if the returned array's type is not important, simply using the toArray() method is both easier and shorter.

					<delay>2</delay>
					For example:
    Stream&lt;Object&gt; args = Stream.of(BigDecimal.ONE, "Two", 3);<break/>    System.out.printf("%s, %s, %s!", args.toArray());<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Convert text to string array where separating each value by comma, and trim every field, for example:
String[] stringArray = Arrays.stream(line.split(",")).map(String::trim).toArray(String[]::new);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can do it in a few ways.
					<delay>2</delay>
					All the ways are technically the same but using Lambda would simplify some of the code.

					<delay>2</delay>
					Lets say we initialize a List first with String, call it persons.

					<delay>2</delay>
					List&lt;String&gt; persons = new ArrayList&lt;String&gt;(){{add("a"); add("b"); add("c");}};<break/>Stream&lt;String&gt; stream = persons.stream();<break/>

					<delay>2</delay>
					Now you can use either of the following ways.

					<delay>2</delay>
					Using the Lambda Expresiion to create a new StringArray with defined size.

					<delay>2</delay>
					String[]
					<delay>2</delay>
					stringArray = stream.toArray(size->new String[size]);
Using the method reference directly.

					<delay>2</delay>
					String[] stringArray = stream.toArray(String[]::new);

					<delay>2</delay>
				</li>
				<li>
					
					Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3, 4, 5, 6);<break/>int[] arr=   stream.mapToInt(x-&gt;x.intValue()).toArray();<break/>

					<delay>2</delay>
				</li>
				<li>
					
					import java.util.List;<break/>import java.util.stream.Stream;<break/>class Main {<break/>    public static void main(String[] args) {<break/>        // Create a stream of strings from list of strings<break/>        Stream&lt;String&gt; myStreamOfStrings = List.of("lala", "foo", "bar").stream();<break/>        // Convert stream to array by using toArray method<break/>        String[] myArrayOfStrings = myStreamOfStrings.toArray(String[]::new);<break/>        // Print results<break/>        for (String string : myArrayOfStrings) {<break/>            System.out.println(string);<break/>        }<break/>    }<break/>}<break/>
Try it out online:
					<delay>2</delay>
					https://repl.it/@SmaMa/Stream-to-array

					<delay>2</delay>
				</li>
				<li>
					
					you can use the collector like this
  Stream&lt;String&gt; io = Stream.of(&quot;foo&quot; , &quot;lan&quot; , &quot;mql&quot;);<break/>  io.collect(Collectors.toCollection(ArrayList&lt;String&gt;::new));<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ convert ^ java 8 stream ^ array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Can Multidimensional Arrays how two different types in them within java -->
			^ multidimensional arrays ^ two different types ^ within java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					In Java, this is normally done with a class.

					<delay>2</delay>
					class C {<break/>public String name;<break/>public int num;<break/>}<break/>
(later)
C[] myArray = new C[5];<break/>myArray[3] = new C();<break/>myArray[3].name = "Ford";<break/>myArray[3].num = 42;<break/>
name and num should typically be made private and accessed with getters and setters, but this is beyond the point.

					<delay>2</delay>
				</li>
				<li>
					
					Zoyd has it right, that this should be done with a class.
					<delay>2</delay>
					Here's a more complete example.

					<delay>2</delay>
					class MyClass <break/>{<break/>    private String name;<break/>    private int num;<break/>    public MyClass(String name, int num)<break/>    {<break/>        this.name = name;<break/>        this.num = num;<break/>    }<break/>    public String getName()<break/>    {<break/>        return name;<break/>    }<break/>    public int getNum()<break/>    {<break/>        return num;<break/>    }<break/>}<break/>MyClass[] array = new MyClass[5];<break/>array[0] = new MyClass("name1", 5);<break/>array[1] = new MyClass("name2", 8);<break/>...<break/>

					<delay>2</delay>
					If name or num ever need to change after original creation, then you can add setters for them.

					<delay>2</delay>
				</li>
				<li>
					
					    int row=10;<break/>    int col=10;<break/>    Object [][] objArray=new Object[row][col];<break/>    objArray[0][0]=181818;<break/>    objArray[0][1]="Hello String";<break/>    System.out.println(objArray[0][0]);     <break/>    System.out.println(objArray[0][1]);<break/>
You can use Object for that.

					<delay>2</delay>
					Plus you need to search before you post it.
					<delay>2</delay>
					There is already answer here.
					<delay>2</delay>
					Two-dimensional array of different types

					<delay>2</delay>
				</li>
				<li>
					
					This solution has nothing to do with arrays, but if you've got {name, num}, {name, num} data, you might want to consider using a map. 

					<delay>2</delay>
					Map&lt;String, Double&gt; map = new HashMap&lt;String, Double&gt;();<break/>Double valueX = 123.456;<break/>Double valueY = 654.321;<break/>map.put("nameX", valueX);<break/>map.put("nameY", valueY);<break/>Double valueX = c.get("name");<break/>for(String name:c.keySet()) {<break/>   System.out.println("name:"+name+"\tvalue:"+c.get(name));<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ multidimensional arrays ^ two different types ^ within java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- ArrayList construct and array of capacity? -->
			^ arraylist construct ^ array ^ capacity 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					This will not compile since the element type cannot be a primitive.
					<delay>2</delay>
					Use Integer instead.

					<delay>2</delay>
					new ArrayList&lt;Integer&gt;(20); will create a list backed by an array with an initial capacity of 20.

					<delay>2</delay>
				</li>
				<li>
					
					ArrayList&lt;int&gt;(20); is illegal, since you can't use primitives as generic types nor put them into the standard collections.

					<delay>2</delay>
					ArrayList&lt;Integer&gt;(20); would create a list with a basic capacity of 20 integer objects but it can be resized as needed.

					<delay>2</delay>
				</li>
				<li>
					
					Assuming that you change int to Integer (You can't use generics with primitives), that will create an ArrayList of initial size 20. 

					<delay>2</delay>
					It can still grow past that limit, as per the JavaDocs at  http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html#ArrayList(int):
Constructs an empty list with the specified initial capacity.<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Perhaps you should read API documentation for ArrayList first.

					<delay>2</delay>
					You can create an ArrayList instance like this:

					<delay>2</delay>
					List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(20);<break/>

					<delay>2</delay>
					In this case, 20 is initial capacity.

					<delay>2</delay>
					From Java7, you can omit the parameterized type.

					<delay>2</delay>
					List&lt;Integer&gt; list = new ArrayList&lt;&gt;(20);<break/>
You can't use primitive type as type parameter.
					<delay>2</delay>
					Why don&#39;t Java Generics support primitive types?
					<delay>2</delay>
					also helpful.

					<delay>2</delay>
				</li>
				<li>
					
					If your question is about the memory allocation part and considering you use a syntax like:
ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(20);<break/>
It just allocates memory for 20 Integer.
					<delay>2</delay>
					It still an empty ArrayList though.

					<delay>2</delay>
					This is intended to be used for performance reasons but for most common situation there isn't a big difference (without the memory preallocation that is).

					<delay>2</delay>
				</li>
				<li>
					
					Generally we should use the default constructor for any Collection object If we don't know the required size.
					<delay>2</delay>
					Because think about the situation you are creating an ArrayList of size 500 but actually you are adding only 5 items into it.
					<delay>2</delay>
					That is not recommended. 

					<delay>2</delay>
					We can not use primitives in Generics for type safety in Collections.
					<delay>2</delay>
					This restriction is for providing backward compatibility to older version java codes(Older than 1.5). 

					<delay>2</delay>
					For more details kindly have a look here:
					<delay>2</delay>
					Link 1, Link 2, Link 3, Link 5

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ arraylist construct ^ array ^ capacity </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How can I create a 2D array of 2D char arrays? -->
			^ create ^ 2d array ^ 2d char arrays 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					That seems complicated … but still, this is how:

					<delay>2</delay>
					char[][][][] board = new char[3][3][3][3];<break/>

					<delay>2</delay>
					This sounds like a Sudoku board.
					<delay>2</delay>
					It'd be much, much easier if you defined a 9x9 2D char array, taking care of iterating over the right zones whenever you have to (simply by controlling the looping variables).
					<delay>2</delay>
					Trust me, thinking in terms of a 4D array is gonna be a headache.

					<delay>2</delay>
				</li>
				<li>
					
					Create Array Class:
public class 2DChar {<break/>    private char[][] elem = new char[3][3];<break/>    //getters, setters...     <break/>}<break/>
Create Array of Array elements:
$
					<delay>2</delay>
					code_placeholder_2

					<delay>2</delay>
					Initialise
					<delay>2</delay>
					it:
for(int i = 0; i &lt; 2dCharArray.lenght(); i++) {<break/>   for(int j = 0; j &lt; 2dCharArray[i].lenght(); j++) {<break/>      2dCharArray[i][j] = new 2DChar();<break/>      //set value, etc...<break/>   }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					This could also work:
Object[][] array = new Object[3][3];<break/>char[][] subArray = new char[][] {{'a','b','c'},<break/>                                  {'d','e','f'},<break/>                                  {'g','h','i'}};<break/>array[0][0] = subArray;<break/>// initialize remaining arrays here<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ create ^ 2d array ^ 2d char arrays </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to remove items from array that are smaller than 20 characters? -->
			^ remove items ^ array ^ smaller ^ 20 characters 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Arrays in Java are fixed-size, just like in C. You can't remove an item from it, you can only update its value.
					<delay>2</delay>
					The value can also be null, which may serve your purpose.

					<delay>2</delay>
					However, it is not advised to use arrays for your use case; instead use a List implementation.
					<delay>2</delay>
					ArrayList is the default choice and a LinkedList
					<delay>2</delay>
					may make sense for a huge amount of additions and deletions in the middle of the list.

					<delay>2</delay>
					With Java 8, the best approach is to use the Streams API:
List&lt;String&gt; withLongStringsDiscarded = <break/>   myStringList.stream().filter(s -&gt; s.length() &lt;= 20).collect(Collectors.toList());<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Iterate over each of them, check the size using .length
					<delay>2</delay>
					() function, and create the array accordingly..

					<delay>2</delay>
					ArrayList&lt;String&gt; values = new ArrayList&lt;String&gt;();<break/>for (String str : strArray) {<break/>    if (str.length() &lt;= 20) {<break/>         values.add(str);<break/>    }<break/>}<break/>values.toArray();<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Use the following code, download common lang jar from apache url:
					<delay>2</delay>
					http://mirror.cc.columbia.edu/pub/software/apache//commons/lang/binaries/commons-lang3-
					<delay>2</delay>
					3.3.2-bin.zip
String[] arr = {"1","ab","aaa","sdfsdfew","ssdd"};<break/>for(String s : arr){<break/>    if(s.length()&gt;3){<break/>        arr = ArrayUtils.removeElement(arr, s);<break/>    }<break/>}<break/>System.out.println(ArrayUtils.toString(arr));<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ remove items ^ array ^ smaller ^ 20 characters </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to find if a field is an enum array using reflection? -->
			^ find ^ field ^ enum array using reflection 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					First check if the field is an array with field.getType().isArray(), and then check that the array component type is an enum with field.getType().getComponentType().isEnum()

					<delay>2</delay>
				</li>
				<li>
					
					As Holger mentioned in his comment a simple Enum[].class.isAssignableFrom will do it.

					<delay>2</delay>
					import javax.swing.SortOrder;<break/>public class Main {<break/>    private SortOrder[] sortOrders;<break/>    public static void main(String[] args) throws SecurityException,<break/>            NoSuchFieldException {<break/>        Field sortOrdersField = Main.class.getDeclaredField("sortOrders");<break/>        System.out.println(isEnumArray(sortOrdersField));<break/>    }<break/>    private static boolean isEnumArray(Field field) {<break/>        Class&lt;?&gt; type = field.getType();<break/>        return Enum[].class.isAssignableFrom(type);<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ find ^ field ^ enum array using reflection </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How much memory is allocated in Java when initializing a Object array? -->
			^ much memory ^ allocated ^ java ^ initializing ^ object array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Java always knows exactly how big each element of the array is going to be, because Java has only two kinds of arrays: arrays of primitives or arrays of object references.

					<delay>2</delay>
					If it's an array of primitives (int, long, etc.)
					<delay>2</delay>
					it's the size of the primitive; and if it's an array of objects then it's the size of references to objects (pointers).

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ much memory ^ allocated ^ java ^ initializing ^ object array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java Array String[] name or String name[] -->
			
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					It's the same thing, both works but the second one is discouraged.

					<delay>2</delay>
					The first one:
String[] myStringArray;<break/>
Is the default and the most used.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback></postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to use an enum for an array subscript in Java -->
			^ use ^ enum ^ array subscript ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Enum is not number.
					<delay>2</delay>
					But you can do SIZE.ordinal()

					<delay>2</delay>
				</li>
				<li>
					
					Here's the code.
					<delay>2</delay>
					It doesn't look like good practice, though.

					<delay>2</delay>
					int[] x = new int[EnumClass.values().length];<break/>

					<delay>2</delay>
					You can then access the element by ordinal()
int val = x[enumVar.ordinal()];<break/>

					<delay>2</delay>
					Still doesn't look like good practice.

					<delay>2</delay>
					Consider using Map&lt;EnumClass, AtomicInteger&gt; like EnumMap&lt;EnumClass, AtomicInteger&gt;.
					<delay>2</delay>
					Why atomic integer?
					<delay>2</delay>
					because it can have it's value modified instead of assigning a new instance all the time (at the cost of possibly unnecessary synchronization).
					<delay>2</delay>
					That's a different issue though.

					<delay>2</delay>
				</li>
				<li>
					
					For below enum
 enum test{VALUE_ONE, ... , SIZE};<break/>
Use SIZE like this
int[] x = new int[test.SIZE.ordinal()];<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can use: int[] x = new int[SIZE.ordinal()]; int var = x[SOME_VALUE.ordinal()];

					<delay>2</delay>
					Its position in its enum declaration, where the initial constant is assigned an ordinal of zero.

					<delay>2</delay>
					Or set special number for each enum elements.
					<delay>2</delay>
					like:
enum A {<break/>   VALUE_ONE(0),<break/>   SIZE(1),<break/>   ;<break/>   int value;<break/>   private A( int value) {<break/>      this.value = value;<break/>   }<break/>   public int getValue() {<break/>       return this.value;<break/>   }<break/>}<break/>int[] x = new int[A.SIZE.getValue()];<break/>int var = x[A.VALUE_ONE.getValue()];<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Use an EnumMap - it was intended for just this case.

					<delay>2</delay>
					enum Value {<break/>    VALUE_ONE, ... , VALUE_LAKH<break/>}<break/>Map&lt;Value, Integer&gt; x = new EnumMap&lt;&gt;();<break/>x.put(Value.VALUE_ONE, 13);<break/>
Internally uses an array (Integer[]).
					<delay>2</delay>
					The only disadvantage is using Integer instead of int.
					<delay>2</delay>
					And assumedly java 9 or 10 will introduce primitive generic types (List&lt;int&gt; and such).

					<delay>2</delay>
					BTW
					<delay>2</delay>
					EnumSet exists too, and is as efficient as BitSet.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ use ^ enum ^ array subscript ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Is it possible to store all bytes from file to array of bytes? -->
			^ possible ^ store ^ bytes ^ file ^ array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					yes, you can use IOUtils.toByteArray(InputStream input)
 to store it. 

					<delay>2</delay>
					also, if its a big file, you can increase java heap space by executing it with vm arguments:

					<delay>2</delay>
					java -Xmx6g myprogram<break/>
or
java -jar -Xmx6g myprogram.jar<break/>
the 6g means 6 Gigabytes of heap

					<delay>2</delay>
				</li>
				<li>
					
					As suggested by assylias, the 100% Java way to do this is with Files.readAllBytes(path).

					<delay>2</delay>
					Heap space errors depend on the file size and the amount of free memory in the JVM heap; you need to verify that the first is lower than the second before reading it:
File file = new File(path);<break/>bytes[] bytes;<break/>if (file.length &gt; Runtime.getRuntime().freeMemory()) {<break/>    // warn about reading<break/>} else {<break/>    bytes = Files.readAllBytes(path)<break/>    // do stuff with 'bytes'<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ possible ^ store ^ bytes ^ file ^ array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to make the second row of an array point to the first row in C -->
			^ make ^ second row ^ array point ^ first row ^ c 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					In C++:
int **a  = new int*[2];<break/>a[0] = new int[4];<break/>a[1] = a[0];<break/>

					<delay>2</delay>
					In C:
int **a  = malloc(2*sizeof(*a));<break/>a[0] = malloc(4*sizeof(*a[0])];<break/>a[1] = a[0];<break/>

					<delay>2</delay>
				</li>
				<li>
					
					In C/C++, one declares a two dimensional array the same as in JAVA, but the memory allocation by the compiler is different.  
					<delay>2</delay>
					E.g., in C one declares a two-dimensional array of int as a contiguous block of memory.

					<delay>2</delay>
					int a[][]=new int[2][4]  <break/>
is allocated as contiguous block of 32(2*4*4)bytes.
					<delay>2</delay>
					It has only only one reference pointing to the block beginning.
					<delay>2</delay>
					If you want to access an element at (i,j) then it returns the value at reference a+(i*2+j).

					<delay>2</delay>
					But in java it allocates a array of 2 pointers and allocates each row again.

					<delay>2</delay>
					a= new int[2][];<break/>a[0] = new int[4];<break/>a[1] = new int[4];<break/>

					<delay>2</delay>
					So you can modify the references for each row.

					<delay>2</delay>
					But in C++ also you can achieve the JAVA behavior by using the following code.

					<delay>2</delay>
					int **a = new int*[2];<break/>a[0] = new int[4];<break/>a[1] = new int[4];<break/>a[0] = a[1];<break/>

					<delay>2</delay>
					If you need in C you should be able to do the same thing with malloc.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ make ^ second row ^ array point ^ first row ^ c </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Why the new capacity of arraylist is (oldCapacity * 3)/2 + 1? -->
			^ new capacity ^ arraylist ^ oldcapacity ^ 1 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Resizing the array is a relatively expensive operation.
					<delay>2</delay>
					It wants to try and make sure that if the method gets called with ensureCapacity(11), ensureCapacity(12), ensureCapacity(13), ... it should not have to resize the array every time.
					<delay>2</delay>
					So it resizes by a reasonable chunk (increase by 50%) instead of the minimum specified.

					<delay>2</delay>
				</li>
				<li>
					
					The main reason lies the (asymptotic) complexity of adding a sequence of elements to the list.

					<delay>2</delay>
					Note that the add method internally calls ensureCapacity(size+1).
					<delay>2</delay>
					When the size of the internal array is increased, all elements have to be copied into the new, larger array.

					<delay>2</delay>
					If the size was only increased by a constant amount (which would be 1 for each call to add), then adding n elements would have a complexity of O(n2). 

					<delay>2</delay>
					Instead, the size is always increased by a constant factor.
					<delay>2</delay>
					Then, adding n elements only has a complexity of O(n). 

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ new capacity ^ arraylist ^ oldcapacity ^ 1 </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- In Java, why is the class "Arrays" plural? -->
			^ java ^ class ^ arrays ^ plural 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Because it's a collection of utilities to work with arrays.
					<delay>2</delay>
					The other examples you've mentioned are actually instances of a particular type of collection. 

					<delay>2</delay>
					For example, the same naming convention has been followed in Guava for Lists, Sets, Maps etc.

					<delay>2</delay>
				</li>
				<li>
					
					The Utility classes which deals with Arrays, Files, Paths, Objects or Collections are plural.
					<delay>2</delay>
					Exactly because they are not an Array or a Collection but rather a number of utility functions to work on them.
					<delay>2</delay>
					You can even see that in the Javadoc intro:
  This class contains various methods for manipulating arrays

					<delay>2</delay>
					Some of those classes are fairly new additions in 1.7.
					<delay>2</delay>
					So this explains their common naming convention.
					<delay>2</delay>
					I am not sure if there is a written conventions for it, but it is surely a practical one.

					<delay>2</delay>
				</li>
				<li>
					
					It is a collection of utilities that deals with arrays, and doesn't represent the array itself.
					<delay>2</delay>
					Also there is another class with name Array.
					<delay>2</delay>
					Check this https://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Array.html

					<delay>2</delay>
				</li>
				<li>
					
					HashMap, ArrayList, etc are objects.
					<delay>2</delay>
					They are data structures which offer different features and have different uses. 

					<delay>2</delay>
					Arrays (or Collections) on the other hand is not an object.
					<delay>2</delay>
					Arrays is a class which features only static utility methods that can perform convenient operations on arrays.

					<delay>2</delay>
				</li>
				<li>
					
					It's up to author and code conversions how to name classes.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java ^ class ^ arrays ^ plural </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Printwrite always overwriting file -->
			^ printwrite always overwriting file 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Use append mode:
FileWriter output = new FileWriter("result.txt", true);<break/>PrintWriter write = new PrintWriter(new BufferedWriter(output));<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ printwrite always overwriting file </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Filling in a matrix in java -->
			^ filling ^ matrix ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					int [][] matrix = new int[10][20];<break/>for(int i = 0; i &lt; 10; i++) {<break/>    for(int j = 0; j &lt; 20; j++) {<break/>        // read information from somewhere<break/>        matrix[i][j] = information;<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					int [][] arr = new int[x][y];<break/>for(int i = 0; i &lt; x; i++) {        // it will run you through the lines <break/>    for(int j = 0; j &lt; y; j++) {    // this will run you through each cell in the raw selected<break/>        arr[i][j] = &lt;the thing you want to fill here&gt; ;<break/>    }<break/>}<break/>
you can look at a matrix as an array of arrays
the first for is to run trough the array

					<delay>2</delay>
					the second is for the cells in each array 

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ filling ^ matrix ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Why is CopyOnWriteArrayList different than iterating over unmodifiableList? -->
			^ copyonwritearraylist different ^ iterating ^ unmodifiablelist 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					The javadoc of CopyOnWriteArrayList states
  A thread-safe variant of ArrayList in which all mutative operations
  (add, set, and so on) are implemented by making a fresh copy of the
  underlying array.

					<delay>2</delay>
					While the javadoc of Collections#unmodifiableList(List) states
  Returns an unmodifiable view of the specified list.
					<delay>2</delay>
					This method allows
  modules to provide users with "read-only" access to internal lists.
  
  
					<delay>2</delay>
					Query operations on the returned list "read through" to the specified
  list, and attempts to modify the returned list, whether direct or via
  its iterator, result in an UnsupportedOperationException.

					<delay>2</delay>
					So, no, you can't get the features provided by CopyOnWriteArrayList with a List returned by Collections#unmodifiableList(List).

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ copyonwritearraylist different ^ iterating ^ unmodifiablelist </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- In a 2-dimensional array of integers, how can we place a new integer at a completly random spot in the 2-d array? -->
			^ 2 ^ dimensional array ^ array ^ integers ^ place ^ new integer ^ completly random spot 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					static void placeRandomly2D(int[][] arr, int limit) {<break/>// generates value [0...limit) half-interval and places it into the 2D array arr<break/>//    at random position; limit must be positive<break/>    Random rand = new Random();<break/>    int value = rand.nextInt(limit);<break/>    int pos1 = rand.nextInt(arr.length);<break/>    int pos2 = rand.nextInt(arr[pos1].length);<break/>    arr[pos1][pos2] = value;<break/>}<break/>

					<delay>2</delay>
					And, just in case, version for 1-dimensional array:
static void placeRandomly1D(int[] arr, int limit) {<break/>// generates value [0...limit) half-interval and places it into the 1D array arr<break/>//    at random position; limit must be positive<break/>    Random rand = new Random();<break/>    int value = rand.nextInt(limit);<break/>    int pos = rand.nextInt(arr.length);<break/>    arr[pos] = value;<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ 2 ^ dimensional array ^ array ^ integers ^ place ^ new integer ^ completly random spot </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Creating an array that stores strings and integers in java -->
			^ creating ^ array ^ stores strings ^ integers ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You can either use array declaration or array literal (but only when you declare and affect the variable right away, array literals cannot be used for re-assigning an array).

					<delay>2</delay>
					For primitive types:
int[] myIntArray = new int[3];<break/>int[] myIntArray = {1,2,3};<break/>int[] myIntArray = new int[]{1,2,3};<break/>
For classes, for example String, it's the same:
String[] myStringArray = new String[3];<break/>String[] myStringArray = {"a","b","c"};<break/>String[] myStringArray = new String[]{"a","b","c"};<break/>
Extra Info:
If you are knew to coding in Java here are some tutorials:http://www.youtube.com/watch?v=Cfd9DOnuF9w

					<delay>2</delay>
					-HAPPY CODING!

					<delay>2</delay>
				</li>
				<li>
					
					You have two choices:
Use an array.

					<delay>2</delay>
					public class Value {<break/>  public String name;<break/>  public int number;<break/>}<break/>...<break/>public Value[] values = new Value[10];<break/>....<break/>
Use a map which has much more comfort, specially you can use the name as key to get a value
....<break/>public Map&lt;String, int&gt; valueMap = new HashMap&lt;String,int&gt;();<break/>valueMap.put("Sample",10);<break/>int value = valueMap.get("Sample");<break/>...<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can use a Map data structure instead of an array.
					<delay>2</delay>
					This is basically a type of Collection that has key-value pairs.
					<delay>2</delay>
					Your string name can be used as the key and the value is your integer.

					<delay>2</delay>
					Map&lt;String,Integer&gt; myMap = new HashMap&lt;String, Integer&gt;;<break/>MyMap.put("someone", 6);<break/>
Note that using a HashMap has a speed advantage over an array during lookup.
					<delay>2</delay>
					The complexity of HashMap lookup is O(log(n))
					<delay>2</delay>
					while that of an array is O(n).

					<delay>2</delay>
				</li>
				<li>
					
					An Object[] can hold both String and Integer objects.  
					<delay>2</delay>
					Here's a simple example:
    Object[] mixed = new Object[2];<break/>    mixed[0] = "Hi Mum";<break/>    mixed[1] = Integer.valueOf(42);<break/>    ...<break/>    String message = (String) mixed[0];<break/>    Integer answer = (Integer) mixed[1];<break/>

					<delay>2</delay>
					However, if you put use an Object[] like this, you will typically need to use instanceof and / or type casts when accessing the elements.

					<delay>2</delay>
					Any design that routinely involves instanceof and/or type casts needs to be treated with suspicion.  
					<delay>2</delay>
					In most cases, there is a better (more object-oriented, more efficient, less fragile) way of achieving the same ends.

					<delay>2</delay>
					In your particular use-case, it sounds like what you really need is a mapping object that maps from String (names) to Integer (numbers of stocks).  
					<delay>2</delay>
					And the nice thing about Java is that there are existing library classes that provide this functionality;
					<delay>2</delay>
					e.g. the Object[]0 class, with Object[]1 as the key type and Object[]2 as the value type.

					<delay>2</delay>
					Another possibility might be an array, Object[]3 or Object[]4 of some custom or generic pair class.  
					<delay>2</delay>
					These have different semantic properties to Object[]5 types.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ creating ^ array ^ stores strings ^ integers ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Convert List of object arrays to list of objects in Java -->
			^ convert list ^ list ^ object arrays ^ objects ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					No.

					<delay>2</delay>
					Why don't you just write the function yourself?
					<delay>2</delay>
					It would probably be faster than asking this question and waiting for an answer.

					<delay>2</delay>
				</li>
				<li>
					
					You can easily write one yourself:
public static&lt;T&gt; List&lt;T&gt; append (List&lt;T[]&gt; input) {<break/>    List&lt;T&gt; res = new ArrayList&lt;T&gt;();<break/>    for(T[] subarr : input) {<break/>        if(subarr != null) {<break/>            int n = subarr.length;<break/>            for(int i = 0; i &lt; n; i++) {<break/>                res.add(subarr[i]);<break/>            }<break/>        }<break/>    }<break/>    return res;<break/>}<break/>

					<delay>2</delay>
					The function appends the different arrays and null arrays are ignored, null elements are however not.
					<delay>2</delay>
					Thus if the input is [null,[a,b],[null,null],[c,null,d],null].
					<delay>2</delay>
					The output is [a,b,null,null,c,null,d].

					<delay>2</delay>
				</li>
				<li>
					
					No, there's no method that does this directly for you.
					<delay>2</delay>
					You can write a nested for loop or use the flatMap of the stream API as follows:
List&lt;Object&gt; flat = objArrs.stream()<break/>                           .flatMap(Stream::of)<break/>                           .collect(Collectors.toList());<break/>

					<delay>2</delay>
				</li>
				<li>
					
					In Java 8 you can do it with Streams :
List&lt;Object[]&gt; list = ...<break/>List&lt;Object&gt; l = list.stream()<break/>                     .flatMap(arr -&gt; Stream.of(arr))<break/>                     .collect(Collectors.toList());<break/>

					<delay>2</delay>
				</li>
				<li>
					
					As others have already said, there is no utility and creating one yourself wouldn't be hard, for example using old school for loops:
public List&lt;Object&gt; flatten( List&lt;Object[]&gt; source )<break/>{<break/>    // if ( source == null ) return null; // which check you use it up to you<break/>    List&lt;Object&gt; result = new ArrayList&lt;Object&gt;();<break/>    if ( source == null ) return result; // Personally I like this check<break/>    for ( Object[] array: source )<break/>    {<break/>        if ( array == null ) continue; // skip nulls<break/>        for ( Object object: array )<break/>        {<break/>            result.add(object);<break/>        }<break/>    }<break/>    return result;<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ convert list ^ list ^ object arrays ^ objects ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How can I convert a video to byte array and then byte array back to video in parse? -->
			^ convert ^ video ^ byte array ^ byte array back ^ parse 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					I'm not sure that you will reduce a video's size by putting each byte into an array.

					<delay>2</delay>
					If I have a video that is 4,000 bytes then you will have an array of exactly 4,000 bytes (including all of the overhead of the array itself in memory).

					<delay>2</delay>
					There is a method on a ParseFile object called .getData() that will return a byte[] array.  
					<delay>2</delay>
					So if you have a video stored in Video class in the data column you can do something like this:
byte[] bytes_of_video = videoObject.getParseFile("data").getBytes();
Now you have a byte array of the video object but the byte array will be just as big as the video file since no compression took place.  
					<delay>2</delay>
					If you want to compress the video file you can use Android's zlib compression with Deflater:

					<delay>2</delay>
					byte[] originalBytes = bytes_of_video;<break/>     Deflater deflater = new Deflater();<break/>     deflater.setInput(originalBytes);<break/>     deflater.finish();<break/>     ByteArrayOutputStream baos = new ByteArrayOutputStream();<break/>     byte[] buf = new byte[8192];<break/>     while (!deflater.finished()) {<break/>         int byteCount = deflater.deflate(buf);<break/>         baos.write(buf, 0, byteCount);<break/>     }<break/>     deflater.end();<break/>     byte[] compressedBytes = baos.toByteArray();<break/>

					<delay>2</delay>
					I don't know if you are wanting to save space on the server or on the device but to save bandwidth costs you could store the compressed video data in your ParseFile object in the server and then decompress the file on the device when it's ready to be viewed/used.  
					<delay>2</delay>
					But a compressed video file on the device is not very useful since you won't be able to view/edit
					<delay>2</delay>
					/use it while it's in a compressed format.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ convert ^ video ^ byte array ^ byte array back ^ parse </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Hive: apply lowercase to an array -->
			^ hive ^ apply lowercase ^ array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					If your use case is that you are transforming an array in isolation (not as part of a table), then the combination of explode, lower, and collect_list should do the trick.  
					<delay>2</delay>
					For example (please pardon the horrible execution times, I'm running on an underpowered VM):
hive&gt; SELECT collect_list(lower(val))<break/>    &gt; FROM (SELECT explode(array('AN', 'EXAMPLE', 'ARRAY')) AS val) t;<break/>...<break/>... Lots of MapReduce spam<break/>...<break/>MapReduce Total cumulative CPU time: 4 seconds 10 msec<break/>Ended Job = job_1422453239049_0017<break/>MapReduce Jobs Launched: <break/>Job 0: Map: 1  Reduce: 1   Cumulative CPU: 4.01 sec   HDFS Read: 283 HDFS Write: 17 SUCCESS<break/>Total MapReduce CPU Time Spent: 4 seconds 10 msec<break/>OK<break/>["an","example","array"]<break/>Time taken: 33.05 seconds, Fetched: 1 row(s)<break/>
(Note:  Replace array('AN', 'EXAMPLE', 'ARRAY') in the above query with whichever expression
					<delay>2</delay>
					you are using to generate the array.

					<delay>2</delay>
					If instead your use case is such that your arrays stored in a column of a Hive table and you need to apply the lowercase transformation to them, to my knowledge
					<delay>2</delay>
					you have two principle options:

					<delay>2</delay>
					Approach #1:  Use the combination of explode and LATERAL VIEW to separate the array.  
					<delay>2</delay>
					Use lower to transform the individual elements, and then collect_list to glue them back together.  
					<delay>2</delay>
					A simple example with silly made-up data:

					<delay>2</delay>
					explode0
Approach #2:  Write a simple UDF to apply the transformation.  
					<delay>2</delay>
					Something like:
explode1

					<delay>2</delay>
					And then invoke the UDF directly on the data:

					<delay>2</delay>
					explode2

					<delay>2</delay>
					There are some trade-offs between the two approaches.  
					<delay>2</delay>
					#2 will probably be more efficient at runtime in general than #1, since the explode3 clause in #1 forces a reduction stage while the UDF approach does not.  
					<delay>2</delay>
					However, #1 does everything in HiveQL and is a bit more easily generalized (you can replace explode4 with some other kind of string transformation in the query if you needed to).  
					<delay>2</delay>
					With the UDF approach of #2, you potentially have to write a new UDF for each different kind of transformation you want to apply.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ hive ^ apply lowercase ^ array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Sorting an array of String based on the strings sizes (length) -->
			^ sorting ^ array ^ string based ^ strings sizes ^ length 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You can implement a Comparator that uses the length and use Arrays.sort with your Comparator.
					<delay>2</delay>
					The Comparator could look like this:
class StringComparator implements Comparator&lt;String&gt;{<break/>   public int compare(String o1, String o2){<break/>      return Integer.compare(o1.length(), o2.length());<break/>   }<break/>}<break/>

					<delay>2</delay>
					Now you could sort with the following call:
Arrays.sort(strings, new StringComparator());<break/>

					<delay>2</delay>
				</li>
				<li>
					
					In Java 8, this can be done in one line,
Arrays.sort(randomString, (s1,s2) -&gt; Integer.compare(s1.length(), s2.length()));<break/>

					<delay>2</delay>
					If you want reverse order (higher-length to lower-length),
change it to, 

					<delay>2</delay>
					Arrays.sort(randomString, (s1,s2) -&gt; Integer.compare(s2.length(), s1.length()));<break/>

					<delay>2</delay>
					Another approach,
use Comparator.comparing(String::length),
Arrays.sort(yourArray, Comparator.comparing(String::length)); <break/>
to reverse the order,
Arrays.sort(yourArray, Comparator.comparing(String::length).reversed()); <break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ sorting ^ array ^ string based ^ strings sizes ^ length </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Arraylist and Inheritance in Java -->
			^ arraylist ^ inheritance ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					List&lt;Parent&gt; listValue = new ArrayList&lt;Parent&gt;();<break/>listValue.add(new Child1());<break/>listValue.add(new Child2());<break/>
Both Child1
					<delay>2</delay>
					and Child2 are inherited from "Parent" Class.

					<delay>2</delay>
				</li>
				<li>
					
					You can look java library classes for this.

					<delay>2</delay>
					For example Shape class is superclass of Rectangle and Polygon classes
ArrayList&lt;Shape&gt; list = new ArrayList&lt;Shape&gt;();<break/>list.add(new Rectangle());<break/>list.add(new Polygon());<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can do it by creating "ArrayList" of super class.

					<delay>2</delay>
					Than you can add the child class elements in the "ArrayList".

					<delay>2</delay>
					List&lt;SuperClass&gt; tempList=new ArrayList&lt;SuperClass&gt;();<break/>tempList.add(childClass1);<break/>tempList.add(childClass2);<break/>
Hope this solves your problem.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ arraylist ^ inheritance ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How can I define a method that can return the biggest variable in a array -->
			^ define ^ method ^ return ^ biggest variable ^ array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You could do something like:
Integer array[] = {1, 4, 3, 2};<break/>int max = Collections.max(Arrays.asList(array));<break/>System.out.println(max);<break/>Output:<break/>4<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ define ^ method ^ return ^ biggest variable ^ array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to reference a subarray of a two dimensional array as a single dimensional array in java -->
			^ reference ^ subarray ^ two dimensional array ^ single dimensional array ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					If I understood question correctly, this is it
    int a[][] = {{1,1,1},{2,2,2}, {3,3,3}};<break/>    int[] a2 = a[2];<break/>
,

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ reference ^ subarray ^ two dimensional array ^ single dimensional array ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Is it possible to delete index of an array in java? -->
			^ possible ^ delete index ^ array ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Just assign the blank space to the position of the character you want to replace -
					<delay>2</delay>
					it's not a real deletion, an array in Java is of fixed length (it can't be resized):
array[index] = ' ';<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You cannot delete an index from an array.
					<delay>2</delay>
					This is because arrays have a fixed length that cannot be changed.
					<delay>2</delay>
					If you want a list which you can delete elements, check out the ArrayList class.
					<delay>2</delay>
					Here is the documentation:
					<delay>2</delay>
					http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ possible ^ delete index ^ array ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Why doesn't ArrayList class have a newInstance() method? -->
			^ arraylist class 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Method newInstance() belongs to the class called Class.
					<delay>2</delay>
					Javadoc:
  Creates a new instance of the class represented by this Class object.
					<delay>2</delay>
					The class is instantiated as if by a new expression with an empty argument list.

					<delay>2</delay>
					So these two are equivalent:

					<delay>2</delay>
					ArrayList a = new ArrayList();<break/>ArrayList b = ArrayList.class.newInstance();<break/>
You can do this for every class, but it is not recommended because you lose compile-time safety (it may fail at run-time if there is no no-arg constructor) and cannot track usages.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ arraylist class </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- how can i compare an element stored in an Arraylist with an integer? -->
			^ compare ^ element stored ^ arraylist ^ integer 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You should consider using ArrayList.contains()
ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();<break/>// populate your list here<break/>Integer i = 1;<break/>System.out.println(list.contains(i));<break/>
You have to autobox primitive int type into Integer since ArrayList&lt;T&gt; uses generics and they don't allow to use primitive types.

					<delay>2</delay>
					EDITED for purists.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ compare ^ element stored ^ arraylist ^ integer </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to access an array thread safely in Java? -->
			^ access ^ array thread safely ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Operation on array in java is not thread safe.
					<delay>2</delay>
					Instead you may use ArrayList with Collections.synchronizedList()   

					<delay>2</delay>
					Suppose we are trying to populate a synchronized ArrayList of String.
					<delay>2</delay>
					Then you can add item to the list like - 
List&lt;String&gt; list = <break/>         Collections.synchronizedList(new ArrayList&lt;String&gt;());<break/>       //Adding elements to synchronized ArrayList<break/>       list.add("Item1");<break/>       list.add("Item2");<break/>       list.add("Item3"); <break/>
Then access them from a synchronized block like this
					<delay>2</delay>
					- 
synchronized(list) {<break/>       Iterator&lt;String&gt; iterator = list.iterator(); <break/>       while (iterator.hasNext())<break/>       System.out.println(iterator.next());<break/>}  <break/>

					<delay>2</delay>
					Or you may use a thread safe variant of ArrayList - CopyOnWriteArrayList.
					<delay>2</delay>
					A good example can be found here. 

					<delay>2</delay>
					Hope it will help.

					<delay>2</delay>
				</li>
				<li>
					
					You will not get an invalid state when changing arrays using multiple threads.
					<delay>2</delay>
					However if a certain thread has edited a value in the array, there is no guarantee that another thread will see the changes.
					<delay>2</delay>
					Similar issues occur for non-volatile variables.

					<delay>2</delay>
				</li>
				<li>
					
					array operations are not threadsafe.
					<delay>2</delay>
					you can either lock on a field, i would recommend to add a field e.g. named LOCK and do the
void add(){<break/> syncronized(LOCK) {<break/>  // add<break/> }<break/>}<break/>void get(int i){<break/> synchronized(LOCK){ <break/>   // return<break/> }<break/>}<break/>
or simply use
java.util.concurrent.*<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ access ^ array thread safely ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- What is the difference between these two statements in Java? -->
			^ difference ^ two statements ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					These two statements are technically grammatically different but have identical effects.

					<delay>2</delay>
					An array initializer can appear as part of a local variable declaration initializer as in:
int[] X = {1,2,3};<break/>
and also an array creation expression as in:
new int[] {1,2,3}<break/>

					<delay>2</delay>
					And yes, X will be on the heap.
					<delay>2</delay>
					All objects in Java are on the heap and since arrays are objects, all arrays are on the heap.

					<delay>2</delay>
				</li>
				<li>
					
					The only difference is that the first statement works only when the array variable is declared, while the second can be written separately from the declaration :
int[] X;<break/>int[] Y;<break/>X = {1,2,3}; // doesn't work<break/>Y = new int[] {1,2,3}; // works<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Java provides a ease of initializing arrays.
					<delay>2</delay>
					So with out new operator you can directly assign value.
					<delay>2</delay>
					Like
 int[] X={1,2,3};<break/>
Here the size of array is know by no.of elements in the initialization block. 

					<delay>2</delay>
					Another way of initializing is using new operator.

					<delay>2</delay>
					int[] y=new int[]{1,2,3};<break/>
String variable also uses the both the way of initialization.
					<delay>2</delay>
					But in Strings these two types have different meaning.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ difference ^ two statements ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java declaring an array. What is the difference? -->
			^ java declaring ^ array ^ difference 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					From Oracle Java documentation
Declaring a Variable to Refer to an Array
Declare an array (named anArray) with the following line of code:
// declares an array of integers<break/>int[] anArray;<break/>
Like declarations for variables of other types, an array declaration has two components: the array's type and the array's name.
					<delay>2</delay>
					An array's type is written as type[], where type is the data type of the contained elements; the brackets are special symbols indicating that this variable holds an array.
					<delay>2</delay>
					The size of the array is not part of its type (which is why the brackets are empty).
					<delay>2</delay>
					An array's name can be anything you want, provided that it follows the rules and conventions as previously discussed in the naming section.
					<delay>2</delay>
					As with variables of other types, the declaration does not actually create an array; it simply tells the compiler that this variable will hold an array of the specified type.

					<delay>2</delay>
					Similarly, you can declare arrays of other types:
byte[] anArrayOfBytes;<break/>short[] anArrayOfShorts;<break/>long[] anArrayOfLongs;<break/>float[] anArrayOfFloats;<break/>double[] anArrayOfDoubles;<break/>boolean[] anArrayOfBooleans;<break/>char[] anArrayOfChars;<break/>String[] anArrayOfStrings;<break/>

					<delay>2</delay>
					You can also place the brackets after the array's name:

					<delay>2</delay>
					// this form is discouraged<break/>float anArrayOfFloats[];<break/>
However, convention discourages this form; the brackets identify the array type and should appear with the type designation.

					<delay>2</delay>
					So, there is no difference between using these two type of declarations.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java declaring ^ array ^ difference </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to check an array of an array for an object -->
			^ check ^ array ^ object 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You have to use nested loops.
					<delay>2</delay>
					Suppose you have an array of arrays of Integer, and you want to check if a specific number is inside the array:

					<delay>2</delay>
					static boolean contains(Integer[][] array, Integer wantedInt) {<break/>    // For each sub-array<break/>    for (int i = 0; i &lt; array.length; i++) {<break/>        // For each element in the sub-array<break/>        for (int j = 0; j &lt; array[i].length; j++) {<break/>            // If the element is the wanted one<break/>            if (array[i][j].equals(wantedInt)) {<break/>                // We've found it<break/>                return true;<break/>            }<break/>        }<break/>    }<break/>    // We didn't find the wanted number<break/>    return false;<break/>}<break/>

					<delay>2</delay>
					You could use the same logic to search for any object type by using generics:
static &lt;T&gt; boolean contains(T[][] array, T wantedObj) {<break/>    for (int i = 0; i &lt; array.length; i++) {<break/>        for (int j = 0; j &lt; array[i].length; j++) {<break/>            if (array[i][j].equals(wantedObj)) {<break/>                return true;<break/>            }<break/>        }<break/>    }<break/>    return false;<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					 Object objects[][] = new Object[100][];<break/> Object objectToLocate = null;<break/>     outerloop:<break/>     for (Object[] object : objects) {<break/>        for (Object o : objects) {<break/>            if (o == objectToLocate) {<break/>                System.out.println("Found it!");<break/>                break outerloop;<break/>            }<break/>        }<break/>    }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Here is a solution for objects:
    Object[][] twoDArray = new Object[x][y];<break/>    // Fill array<break/>    for (int i = 0; i &lt; twoDArray.length; ++i)<break/>    {<break/>        for (int j = 0; j &lt; twoDArray[i].length; ++j)<break/>        {<break/>            if (twoDArray[i][j].equals(someObject))<break/>            {<break/>                // do something<break/>            }<break/>        }<break/>    }<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ check ^ array ^ object </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- how to take input from user and insert it in a arrayList -->
			^ take input ^ user ^ insert ^ arraylist 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					I think this is what you are looking for
   ----------------------- Main Class File --------------------<break/>   public class TestingClass {<break/>      public static void main(String[] args) {<break/>        Scanner input = new Scanner(System.in);<break/>        System.out.println("Please enter the number of students detail : ");<break/>        int numberOfInputs = input.nextInt();<break/>        ArrayList&lt;Student&gt; StudentList = new ArrayList&lt;Student&gt;();<break/>        for( int i=0;  i &lt; numberOfInputs ; i++){<break/>            System.out.println("Please enter Name : ");<break/>            String name = input.next();<break/>            System.out.println("Please enter Address : ");<break/>            String address = input.next();<break/>            Student std = new Student(name, address);<break/>            StudentList.add(std);<break/>        }<break/>        for(Student std : StudentList){<break/>            System.out.println(std.toString());<break/>        }<break/>     }<break/>    }<break/>   -------------------- Student Java File ----------------------<break/>     public class Student {<break/>       public String    name    = "";<break/>       public String    address = "";<break/>       public Student(String name2, String address2) {<break/>           this.name = name2;<break/>           this.address = address2;<break/>       }<break/>     @Override<break/>     public String toString() {<break/>         return "Student [name=" + this.name + ", address=" + this.address + "]";<break/>        }<break/>     }<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ take input ^ user ^ insert ^ arraylist </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java - Pass double as arguments without giving actual value -->
			^ java ^ pass double ^ arguments without giving actual value 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					To the first question: There is no variable cost within addSession().
					<delay>2</delay>
					If you have not defined an attribute cost within Session then this is the problem.

					<delay>2</delay>
					To the second question: I am not quite sure that I understand your problem correctly.
					<delay>2</delay>
					You have an int[] values and want to know, whether a given int x is within that array?
					<delay>2</delay>
					If so, you can achieve this with this code snippet:
for (int value : values) {<break/>    if (value == x) {<break/>        // Put code, that should be executed when the value is found, here<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Can you place the Super class Record also in your question?

					<delay>2</delay>
					Probably, you need to check the super constructor, which is differing from your sub class constructor.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java ^ pass double ^ arguments without giving actual value </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to jumble the elements in an integer array? -->
			^ jumble ^ elements ^ integer array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					
When an Double Integer is given
This statement is wrong , As @Mike Kobit mentioned , double is not same as integer , but for an Integer Array
Try this
Integer i[]=new Integer[]{1,2,3,4,5};<break/>List&lt;Integer&gt; list=Arrays.asList(i);<break/>System.out.println(list);  ------&gt; Before Shuffling<break/>Collections.shuffle(list);<break/>System.out.println(list); -------&gt; After shuffling<break/>list.toArray(i);  -----&gt; Convert list back to array<break/>
Output
[1, 2, 3, 4, 5] --&gt;Before Shuffling<break/>[1, 3, 4, 2, 5] --&gt; After Shuffling<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ jumble ^ elements ^ integer array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- ArrayUtils.reverse() Usage -->
			^ arrayutils 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					The error refers to the fact that ArrayUtils cannot be found among your classes, the standard Java runtime or the libraries in your classpath.

					<delay>2</delay>
					ArrayUtils is part of Apache Commons, you need to include that jar library in your project and to add an import org.apache.commons.lang.ArrayUtils on top, to make this work.

					<delay>2</delay>
				</li>
				<li>
					
					try Collections.reverse(yourArrayList);
for javadoc, docs.oracle.com/...

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ arrayutils </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Array vs. ArrayList - Why would you use one over the other? -->
			^ array vs ^ arraylist ^ would ^ use one 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Array takes up less space and are typically faster, ArrayList lets you add and remove elements from your array (can be useful for a lot of reasons).

					<delay>2</delay>
				</li>
				<li>
					
					Array is perfect, if you have a fixed number of items.
					<delay>2</delay>
					It is fast and can be accessed by index.

					<delay>2</delay>
					ArrayList is more flexible, the list can easily extended by using add() function.
					<delay>2</delay>
					ArrayList can also be accessed by index (using get(int i)).

					<delay>2</delay>
					So at the end it boils down to fixed length or not.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ array vs ^ arraylist ^ would ^ use one </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Is it possible to dynamically initialize an array using "java.lang.reflect.Array" dynamically in Java? -->
			^ possible ^ dynamically initialize ^ dynamically ^ array using ^ array ^ java ^ lang ^ reflect 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					If you want to initialise the array to a size specified by the user, just use a variable for the size.

					<delay>2</delay>
					int size = 3;<break/>int[] array = new int[size];<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Yes you can use java.lang.reflect.Array class to create an array.

					<delay>2</delay>
					See the following code where we can create an array of int.

					<delay>2</delay>
					int[] intArray = (int[]) java.lang.reflect.Array.newInstance(int.class, 5);<break/>

					<delay>2</delay>
					The first parameter is the type of each element in the array.

					<delay>2</delay>
					The second parameter indicates the number of elements in the array.

					<delay>2</delay>
				</li>
				<li>
					
					Try this:
public static void main(String[] args){<break/>    Scanner sc = new Scanner(System.in);<break/>    System.out.println("Enter the size of your array:");<break/>    int arraySize = sc.nextInt();<break/>    int[] yourArray = new int[arraySize];<break/>    //Do something with your array<break/>}<break/>
Note that this does not check for invalid input.
					<delay>2</delay>
					You should add checks to confirm the input is actually positive and an integer.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ possible ^ dynamically initialize ^ dynamically ^ array using ^ array ^ java ^ lang ^ reflect </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Anonymous arrays in Java -->
			^ anonymous arrays ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Hello imagine that you have the following code:
public class Test { <break/>    public static void printArray(int []arr){<break/>        for (int i : arr) {<break/>            System.out.print(i);<break/>        }<break/>    }<break/>    public static void main(String[] args) {<break/>        int arr[]={1,2,3,4,5,6};<break/>        printArray(arr);<break/>    }<break/>}<break/>

					<delay>2</delay>
					The output is 123456.
					<delay>2</delay>
					If you want to call the printArrayMethod in a single line you have to use a anonymous array like the following:
printArray(new int[]{1,2,3,4,5,6});<break/>
You cant use something like the following:
printArray({1,2,3,4,5,6});<break/>
It is going to provoke a compilation fail.

					<delay>2</delay>
					And the question is, Why do I need to use an anonymous array and not a normal array like the first example.

					<delay>2</delay>
					Check the following code:
$
					<delay>2</delay>
					code_placeholder_5

					<delay>2</delay>
					If you use a normal array this array is going to alive in your heap during all the main method execution and with the anonymous array you are only use this array to the printArray method and after this the object is going to be eligible to the garbage collector.

					<delay>2</delay>
				</li>
				<li>
					
					If you mean anonymous arrays like anonymous class where it was declared and instantiated at the same time without a name.
					<delay>2</delay>
					The example below shows when you would use it.

					<delay>2</delay>
					For example, you have a method which expects an array of int as the argument in the parameter list.

					<delay>2</delay>
					public void fillPolygon(int[] xPoints, int[] yPoints, nPoints)<break/>

					<delay>2</delay>
					To invoke this method:
int[] xPoints = {1,2,3};<break/>int[] yPoints = {4,5,6};<break/>g.fillPolygon(xPoints, yPoints, 3);<break/>
You can also write it as:
g.fillPolygon(new int[]{1,2,3}, new int[]{4,5,6}, 3);<break/>

					<delay>2</delay>
					In what scenario anonymous arrays are used?

					<delay>2</delay>
					A:
					<delay>2</delay>
					Use it when you are only going to use it once because you do not keep a reference (name) for the arrays.

					<delay>2</delay>
					Q: So what is the benefit of using &quot;anonymous array&quot;?

					<delay>2</delay>
					A: It keeps your codes concise.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ anonymous arrays ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Printing elements from Nth index onward in an array -->
			^ printing elements ^ nth index onward ^ array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					If you are using Java-8, you can do this :
Arrays.stream(array).skip(2).forEach(System.out::println);<break/>

					<delay>2</delay>
					There won't be any exceptions thrown even if you pass a value to skip that is greater than the length of the array.
					<delay>2</delay>
					You will simply get no output in such a case.

					<delay>2</delay>
					If you are not using Java-8, I don't see any challenge.
					<delay>2</delay>
					Just loop through index 3 to n and print the elements.

					<delay>2</delay>
				</li>
				<li>
					
					check the following code snippet
  //its three because you want to display last three elements.Note it should be less than array length<break/>    int pointer=3;<break/>    int[] inputArray= {1,2,3,4,5};<break/>    for(int i=inputArray.length-pointer;i&lt;inputArray.length;i++){<break/>        System.out.println(inputArray[i]);<break/>    }<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ printing elements ^ nth index onward ^ array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- deleted deleted deleted -->
			^ deleted deleted deleted 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Your getContacts AsyncTask runs in another thread (asynchronously as the etymology suggests).
					<delay>2</delay>
					Your list is updated after that thread finishes, but your Logging happens in parallel with the AsyncTask so at the time you log the size, the list does contain nothing.
					<delay>2</delay>
					Later when the AsyncTask finishes that's when you see things displayed in the list.

					<delay>2</delay>
					Heres a visualization

					<delay>2</delay>
					Thread:
					<delay>2</delay>
					UI -----------------------------------------------------------
					<delay>2</delay>
					ASYNCTASK
...............
					<delay>2</delay>
					| .. ArrayList mNewList = new ...;
...............
					<delay>2</delay>
					| .. mNewList = mListData.getContacts();
...............
					<delay>2</delay>
					| ..
					<delay>2</delay>
					AsyncTask::onBeforeExecute
					<delay>2</delay>
					()
...............
					<delay>2</delay>
					| ..............................................................................
					<delay>2</delay>
					| ..
					<delay>2</delay>
					AsyncTask::doInBackground starts
...............
					<delay>2</delay>
					| .. Log.i(mNewList.size());
					<delay>2</delay>
					.................................... | .. ( still working )
...............
					<delay>2</delay>
					| ..............................................................................
					<delay>2</delay>
					| ..
					<delay>2</delay>
					AsyncTask::doInBackground returns
...............
					<delay>2</delay>
					| ..
					<delay>2</delay>
					AsyncTask::onPostExecute
...............
					<delay>2</delay>
					| .. mContacts.add(...) ...
...............
					<delay>2</delay>
					| ...

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ deleted deleted deleted </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Last removed element from an Array/List in Java? -->
			^ last removed element ^ array ^ list ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Most likely this is what they had in mind.

					<delay>2</delay>
					List&lt;String&gt; words = ...<break/>String word = words.remove(0);<break/>

					<delay>2</delay>
					The method remove(int) return the object removed from the list.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ last removed element ^ array ^ list ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to add an Object into a certain x,y position in a 2D array of Objects -->
			^ add ^ object ^ certain x ^ position ^ 2d array ^ objects 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Try using
array[row][col] = object<break/>
Hope this helps!

					<delay>2</delay>
				</li>
				<li>
					
					`
import java.util.*;<break/>class a_class{<break/>    private int i;<break/>    public a_class(int k){<break/>        i=k;<break/>    }<break/>    public void print(){<break/>        System.out.print(i+"\t");<break/>    }<break/>}<break/>class Stack_help{<break/>    public static void main(String []args){<break/>        a_class [][]a=new a_class[4][4];//creating a new array of 2d objects<break/>        for(int i=0;i&lt;4;i++){<break/>            for(int j=0;j&lt;4;j++){<break/>                a[i][j] = new a_class(i);<break/>                a[i][j].print();<break/>            }<break/>            System.out.println("\n");<break/>        }<break/>    }<break/>}<break/>
`
Probably what you are asking just run this code
					<delay>2</delay>
					you will get your answer

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ add ^ object ^ certain x ^ position ^ 2d array ^ objects </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Can I store string in object array by using this string as index? -->
			^ store string ^ string ^ object array ^ using ^ index 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					No you cannot.
					<delay>2</delay>
					Array index must be integer. 

					<delay>2</delay>
					And if you want to pair them up, look at Map, where you can use String as a key and value Map&lt;String,String&gt;.
Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();<break/>map.put("ab","ab"); //adding key-value;<break/>String value map.get("ab"); //gives you "ab"<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ store string ^ string ^ object array ^ using ^ index </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to delete a line from a textfile using java? -->
			^ delete ^ line ^ textfile using java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Here's a working code, assuming you are using Java >= 7:
public static void removeLine(String ans, String file) throws IOException {<break/>    boolean foundLine = false;<break/>    try (BufferedReader br = Files.newBufferedReader(Paths.get(file));<break/>            BufferedWriter bw = Files.newBufferedWriter(Paths.get(file + ".tmp"))) {<break/>        String line;<break/>        while ((line = br.readLine()) != null) {<break/>            String[] tokens = line.split("::", 2);<break/>            if (tokens[0].equals(ans)) {<break/>                foundLine = true;<break/>            } else {<break/>                if (foundLine) {<break/>                    bw.write((Integer.parseInt(tokens[0]) - 1) + "::" + tokens[1]);<break/>                } else {<break/>                    bw.write(line);<break/>                }<break/>                bw.newLine();<break/>            }<break/>        }<break/>    }<break/>    Files.move(Paths.get(file + ".tmp"), Paths.get(file), StandardCopyOption.REPLACE_EXISTING);<break/>}<break/>

					<delay>2</delay>
					It is not possible to delete a line from a file.
					<delay>2</delay>
					What you need to do is read the existing file, write the contents you want to keep to a temporary file and then rename the temporary file to overwrite the input file.

					<delay>2</delay>
					Here, the temporary file is created in the same directory as the input file, with the extension .tmp added (note that you can also use Files.createTempFile for this).

					<delay>2</delay>
					For each line that is read, we check if this is the line the user wants to delete.

					<delay>2</delay>
					If it is, we update a boolean variable telling us that we just hit the line to be deleted and we do not copy this line to the temporary file.

					<delay>2</delay>
					If it is not, we have a choice:

					<delay>2</delay>
					Either we did not yet hit the line to be deleted.
					<delay>2</delay>
					Then we simply copy what we read to the temporary file

					<delay>2</delay>
					Or we did
					<delay>2</delay>
					and we need to decrement the first number and copy the rest of the line to the temporary file.

					<delay>2</delay>
					The current line is splitted with the help of String.split(regex, limit) (it splits the line only two times, thereby creating an array of 2 Strings: first part is the number, second part is the rest of the line).

					<delay>2</delay>
					Finally, the temporary file overwrites the input file with Files.move (we need to use the REPLACE_EXISTING option).

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ delete ^ line ^ textfile using java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- how to adjust line number in textfile using java? -->
			^ adjust line number ^ textfile using java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Your code looks good so far.

					<delay>2</delay>
					I suggest you do what you are trying to achieve: you basically renumber each line.

					<delay>2</delay>
					You should introduce a variable, set it to an initial number (1,
based on your example).

					<delay>2</delay>
					You use the new number when writing it out
to the file.

					<delay>2</delay>
					You increment the variable.

					<delay>2</delay>
					I am intentionally not posting the exact code for you to improve.
					<delay>2</delay>
					Comment if you need more help.

					<delay>2</delay>
				</li>
				<li>
					
					private static void filterSpecifiedLine(String skipLine) throws IOException {<break/>        List&lt;String[]&gt; lines = Files.lines(Paths.get("./Phonebook.txt"))<break/>                .map(l -&gt; l.split("::"))<break/>                .filter(s -&gt; !s[0].equals(skipLine))<break/>                .map(s -&gt; Arrays.copyOfRange(s, 1, s.length))<break/>                .collect(Collectors.toList());<break/>        List&lt;String&gt; generated = IntStream.range(0, lines.size())<break/>                .mapToObj(i -&gt; (i + 1) + "::" + String.join("::", lines.get(i)))<break/>                .collect(Collectors.toList());<break/>        Files.write(Paths.get("./Phonebook1.txt"), generated);<break/>}<break/>
I have used Stream to come true a simplify version.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ adjust line number ^ textfile using java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- to create rows and columns -->
			^ create rows ^ columns 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Since you cannot use array and cannot create any new method.
					<delay>2</delay>
					You can do something like this:
Output:
 O  .  .  .  . <break/> .  .  .  .  . <break/> .  .  .  .  . <break/> .  .  .  .  . <break/> .  .  .  .  E <break/>
Codes:
    int playerX=0, playerY=0;  //holds player's location<break/>    int exitX = 4, exitY = 4;  //holds exit's location<break/>    //Print map<break/>    for(int x=0; x&lt;5; x++){<break/>        for(int y=0; y&lt;5; y++)<break/>            if(x == playerX &amp;&amp; y == playerY)<break/>                System.out.print(" O "); //print player location<break/>            else if(x == exitX &amp;&amp; y == exitY)<break/>                System.out.print(" E ");<break/>            else    <break/>                System.out.print(" . ");<break/>        System.out.println("");     <break/>    }<break/>    /*<break/>    //Update player's position on movement<break/>    if (movement == DOWN)<break/>        playerY = Math.min(playerY+1 , 5);<break/>    else if (movement == UP)<break/>        playerY = Math.max(playerY-1 , 0);<break/>    else if (movement == LEFT)<break/>        playerX = Math.max(playerX-1 , 0);<break/>    else else if (movement == RIGHT)<break/>        playerX = Math.max(playerY+1 , 5);  <break/>    */<break/>

					<delay>2</delay>
					You can enclose every thing in a while loop, and repeat the loop so long player's location is not same as exit's location.

					<delay>2</delay>
				</li>
				<li>
					
					Since this is home work I am not going to give an answer but rather a hint.

					<delay>2</delay>
					Draw the 5x5 maze you want on paper or whatever.
					<delay>2</delay>
					Now you have 25 points.
					<delay>2</delay>
					That is 25 conditions of x,y.
					<delay>2</delay>
					That is you can make 25 if else statements.
					<delay>2</delay>
					Loop through and test your if else chain for each move and rendering.

					<delay>2</delay>
					Yes that many conditions is tedious
					<delay>2</delay>
					but I'm sure the point of the assignment is test your ability to properly construct a chain of conditions
					<delay>2</delay>
					(you could also use a switch statement using strings for cords but probably not a good idea).

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ create rows ^ columns </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- What is the difference between an array of characters and a single linear array? -->
			^ difference ^ array ^ characters ^ single linear array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					An array of characters is just a linear array of char values.
					<delay>2</delay>
					An array can be anything, primitive or object; Object[], char[], Comparable[] and an array of a class named Car (Car[]) are all valid arrays.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ difference ^ array ^ characters ^ single linear array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Setting an array as an input parameter for a method -->
			^ setting ^ array ^ input parameter ^ method 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					public class FirstJavaClass {<break/>    public void method(double[] input) {<break/>        // ... do something amazing with it!<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ setting ^ array ^ input parameter ^ method </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- JAVA MissingFormatArgumentException: Printing an array that is passed in method parameters -->
			^ java missingformatargumentexception ^ printing ^ array ^ passed ^ method parameters 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					What did you expect the statement to do?

					<delay>2</delay>
					System.out.printf("(x,y): (%f,%f)");<break/>

					<delay>2</delay>
					You never gave any values.
					<delay>2</delay>
					Try actually giving some values for the %f markers:
System.out.printf("(x,y): (%f,%f)", this.x, this.y);<break/>

					<delay>2</delay>
					You should read the The Java™ Tutorials:
					<delay>2</delay>
					Formatting Numeric Print Output.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java missingformatargumentexception ^ printing ^ array ^ passed ^ method parameters </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- what is the similar ways in Java ArrayList of vector v(100) -->
			^ similar ways ^ java arraylist ^ vector v ^ 100 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					When you instantiate an ArrayList, you can specify the initial capacity, but that doesn't populate the ArrayList.

					<delay>2</delay>
					You can use some short cuts with arrays.

					<delay>2</delay>
					For example, you can create an ArrayList of 100 null references with :
List&lt;Integer&gt; list = new ArrayList&lt;&gt; (Arrays.asList(new Integer[100]));<break/>

					<delay>2</delay>
				</li>
				<li>
					
					By using the constructor ArrayList(int initialCapacity), which sets the initial size of the backing array to initialSize.

					<delay>2</delay>
					Note that this does not actually give you initialSize values in the ArrayList, it just sets the size of the backing array.
					<delay>2</delay>
					If you need to set some initial values, you need to do something like
new ArrayList&lt;Integer&gt;(Collections.nCopies(100, 0));

					<delay>2</delay>
				</li>
				<li>
					
					Constructor defined in ArrayList can be used and initial capacity can be set to 100.
					<delay>2</delay>
					It also avoids resizing of list until threshold is reached.

					<delay>2</delay>
					List&lt;Integer&gt; arr = Arrays.asList(new Integer[10]);<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ similar ways ^ java arraylist ^ vector v ^ 100 </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Using linear search to check? -->
			^ using linear search ^ check 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Assuming you're ultimately just trying to get a list of words that are in both files:
Scanner fileReader = new Scanner(file);<break/>Set&lt;String&gt; words = new HashSet&lt;&gt;();<break/>while (fileReader.hasNext()) {<break/>  String s = fileReader.next();<break/>  words.add(s);<break/>}<break/>fileReader.close();<break/>Scanner otherFileReader = new Scanner(otherFile);<break/>List&lt;String&gt; wordsInBothFiles = new ArrayList&lt;&gt;();<break/>while (otherFileReader.hasNext()) {<break/>  String s = otherFileReader.next();<break/>  if (words.contains(s)) {<break/>    wordsInBothFiles.add(s);<break/>  }<break/>}<break/>otherFileReader.close();<break/>// Do whatever it is you have to do with the shared words, like printing them:<break/>// for (String s : wordsInBothFiles) {<break/>//   System.out.println(s);<break/>// }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you check the documentation it will usually explain why a method throws an exception.
					<delay>2</delay>
					In this case "no line was found" means you've hit the end of your file.
					<delay>2</delay>
					There are two possible ways this error could come about:
String nextLine = scanner.nextLine(); //problem 1: reads a file with no lines<break/>while (scanner.hasNextLine()) {<break/>   linearSearch(words,nextLine);<break/>   System.out.println(nextLine);<break/>} <break/>scanner.nextLine(); //problem 2: reads after there is not next line<break/>
Since you loop appears to be infinite
					<delay>2</delay>
					I'd wager you're getting the exception from the first line and can fix it by adding the following check before String nextLine = scanner.nextLine();:
if(!scanner.hasNextLine()) {<break/>    System.out.println("empty file: "+filePath)<break/>    return; //or break or otherwise terminate<break/>}<break/>
Beyond that you may still have some other issues
					<delay>2</delay>
					but hopefully this resolves your present problem.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ using linear search ^ check </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- I'm trying to create an arrayList that could accept both integers and array -->
			^ trying ^ create ^ arraylist ^ could accept ^ integers ^ array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Well, the fastest way might be create an auxiliar object that is composed by boths Integers and array letting you to use boths by equal

					<delay>2</delay>
				</li>
				<li>
					
					Both int (Integer wrapper) and array's common base class is Object.
					<delay>2</delay>
					So create ArrayList using Object type. 

					<delay>2</delay>
					ArrayList&lt;Object&gt; list= new ArrayList&lt;Object&gt;();<break/>

					<delay>2</delay>
					But this is not the right way to solve this problem and there is no use of Generics here to make run-time safety.
					<delay>2</delay>
					So, re-design your program and allocate each type in seperate list or use any other appropriate Collection type.

					<delay>2</delay>
				</li>
				<li>
					
					Use a class which has an int and an array as its instance variables.
					<delay>2</delay>
					Then create an ArrayList like
import java.util.ArrayList;<break/>public class Hello {<break/>    public static void main(String[]args) {<break/>        ArrayList&lt;Intarray&gt; myArrayList = new ArrayList&lt;Intarray&gt;();<break/>        int[] arr = {3,4,5};<break/>        myArrayList.add(new Intarray(2,arr));<break/>    }<break/>}<break/>class Intarray {<break/>    private int numbers;<break/>    private int[] myArray;<break/>    public Intarray(int numbers, int[] myArray){<break/>        this.numbers = numbers;<break/>        this.myArray = myArray;<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Create the array list at the Generalization level for all the objects you need in the List.
					<delay>2</delay>
					In this case,i.e for int and array, it is java.lang.Object.

					<delay>2</delay>
					Here's a small test I ran:
public static void main(String[] args) {<break/>    List&lt;Object&gt; both = new ArrayList&lt;Object&gt;();<break/>    both.add(1);<break/>    both.add(args);<break/>    System.out.println(both);<break/>}<break/>
Produces:
[1, [Ljava.lang.
					<delay>2</delay>
					String;@1db9742]

					<delay>2</delay>
				</li>
				<li>
					
					As @AbtPst suggested, the most suitable solution would be to have a list of lists.
					<delay>2</delay>
					This can be done in many different ways.
					<delay>2</delay>
					Personally, I'd create a class with two constructors.

					<delay>2</delay>
					class NumericElement<break/>{<break/>    private ArrayList&lt;int&gt; elements;<break/>    public NumericElement(int newElement)<break/>    {<break/>        elements = new ArrayList&lt;int&gt;();<break/>        elements.add(newElement);<break/>    }<break/>    public NumericElement(ArrayList&lt;int&gt; newElements)<break/>    {<break/>        elements = new ArrayList&lt;int&gt;(newElements); // copying array elements to the new array.<break/>    }<break/>    public ArrayList&lt;int&gt; getElements()<break/>    {<break/>        return elements;<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can define a List class with a type-safe interface, hiding an unsafe List&lt;Object&gt; as an internal implementation detail.

					<delay>2</delay>
					This is more work than just using a List&lt;Object&gt; directly.
					<delay>2</delay>
					If your list is used only by one class, just use a List&lt;Object&gt;, as an implementation detail of that one class.
					<delay>2</delay>
					But if your list is exposed to access by more than just one class, consider using this type-safe approach.

					<delay>2</delay>
					First, define an interface that can represent either an int or a array of ints. 

					<delay>2</delay>
					public interface IScalarOrArrayInt { }<break/>
And define a sub-interface for each possible element type:

					<delay>2</delay>
					public interface IScalarInt extends IScalarOrArrayInt { <break/>    public int getScalarInt();<break/>}<break/>public interface IArrayInt extends IScalarOrArrayInt {<break/>    public int[] getIntArray();<break/>}<break/>
Then define your list class and its representation.
					<delay>2</delay>
					It's interface can be a List&lt;IScalarOrArrayInt&gt;.
					<delay>2</delay>
					The representation can be a List&lt;Object&gt;, so that you can put Integer and int
					<delay>2</delay>
					[] objects into it directly, without wrapper objects.

					<delay>2</delay>
					public class ListOfScalarsAndArray extends AbstractList&lt;IScalarOrArrayInt&gt; {<break/>    private static List&lt;Object&gt; m_list = new ArrayList&lt;Object&gt;();<break/>
As noted in the List0 documentation, you'll want to define several methods to allow modifying your list.
					<delay>2</delay>
					You can delegate them to the internal list, but wrap the return values.

					<delay>2</delay>
					List1

					<delay>2</delay>
					For the convenience of callers, you can add some methods that accept an unwrapped List2 or List3.
					<delay>2</delay>
					For example: 
List4

					<delay>2</delay>
					To satisfy the standard List&lt;> interface, you can wrap return values.
					<delay>2</delay>
					Your class controls the internal list, so it alone controls the possible types of list members.

					<delay>2</delay>
					List5

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ trying ^ create ^ arraylist ^ could accept ^ integers ^ array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Finding intersection -->
			^ finding intersection 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					The variable intCount is local in the innermost if-condition, which means that only the first entry of interArr is accessed.
					<delay>2</delay>
					Rearrange the implementation as follows.

					<delay>2</delay>
					public int[] intersection(Set parSet)<break/>{<break/>    int[] interArr = new int[numbers.length];<break/>    int[] testArr = parSet.toArray();<break/>    int intCount = 0; // initialization out of the loop<break/>    for(int index = 0; index &lt; numbers.length; index++)<break/>    {<break/>        for(int compareInt = 0; compareInt &lt; testArr.length; compareInt++)<break/>        {<break/>            if(numbers[index] == testArr[compareInt])<break/>            {<break/>                interArr[intCount] = testArr[compareInt];<break/>                intCount++;<break/>            }//end if<break/>        }//end inner for<break/>    }//end outter for<break/>    return interArr;<break/>}//end method intersection<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You are on the right track: using a nested loop to do an exhaustive search (although it could be simplified using java collection), only some minor issues: 
1)
					<delay>2</delay>
					you didn't define toArray() method for your class, so assume you meant parSet.numbers when you call parSet.toArray()
2)
					<delay>2</delay>
					the counter intCount needs to be outside of the loop to avoid being set to 0 in every iteration. 

					<delay>2</delay>
					So the correct version should be:
public int[] intersection(Set parSet) {<break/>    int[] interArr = new int[numbers.length];<break/>    int[] testArr = parSet.numbers; //you didn't define toArray() for the class Set<break/>    int intCount = 0; // move this variable out of the loop<break/>    for (int index = 0; index &lt; numbers.length; index++) {<break/>        for (int compareInt = 0; compareInt &lt; testArr.length; compareInt++) {<break/>            if (numbers[index] == testArr[compareInt]) {<break/>                interArr[intCount] = testArr[compareInt];<break/>                intCount++;<break/>            }//end if<break/>        }//end inner for<break/>    }//end outter for<break/>    return interArr;<break/>}//end method intersection<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ finding intersection </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java.util.Arrays.sort - what type? -->
			^ java ^ util ^ arrays ^ sort ^ type 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					from java doc:
  Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch.
					<delay>2</delay>
					This
  algorithm offers O(n log(n))
					<delay>2</delay>
					performance on many data sets that cause
  other quicksorts to degrade to quadratic performance, and is typically
  faster than traditional (one-pivot) Quicksort implementations.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java ^ util ^ arrays ^ sort ^ type </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- I want to populate a single element in a 2D array randomly with a single char value? -->
			^ want ^ populate ^ single element ^ 2d array randomly ^ single char value 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Are you looking for something like this?

					<delay>2</delay>
					// Your array of Char with the length of 5 by 5<break/>char[][] arrayOfChar = new char[5][5];<break/>// Generating a radom number with min being 0 and max being length - 1<break/>Random rand = new Random();<break/>int x = rand.nextInt(arrayOfChar[0].length);<break/>int y = rand.nextInt(arrayOfChar[1].length);<break/>// Random position in array assigned M<break/>arrayOfChar[x][y] = 'M' ;<break/>

					<delay>2</delay>
					If you wanted an int array
// Your array of int with the length of 5 by 5<break/>int[][] arrayOfInt = new int[5][5];<break/>// Generating a radom number with min being 0 and max being length - 1<break/>Random rand = new Random();<break/>int x = rand.nextInt(arrayOfInt[0].length);<break/>int y = rand.nextInt(arrayOfInt[1].length);<break/>// Random position in array assigned number 8<break/>arrayOfInt[x][y] = 8 ;<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Maybe something like this?

					<delay>2</delay>
					public class random2DChar {<break/>    public static void main(String args[]) {<break/>        char[][] char2DArr = new char[10][10];<break/>        Random random = new Random();<break/>        int x = random.nextInt(char2DArr.length);<break/>        char2DArr[x][x] = 'M';<break/>        System.out.println(Arrays.deepToString(char2DArr));<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ want ^ populate ^ single element ^ 2d array randomly ^ single char value </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Allow arrayList to take in three columns of data from CSV -->
			^ allow arraylist ^ take ^ three columns ^ data ^ csv 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					What you can do is :
Skip the first row
					<delay>2</delay>
					if it has X Y Z.
Declare two more ArrayList to store Y and Z column. 

					<delay>2</delay>
					You can do it like this :
  public class FileParser  {<break/>    public ArrayList&lt;String&gt; parseFile(String fileName){<break/>    String csvFile = fileName;<break/>    BufferedReader br = null;<break/>    String line = "";<break/>    final String DELIMITER = ",";<break/>    ArrayList&lt;String&gt; dataX = new ArrayList&lt;String&gt;();<break/>    ArrayList&lt;String&gt; dataY = new ArrayList&lt;String&gt;();<break/>    ArrayList&lt;String&gt; dataZ = new ArrayList&lt;String&gt;();<break/>     try {<break/>         int counter = 0;<break/>         int N = 10;<break/>          br = new BufferedReader(new FileReader(csvFile));<break/>          while ((line = br.readLine()) != null &amp;&amp; counter &lt; N) {<break/>          if(counter &gt; 0){<break/>            String[] dataRow = line.split(DELIMITER);<break/>            dataX.add(dataRow[0]);<break/>            dataY.add(dataRow[1]);<break/>            dataZ.add(dataRow[2]);<break/>        }<break/>        counter++;<break/>    }<break/>  } catch (FileNotFoundException e) {<break/>    e.printStackTrace();<break/> } catch (IOException e) {<break/>    e.printStackTrace();<break/> } finally {<break/>    if (br != null) {<break/>        try {<break/>            br.close();<break/>        } catch (IOException e) {<break/>            e.printStackTrace();<break/>        }<break/>    }<break/>}<break/> return data;<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Try this
   public class FileParser  {<break/> public static ArrayList&lt;String&gt; parseFile(String fileName){<break/>  String csvFile = fileName;<break/>  BufferedReader br = null;<break/> String line = "";<break/> final String DELIMITER = ",";<break/> ArrayList&lt;String&gt; data = new ArrayList&lt;String&gt;();<break/>try {<break/>    int counter = 0;<break/>    int N = 10;<break/>    br = new BufferedReader(new FileReader(csvFile));<break/>    while ((line = br.readLine()) != null &amp;&amp; counter &lt; N) {<break/>        if(counter &gt;= 0){<break/>            String dataRow = line;<break/>            data.add(dataRow);<break/>        }<break/>        counter++;<break/>    }<break/>    for (String string : data) {<break/>        string.split(DELIMITER);<break/>        System.out.println(string);<break/>    }<break/>} catch (FileNotFoundException e) {<break/>    e.printStackTrace();<break/>} catch (IOException e) {<break/>    e.printStackTrace();<break/>} finally {<break/>    if (br != null) {<break/>        try {<break/>            br.close();<break/>        } catch (IOException e) {<break/>            e.printStackTrace();<break/>        }<break/>    }<break/>}<break/>return data;<break/>
}
}

					<delay>2</delay>
				</li>
				<li>
					
					I guess better option would be to create a custom class with three variables x,y and z.
					<delay>2</delay>
					Then use this class object to store data.
					<delay>2</delay>
					Make implementation changes to overrided equals and hashCode methods as required.

					<delay>2</delay>
					    public final class CsvData{<break/>        private String x;<break/>        private String y;<break/>        private String z;<break/>        public CsvData(String x, String y, String z){<break/>            this.x = x;<break/>            this.y = y;<break/>            this.z = z;<break/>        }<break/>        //getters and setters<break/>        public boolean equals(Object o) {<break/>            if (o instanceof CsvData) {<break/>                CsvData node = (CsvData)o;<break/>                return (x.equals(node.x) &amp;&amp; y.equals(node.y) &amp;&amp; z.equals(node.z));<break/>            }<break/>            return false;<break/>        }<break/>        public int hashCode() {<break/>            return HashCodeBuilder.reflectionHashCode(this);<break/>        }<break/>    } <break/>public class FileParser  {<break/>public ArrayList&lt;CsvData&gt; parseFile(String fileName){<break/>    String csvFile = fileName;<break/>    BufferedReader br = null;<break/>    String line = "";<break/>    final String DELIMITER = ",";<break/>    ArrayList&lt;CsvData&gt; data = new ArrayList&lt;CsvData&gt;();<break/>    try {<break/>        int counter = 0;<break/>        int N = 10;<break/>        br = new BufferedReader(new FileReader(csvFile));<break/>        while ((line = br.readLine()) != null &amp;&amp; counter &lt; N) {<break/>                String[] dataRow = line.split(DELIMITER);<break/>                CsvData csvData = new CsvData(dataRow[0],dataRow[1],dataRow[2]);<break/>                data.add(csvData);<break/>             counter++;<break/>        }<break/>    } catch (FileNotFoundException e) {<break/>        e.printStackTrace();<break/>    } catch (IOException e) {<break/>        e.printStackTrace();<break/>    } finally {<break/>        if (br != null) {<break/>            try {<break/>                br.close();<break/>            } catch (IOException e) {<break/>                e.printStackTrace();<break/>            }<break/>        }<break/>    }<break/>    return data;<break/>  }<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ allow arraylist ^ take ^ three columns ^ data ^ csv </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Is there a way to see if certain integers are in certain places within an arraylist? -->
			^ way ^ see ^ certain integers ^ certain places within ^ arraylist 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Just compare the order and the array with a for-loop:
public boolean isArrayInOrder(int[] array, int... order) {<break/>    if(array.length == order.length) {<break/>        for(int i = 0; i &lt; array.length; ++i) {<break/>            if(array[i] != order[i]) return false;<break/>        }<break/>        return true;<break/>    }<break/>    return false;<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ way ^ see ^ certain integers ^ certain places within ^ arraylist </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Why Array in Java always need to fixed size? -->
			^ array ^ java always need ^ fixed size 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					An ArrayList is backed by an array, whose size is fixed, but the ArrayList class contains code that creates a larger array and copies the existing array to it when the existing array is full.

					<delay>2</delay>
					That's the difference between arrays and ArrayLists.

					<delay>2</delay>
				</li>
				<li>
					
					There is big difference between array and lists:
1) if we certainly know size of collection - this is array, we need no dynamicaly changing size.

					<delay>2</delay>
					2) if we don't know, how many elements will be in our collection - this is list, where size is not fixed.

					<delay>2</delay>
					In this answer "collection" doesn't means Collection class in Java, it's just a a bunch of some objects

					<delay>2</delay>
				</li>
				<li>
					
					
The main difference between Array and ArrayList in Java is that Array is a fixed length data structure while ArrayList is a variable length.
					<delay>2</delay>
					You can not change length of Array once create, but ArrayList can re-size itself.

					<delay>2</delay>
					Another difference between Array and ArrayList in Java, you can not store primitives in ArrayList, because it can only contain Objects.
					<delay>2</delay>
					Array can contain both primitives and Objects.

					<delay>2</delay>
					The Array is not a class, while ArrayList is an object with many methods.

					<delay>2</delay>
					The elements of the Array retrieved with for loop.
					<delay>2</delay>
					The elements of the ArrayList can be retrieved with for loop and iterators.

					<delay>2</delay>
					The Array cannot be synchronized, while ArrayList can be obtained a synchronized ver.

					<delay>2</delay>
					etc....

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ array ^ java always need ^ fixed size </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Sorting an array of integers in time complexity of o(n) or o(1) -->
			^ sorting ^ array ^ integers ^ time complexity ^ n ^ 1 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Use Radix Sort, which is O(n)
 public void radixsort(int[] input) {<break/>  final int RADIX = 10;<break/>  // declare and initialize bucket[]<break/>  List&lt;Integer&gt;[] bucket = new ArrayList[RADIX];<break/>  for (int i = 0; i &lt; bucket.length; i++) {<break/>    bucket[i] = new ArrayList&lt;Integer&gt;();<break/>  }<break/>  // sort<break/>  boolean maxLength = false;<break/>  int tmp = -1, placement = 1;<break/>  while (!maxLength) {<break/>    maxLength = true;<break/>    // split input between lists<break/>    for (Integer i : input) {<break/>      tmp = i / placement;<break/>      bucket[tmp % RADIX].add(i);<break/>      if (maxLength &amp;&amp; tmp &gt; 0) {<break/>        maxLength = false;<break/>      }<break/>    }<break/>    // empty lists into input array<break/>    int a = 0;<break/>    for (int b = 0; b &lt; RADIX; b++) {<break/>      for (Integer i : bucket[b]) {<break/>        input[a++] = i;<break/>      }<break/>      bucket[b].clear();<break/>    }<break/>    // move to next digit<break/>    placement *= RADIX;<break/>  }<break/>}<break/>
code Ref

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ sorting ^ array ^ integers ^ time complexity ^ n ^ 1 </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to implement a stack of integers in array in Java Collection Framework as a variable-size array? -->
			^ implement ^ stack ^ integers ^ array ^ java collection framework ^ variable ^ size array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					If stack of Integer boxed objects suites for you then you can just use java.util.Stack implementation from Java Collections.

					<delay>2</delay>
					But if your requirement is to use only primitive types take a look at java.util.Stack implementation.
					<delay>2</delay>
					All you need to do to make it work with primitive integer is just replace type of base array and all method parameters and return values.
					<delay>2</delay>
					It's simple.

					<delay>2</delay>
					Third option is to use one of 3d party collection libraries, for example goldmnan sachs collections if I remember right.
					<delay>2</delay>
					They provide such solution already.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ implement ^ stack ^ integers ^ array ^ java collection framework ^ variable ^ size array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How can I create an array in Kotlin like in Java by just providing a size? -->
			^ create ^ array ^ kotlin like ^ java ^ providing ^ size 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					According to the reference, arrays are created in the following way:
For Java's primitive types there are distinct types IntArray, DoubleArray etc.
					<delay>2</delay>
					which store unboxed values.

					<delay>2</delay>
					They are created with the corresponding constructors and factory functions:
val arrayOfZeros = IntArray(size) //equivalent in Java: new int[size]<break/>val numbersFromOne = IntArray(size) { it + 1 }<break/>val myInts = intArrayOf(1, 1, 2, 3, 5, 8, 13, 21)<break/>

					<delay>2</delay>
					The first one is simillar to that in Java, it just creates a primitive array filled with the default value, e.g. zero for Int, false for Boolean.

					<delay>2</delay>
					Non primitive-arrays are represented by Array&lt;T&gt; class, where T is the items type.

					<delay>2</delay>
					T can still be one of types primitive in Java (IntArray0, IntArray1,...), but the values inside will be boxed equivalently to Java's IntArray2, IntArray3 and so on.

					<delay>2</delay>
					Also, IntArray4 can be both nullable and non-null like IntArray5 and IntArray6.

					<delay>2</delay>
					These are created in a similar way:
IntArray7

					<delay>2</delay>
				</li>
				<li>
					
					In Kotlin, creating an IntArray of size N is simple.
					<delay>2</delay>
					Use IntArray(n) or the appropriate type, as detailed thoroughly in hotkey's answer.

					<delay>2</delay>
					When utilizing your fixed size array, you can use Kotlin Destructuring
// Create fixed sized array<break/>val point = IntArray(2)<break/>// Access values directly<break/>val (x, y) = point<break/>

					<delay>2</delay>
					In this case, x will be taken from index 0, y from index 1, etc.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ create ^ array ^ kotlin like ^ java ^ providing ^ size </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Create BigInteger Array from int Array -->
			^ create biginteger array ^ int array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					There is no way to accomplish this without iteration under Java-8 (and why does that matter, does the performance hinder your runtime by so much?
					<delay>2</delay>
					Is this the bottleneck of your application?
					<delay>2</delay>
					You must know that the iteration "cost" will take its toll from your application no matter if you use it directly or not).     

					<delay>2</delay>
					Anyway, for the sake of completeness and to make this answer more useful, this is how you might do that:
for (int i = 0; i &lt; arr.length ; i++)<break/>    bigIntegerArray[i] = BigInteger.valueOf(arr[i]);<break/>

					<delay>2</delay>
					And if you decide you want to convert your int array to a single BigInteger, there is the constructor public BigInteger(byte[] val) that:
  
					<delay>2</delay>
					Translates a byte array containing the two's-complement binary representation of a BigInteger into a BigInteger.
					<delay>2</delay>
					The input array is assumed to be in big-endian byte-order: the most significant byte is in the zeroth element.

					<delay>2</delay>
					(And as you probably know int can be represented as 4 bytes)

					<delay>2</delay>
				</li>
				<li>
					
					This should do the job if you're using java-8
int[] ints = new int[]{1,2,3};<break/>System.out.println(Arrays.toString(ints)); // [1, 2, 3]<break/>BigInteger[] bigs = Arrays.stream(ints)<break/>                          .mapToObj(BigInteger::valueOf)<break/>                          .toArray(BigInteger[]::new);<break/>System.out.println(Arrays.toString(bigs)); // [1, 2, 3]<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ create biginteger array ^ int array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to sort an Array of Points by MergeSort in Java? -->
			^ sort ^ array ^ points ^ mergesort ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Assuming you are talking about 2D or 3D points, you would have to think about defining a metric such that they are orderable. 

					<delay>2</delay>
					Consider the exampe points (1,0) and (0,1) in 2D space.
					<delay>2</delay>
					Is (1,0) &gt; (0,1) ? Or (1,0) &lt; (0,1) ?
					<delay>2</delay>
					It really depends on the application.

					<delay>2</delay>
					You could e.g. take just the first component as metric, then it would be (1,0) &gt; (0,1).
					<delay>2</delay>
					Or you could take the distance from a specific point, e.g. the origin (0,0), in which case they would be equal.

					<delay>2</delay>
					Anyways, after you have decided on that, you can look up existing implementations of sorting algorithms (you seem to be determined about MergeSort though), on the internet.
					<delay>2</delay>
					Here is one example.

					<delay>2</delay>
					Most interfaces to sort function in various programming languages require either a key function (e.g. "get first component" or "distance from origin"), or a custom comparison operator.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ sort ^ array ^ points ^ mergesort ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- how to create a method that uses 2D array in java -->
			^ create ^ method ^ uses 2d array ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					2D arrays can be declared like int[][] matrix = new int[10][10];
					<delay>2</delay>
					If you need 2D array with different number of values in rows, than you have to create each row by yourself:
int [][] matrix = new int[10][];<break/>matrix[0] = new int[10];<break/>matrix[1] = new int[20];<break/>//...<break/>

					<delay>2</delay>
					To iterate over matrix you need
for (int[] row : matrix) {<break/>    for (int value : row) {<break/>        sum += value;<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					   //method to count your number of Occurrences in Your 2-D Array.    <break/>private int getAllOccurence(int [] arr, int yourNumberToSearch){ <break/> int count = 0;<break/>for (int[] row : arr) {      //loop will able to get all Rows<break/>    for (int value : row) {      //loop enables you to get each values of each Row.<break/>       // This if Statement will check wheather Your Number exists in array or not<break/>        if(value == yourNumberToSearch) <break/>              count++; //count increase each times by one If Number exists in a array.<break/>    }<break/>  }<break/>  return count;<break/>}<break/>
  Here
					<delay>2</delay>
					You may try this.
					<delay>2</delay>
					You will get Your Answer.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ create ^ method ^ uses 2d array ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How do I convert a byte to an array of eight booleans -->
			^ convert ^ byte ^ array ^ eight booleans 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Try using BitSet to get the representation of the byte number...

					<delay>2</delay>
					Example:
independently of the signed or not....
public static void main(String[] args) {<break/>    byte b1 = (byte) 129;<break/>    BitSet bits = BitSet.valueOf(new byte[]{b1});<break/>    System.out.println(bits); //<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ convert ^ byte ^ array ^ eight booleans </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Whats wrong with the following code -->
			^ whats wrong ^ following code 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Strings are immutable so you can't change them, and you shouldn't expect this to do anything.

					<delay>2</delay>
					What you might have intended is
String s = "fecbda"; <break/>char[] chars = s.toCharArray();<break/>Arrays.sort(chars); <break/>String s2 = new String(chars);<break/>System.out.println(s2);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					It does not work as s.toCharArray():
  Returns:
      a newly allocated character array whose length is the length of this string and whose contents are initialized to contain the character sequence represented by this string.

					<delay>2</delay>
					The operative part of the documentation is that it creates a new array (i.e. a copy of the characters in the string) and when you sort that array you do not sort the String.

					<delay>2</delay>
					You cannot sort the string as it is immutable but you can make a new string out of the sorted character array like this:

					<delay>2</delay>
					String s = "fecbda";<break/>char[] c = s.toCharArray();<break/>Array.sort( c );<break/>String n = new String( c );<break/>

					<delay>2</delay>
					As an alternative method, you can do it in Java 8 using streams:
String s = "fecbda";<break/>String n = s.chars()  // Convert to an IntStream of character codes<break/>            .sorted() // Sort<break/>            .mapToObj(i -&gt; Character.toString((char) i)) // Convert to strings<break/>            .collect(Collectors.joining()); // Concatenate the strings.<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ whats wrong ^ following code </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to create 2d Array containing 2d Arraylist? (JAVA) -->
			^ create 2d array containing 2d arraylist ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You should use:
List&lt;List&lt;String&gt;&gt; example = new ArrayList&lt;List&lt;String&gt;&gt;();<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ create 2d array containing 2d arraylist ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- What array types CANNOT be supplied for T when constructing an ArrayList collection? -->
			^ array types cannot ^ supplied ^ constructing ^ arraylist collection 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					All array types are subclasses of Object so you can use any array type in a generic which extends Object as T does by default, even arrays of primitive.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ array types cannot ^ supplied ^ constructing ^ arraylist collection </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to declare a call a 2d array in java? -->
			^ declare ^ call ^ 2d array ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					int [][] arr = new int[height][width];<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ declare ^ call ^ 2d array ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- I have a text and i have to store it in Array then get all punctuations out and the printed text should be in lowCase. I am new in Java -->
			^ text ^ store ^ array ^ get ^ punctuations ^ printed text ^ lowcase ^ new ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Google the items below and apply them on your code.

					<delay>2</delay>
					Java String lowercase

					<delay>2</delay>
					Java String remove punctuations

					<delay>2</delay>
				</li>
				<li>
					
					public static char[]
					<delay>2</delay>
					normalisieren(char[] text) throws IOException {
    BufferedReader keyboard = new BufferedReader(new <break/>
FileReader("c:/readIt.txt"));
    String texte;<break/>     ArrayList&lt;String&gt; reText = new ArrayList&lt;String&gt;();<break/>        while((texte = keyboard.readLine()) != null){<break/>            reText.add(texte);<break/>        }<break/>        String[] stringArr = reText.toArray(new String[0]);<break/>        for(int i = 0; i &lt; stringArr.length; i++){<break/>      //  System.out.println(stringArr[i]);<break/>        String str = stringArr[i].toLowerCase();<break/>        System.out.println(str);<break/>        }<break/>        return text;<break/>}<break/>public static void main(String[] args) throws IOException {<break/>    normalisieren(null);<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ text ^ store ^ array ^ get ^ punctuations ^ printed text ^ lowcase ^ new ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Check for Winner Tic Tac Toe game Java -->
			^ check ^ winner tic tac toe game java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You are not checking if the "computer" won, if the computer didnt won, and player either, then you can turn the tieGame flag true

					<delay>2</delay>
				</li>
				<li>
					
					The problem is this expression in the if statement:
GameBoard[0][0] == player &amp;&amp; GameBoard[0][1] == player &amp;&amp; GameBoard[0][2] == player &amp;&amp;<break/>                    GameBoard[1][0] == player &amp;&amp; GameBoard[1][1] == player &amp;&amp; GameBoard[1][2] == player &amp;&amp;<break/>                    GameBoard[2][0] == player &amp;&amp; GameBoard[2][1] == player &amp;&amp; GameBoard[2][2] == player<break/>

					<delay>2</delay>
					You're checking to see if the player is in every board position.

					<delay>2</delay>
					You want to determine that there wasn't a winner.  
					<delay>2</delay>
					That means checking that none of the the rows, columns and diagonals have the same player.

					<delay>2</delay>
				</li>
				<li>
					
					Change GameBoard[0][0] == player to GameBoard[0][0] != 0 for all 9 conditions.

					<delay>2</delay>
				</li>
				<li>
					
					The error is in the main code/structure of the function.
					<delay>2</delay>
					Your function needs to return two variables, finalwinner and tie game.
					<delay>2</delay>
					Right now your function stops at the first return statement, and sets that equal to finalwinner in the main.

					<delay>2</delay>
					Try something like this:
public static boolean[] CheckForWinner(int player)<break/>        {<break/>            //Row and Column Check<break/>            if (GameBoard[0][0] == player &amp;&amp; GameBoard[0][1] == player &amp;&amp; GameBoard[0][2] == player ||<break/>                GameBoard[1][0] == player &amp;&amp; GameBoard[1][1] == player &amp;&amp; GameBoard[1][2] == player ||<break/>                GameBoard[2][0] == player &amp;&amp; GameBoard[2][1] == player &amp;&amp; GameBoard[2][2] == player ||<break/>                GameBoard[0][0] == player &amp;&amp; GameBoard[1][0] == player &amp;&amp; GameBoard[2][0] == player ||<break/>                GameBoard[0][1] == player &amp;&amp; GameBoard[1][1] == player &amp;&amp; GameBoard[2][1] == player ||<break/>                GameBoard[0][2] == player &amp;&amp; GameBoard[1][2] == player &amp;&amp; GameBoard[2][2] == player)<break/>                {<break/>                    boolean finalwinner=true;<break/>                }<break/>            //diagonal checks<break/>            if (GameBoard[0][0]==player &amp;&amp; GameBoard[1][1]==player &amp;&amp; GameBoard[2][2]==player)<break/>            {<break/>                boolean finalwinner=true;<break/>            }<break/>            if (GameBoard[2][0]==player &amp;&amp; GameBoard[1][1]==player &amp;&amp; GameBoard[0][2]==player)<break/>            {<break/>                boolean finalwinner=true;<break/>            }<break/>            //Tie Game Check<break/>            if (GameBoard[0][0] == player &amp;&amp; GameBoard[0][1] == player &amp;&amp; GameBoard[0][2] == player &amp;&amp;<break/>                GameBoard[1][0] == player &amp;&amp; GameBoard[1][1] == player &amp;&amp; GameBoard[1][2] == player &amp;&amp;<break/>                GameBoard[2][0] == player &amp;&amp; GameBoard[2][1] == player &amp;&amp; GameBoard[2][2] == player)<break/>                {<break/>                boolean tieGame=true;<break/>            }<break/>            return new boolean [] {finalwinner, tiegame};<break/>        }<break/>public static void main (String[] args)<break/>                {<break/>                System.out.println("Tic Tac Toe Game");<break/>                System.out.println("Player 1 is 1, Computer is 2");<break/>            Draw();<break/>            currentplayer=1;<break/>            while (winner!= true)<break/>            {<break/>                if(currentplayer==1)<break/>                    {<break/>                        System.out.println("Your Turn");<break/>                        Player1Turn(currentplayer);<break/>                    }<break/>                else<break/>                    ComputerTurn(currentplayer);<break/>                boolean result[] = CheckForWinner(currentplayer);<break/>                if(result[0]==true &amp;&amp; result[1]==false)<break/>                {<break/>                    System.out.println("Winner is Player" +currentplayer+ "Congrats Champion!");<break/>                    System.out.println("Beginning New Game! Press Cancel then Enter to Exit");<break/>                    Reset();<break/>                }<break/>                if(result[1]==true)<break/>                {<break/>                    System.out.println("It's a Tie! Play Again.");<break/>                    System.out.println("Beginning New Game! Press Cancel then Enter to Exit");<break/>                    Reset();<break/>                }<break/>                if(currentplayer==1)<break/>                    currentplayer=2;<break/>                else if(currentplayer==2)<break/>                    currentplayer=1;<break/>            }<break/>            }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					EDIT: Info on enums

					<delay>2</delay>
					This is probably not what you'd prefer, but I strongly suggest you go for a different move/board representation:

					<delay>2</delay>
					HOW
Firstly, I suggest you implement your board cells as enums (since there are only 9 of them).

					<delay>2</delay>
					Then, implement the board as a set of 9 enums, as such:
public enum Move {<break/>A0, A1, A2, B0, B1, B2, C0, C1, C2; }<break/>
Also, implement winning patterns (e.g. a whole line, a whole diagonal) as sets of 3 enums (i.e. a subset of the board set).

					<delay>2</delay>
					After these changes, it gets a lot easier to check whether a player (be it you or computer) has won.

					<delay>2</delay>
					I recommend you add the subsets and the method that checks if a player has won inside the Move class as well. 

					<delay>2</delay>
					A subset can be created like this:
e.g.
static private final EnumSet&lt;Move&gt; lineA = EnumSet.of(A0,A1,A2);<break/>

					<delay>2</delay>
					And a check from your won method (note you need to check for all subsets) could possibly be:

					<delay>2</delay>
					moves.containsAll(lineA)<break/>
where moves is the set of moves made by player (when a player makes a move you add the enum to
					<delay>2</delay>
					it's moves set).

					<delay>2</delay>
					WHY

					<delay>2</delay>
					This design is more concise, straightforward and elegant.
					<delay>2</delay>
					You should not experience the problems you described any longer, if you use this approach.

					<delay>2</delay>
				</li>
				<li>
					
					First of all, in your main method you say finalwinner=CheckForWinner(currentplayer);
					<delay>2</delay>
					so you don't have to set finalwinner=true; every time after checking row, column and diagonal.
					<delay>2</delay>
					return true; is enough.

					<delay>2</delay>
					Your problem is, you check for a Tie Game and if it is the case, you also return true, but it is wrong, because neither player nor computer wins!
					<delay>2</delay>
					So your checkForWinner method always returns true.

					<delay>2</delay>
					You don't really have to check extra for Tie Game.
					<delay>2</delay>
					Just check win for player, check win for computer, if both are false and last move done - its a tie game.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ check ^ winner tic tac toe game java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Efficient way to store an array of only 0s and 1s in Java -->
			^ efficient way ^ store ^ array ^ 0s ^ 1s ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					The answer is going to be different depending on whether you know the size of the array in advance, and how sparse or random the data is.

					<delay>2</delay>
					For starters, if you're looking for the most efficient storage, you're going to want to compress the data instead of storing the raw 0s and 1s.  
					<delay>2</delay>
					One
					<delay>2</delay>
					typically good compression algorithm is Huffman Coding, although it is not always the "best" particularly if the data is random.  
					<delay>2</delay>
					You can find an implementation here.

					<delay>2</delay>
					Going back to the original question and assuming you want to keep the raw values; the most efficient storage will depend on whether you know the size of the array in advance.
					<delay>2</delay>
					If it is a fixed size, you can create a number of byte primitives.  
					<delay>2</delay>
					Each of these would take exactly 1 byte, plus the overhead for the object in which they are stored.  
					<delay>2</delay>
					You could reduce the number of variables by using short, int, or long as needed to group 2, 4, or 8 bytes together.  
					<delay>2</delay>
					If you're including these variables as a member of a class with other variables, it may make a difference which type you use, as the object itself takes 8 bytes for overhead, and the size will always be a multiple of 8 bytes; so any variables short of that will be padded to a multiple 8-bytes. 
If you need an arbitrary size array (which incurs its own 12-byte overhead, 8 for the object and 4 for the array length) the answer would continue to be an array of byte[] with each of the 8 bits mapped to your 1's and 0's.   
					<delay>2</delay>
					However, the JVM allocates memory in 8-byte chunks so 1 to 4 bytes will take the the memory footprint of an int so a byte[] array will ultimately match the memory footprint of a short[], or int[]
					<delay>2</delay>
					and there's no real need to allocate an array in smaller sizes than 32 bits (as long as you ensure you use all the bits efficiently.  
					<delay>2</delay>
					A byte0 would always end up taking an extra 8 bytes over the other integer array types, due to the 12-byte object overhead and 16-byte allocation roundoff.

					<delay>2</delay>
					At the end of the day, however, readability/usability probably trumps memory usage.  
					<delay>2</delay>
					A byte1 stores values as byte2 under the hood and has friendlier access methods and is probably the best choice here to minimize (not exactly, but good enough for practical purposes) memory footprint.

					<delay>2</delay>
					A byte3 would likely be the fastest to deal with CPU wise but would take 8x the memory as a primitive integer type.

					<delay>2</delay>
				</li>
				<li>
					
					I hope you have gone through BitSet.
					<delay>2</delay>
					I think thats the efficient way of storing Bits. 

					<delay>2</delay>
					https://docs.oracle.com/javase/7/docs/api/java/util/BitSet.html

					<delay>2</delay>
					but you should treat 0 as false and 1 as true

					<delay>2</delay>
				</li>
				<li>
					
					I think the most most space efficient way to store a binary matrix, if you have most '0's then '1's, is using a sparse matrix.

					<delay>2</delay>
					In a sparse matrix you need represent only the '1' values using a crossed-list structure.

					<delay>2</delay>
					You can find some implementations on GitHub.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ efficient way ^ store ^ array ^ 0s ^ 1s ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Inventory Program Java Help Needed -->
			^ inventory program java help needed 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					This is the easiest method yet!
					<delay>2</delay>
					If you simply want to retireve the item by position, then ArrayList#get is your method.
					<delay>2</delay>
					Per the Oracle docs,
  Returns the element at the specified position in this list.

					<delay>2</delay>
					public StockItem getItem(int index) {<break/>    return this.stock.get(index);<break/>}<break/>

					<delay>2</delay>
					However, you have to add in the special case for the null return specified by your JavaDocs.
					<delay>2</delay>
					There are two ways to do this
First way

					<delay>2</delay>
					public StockItem getItem(int index) {<break/>    if (index &lt; 0 || index &gt;= this.stock.size()){<break/>        return null;<break/>    }<break/>    return this.stock.get(index);<break/>}<break/>
Second way

					<delay>2</delay>
					public StockItem getItem(int index) {<break/>    try{<break/>        return this.stock.get(index);<break/>    }catch(IndexOutOfBoundsException e){<break/>        return null;<break/>    }<break/>}<break/>

					<delay>2</delay>
					I'd suggest the first way because, although there is additional logic, using Exceptions as regular control flow in your code is not good practice.
					<delay>2</delay>
					See this and this for more discussion.

					<delay>2</delay>
				</li>
				<li>
					
					public StockItem getItem(int index) {<break/>     try<break/>     {<break/>         return stock.get(index)<break/>     }<break/>     catch(IndexOutOfBoundsException ex)<break/>     {<break/>         return null;<break/>     }<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ inventory program java help needed </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java print(); method with getters from a different class -->
			^ getters ^ different class 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					This is the important error message. 
  
					<delay>2</delay>
					Cannot make a static reference to the non-static method
  getStudentID(); from the type Student.

					<delay>2</delay>
					You need to call getStudentID() on an instance of the class, and not the class itself.
					<delay>2</delay>
					You can try something like this. 

					<delay>2</delay>
					public static void print_all() {<break/>    System.out.println("Student ID\tRecent Grades\tName\t\tE-Mail\t\t\tAge");<break/>    for (Student w : studentlist) {<break/>        System.out.print(w.getStudentID() + "\t\t");<break/>        System.out.print(w.getGrades() + "\t");<break/>        System.out.print(w.getFirstname()+ " ");<break/>        System.out.print(w.getLastname()+ "\t");<break/>        System.out.print(w.getEmail()+ "\t");<break/>        System.out.print(w.getAge()+ "\t");<break/>        System.out.println(" ");<break/>    }<break/>}<break/>

					<delay>2</delay>
					Calling Student.getStudentID() would only work if there was a static (shared) ID for all the students.
					<delay>2</delay>
					This is not the case here.
					<delay>2</delay>
					You can look at this post for a more complete explanation of the static keyword in java. 

					<delay>2</delay>
				</li>
				<li>
					
					The error says it all.
					<delay>2</delay>
					The method getStudentID() is a non-static method of the Student class.
					<delay>2</delay>
					The call Student.getStudentID() is a static call and hence the error.
					<delay>2</delay>
					Invoke the method getStudentID() on an instance of a Student.  

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ getters ^ different class </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Matrix : get value from given matrix -->
			^ matrix ^ get value ^ given matrix 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					To my understanding, the problem can be solved with the following helper function which calculates the indices of the next entry.
					<delay>2</delay>
					The syntax is C#, but should work similar in Java, where m and n are supposed to be the respective matrix dimensions.
					<delay>2</delay>
					The idea is to check whether the desired main direction is down-left or up-right; if the edge of the matrix is reached, which has to be checked beforehand, this is modified to right and down, respectively.
					<delay>2</delay>
					The implementation assumes zero-based indexing of the rows and columns.

					<delay>2</delay>
					public struct Cell<break/>{<break/>    public int Row;<break/>    public int Col;<break/>}<break/>public static Cell GetNext(Cell iCell)<break/>{<break/>    Cell Result;<break/>    if (( iCell.Row + iCell.Col ) % 2 == 0)<break/>    {<break/>        if (iCell.Col == n - 1)<break/>            Result = new Cell { Row = iCell.Row + 1, Col = n - 1 };<break/>        else if (iCell.Row == 0)                    <break/>            Result = new Cell { Row = 0, Col = iCell.Col + 1 };<break/>        else<break/>            Result = new Cell { Row = iCell.Row - 1, Col = iCell.Col + 1 };<break/>    }<break/>    else<break/>    {<break/>        if (iCell.Row == m - 1)<break/>            Result = new Cell { Row = m - 1, Col = iCell.Col + 1 };<break/>        else if (iCell.Col == 0)<break/>            Result = new Cell { Row = iCell.Row + 1, Col = 0 };<break/>        else<break/>            Result = new Cell { Row = iCell.Row + 1, Col = iCell.Col - 1 };<break/>    }<break/>    return Result;<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Personally, I like @Codor's approach more.
					<delay>2</delay>
					I thought I would throw this Java function in the mix too. 

					<delay>2</delay>
					[Note:
					<delay>2</delay>
					I have not compiled or run this.
					<delay>2</delay>
					But, I think it should work (mostly).
					<delay>2</delay>
					Let me know.
					<delay>2</delay>
					:)]
public static int[] getTraversedArray(int[][] arr) {<break/>     if (arr == null || arr.length == 0) <break/>        return null;<break/>    # matrix need not be `nxn`<break/>    int l = arr.length - 1, w = arr[0].length - 1;<break/>    # all indices need to be visited<break/>    int[] out = new int[(l + 1) * (w + 1)];<break/>    int indx = 0;<break/>    for (int i = 0; i &lt;= l + w; i++) {<break/>        # "even" index<break/>        if (i % 2 == 0) {<break/>            for (int x = i; x &gt;= 0; x--) {<break/>                # if it is a "valid index", set the value<break/>                # in the output array<break/>                if ((x &lt;= l) &amp;&amp; (i - x &lt;= w)) {<break/>                    out[indx] = arr[x][i - x];<break/>                    indx++;<break/>                }<break/>            }<break/>        } <break/>        # "odd" index<break/>        else {<break/>            for (int x = 0; x &lt;= i; x++) {<break/>                # if it is a "valid index", set the value<break/>                # in the output array<break/>                if ((x &lt;= l) &amp;&amp; (i - x &lt;= w)) {<break/>                    out[indx] = arr[x][i - x];<break/>                    indx++;<break/>                }<break/>            }<break/>        }<break/>    }<break/>    return out;<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ matrix ^ get value ^ given matrix </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Can rows have different column count? -->
			^ rows ^ different column count 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Yes, that is possible, here is example of iterating through them
public static void main(String[] args) {<break/>        int[][] numbers = new int[][] { { 1, 2, 3 }, { 1, 2, 3, 4 }, { 1, 2, 3, 4, 5 } };<break/>        for(int i = 0; i&lt;numbers.length;i++) {<break/>            for(int j = 0; j &lt; numbers[i].length; j++) {<break/>                System.out.print(numbers[i][j]);<break/>            }<break/>            System.out.println("");<break/>        }<break/>    }<break/>
output:
123<break/>1234<break/>12345<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Yes, you can have different column count for each row.

					<delay>2</delay>
					data_type [][] array = new data_type[row][]
array[0] = new data_type[size1]
array[1] = new data_type[size2]
P.S
					<delay>2</delay>
					: Why don't you try on your system, before asking such questions.

					<delay>2</delay>
					P.P.S : Here i have assumed that row &gt;=2.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ rows ^ different column count </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Size of the list does not match the ones it has -->
			^ size ^ list ^ match ^ ones 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					If you don't want the 'null' image to appear on a list, just do something like:
for each item on a list<break/>    if item == null then continue<break/>    else <break/>        add an item to &lt;List&gt;Images<break/>

					<delay>2</delay>
					If you pass a null object to the List of Images, it still does occupy the place in the list, even though this place is technically uninitialized.

					<delay>2</delay>
				</li>
				<li>
					
					you can't say null value means the object is not exist, even null isn't an object in java. 

					<delay>2</delay>
					String s = null means the reference of String s is unset, but the declare is done, an object with String type and called s.
see more detail about it, oracle doc: The Kinds of Types and Values
$
					<delay>2</delay>
					code_placeholder_5

					<delay>2</delay>
					so in you case, the return of size() should be 20.

					<delay>2</delay>
				</li>
				<li>
					
					I use the solution from @Lithium after some days researching
tourists.removeAll(Collections.singleton(null));

					<delay>2</delay>
					This code remove all null values from an list.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ size ^ list ^ match ^ ones </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Arraylist element index before and after Collections.shuffle in java -->
			^ arraylist element index ^ collections ^ shuffle ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					If you want to hold on to the original position of the object you need to make a copy of the arraylist before you shuffle it.  
					<delay>2</delay>
					And then use indexOf 

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ arraylist element index ^ collections ^ shuffle ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- In android studio how can i take input in EditText field as a number eg; 1452 and convert it into integer array{1,4,5,2} -->
			^ android studio ^ take input ^ edittext field ^ number eg ^ 1452 ^ convert ^ integer array ^ 1 ^ 4 ^ 5 ^ 2 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					well first do 
String s = yourEditText.toString();<break/>Integer digitNumber = s.length();<break/>Integer i = Integer.valueOf(s);<break/>
then ull have to read single digits u do this by using the Mod operator so
new Integer[] I = new Integer[digitNumber];<break/>for(int i=0; i&lt;digitNumber;i++){<break/>    I[i] = i % 10;<break/>    i = i/10;<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Get your String from your EditText and then store each number into an array using a for loop.

					<delay>2</delay>
					public class EditTextArray extends AppCompatActivity {<break/>    @Override<break/>    protected void onCreate(Bundle savedInstanceState) {<break/>        super.onCreate(savedInstanceState);<break/>        setContentView(R.layout.activity_edit_text_array);<break/>        EditText et = (EditText) findViewById(R.id.editText);<break/>        et.setText("1452");  // Normally user input here...<break/>        String text = et.getText().toString();<break/>        int[] array = new int[text.length()];<break/>        for (int i = 0; i &lt; text.length(); i++) {<break/>            array[i] = Character.getNumericValue(text.charAt(i));<break/>        }<break/>        Log.d("Output: ", Arrays.toString(array));<break/>        //09-20 14:27:45.272 20400-20400/com.jtwaller.test D/Output:: [1, 4, 5, 2]<break/>        StringBuilder sb = new StringBuilder();<break/>        for (int i = 0; i &lt; text.length(); i++) {<break/>            sb.append(array[i] + " ");<break/>        }<break/>        Log.d("Output: ", sb);<break/>        //09-20 14:27:45.272 20400-20400/com.jtwaller.test D/Output:: 1 4 5 2 <break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Just do like so... get your String and convert it with parseInt
String number = "10";<break/>int result = Integer.parseInt(number);<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ android studio ^ take input ^ edittext field ^ number eg ^ 1452 ^ convert ^ integer array ^ 1 ^ 4 ^ 5 ^ 2 </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Display numbers in characters as integers -->
			^ display numbers ^ characters ^ integers 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					public static void main(String[] args) {<break/>    int value = 1234;<break/>    List&lt;Integer&gt; output = new ArrayList&lt;Integer&gt;();<break/>    while (value &gt; 0) {<break/>        output.add(value % 10);<break/>        value /= 10;<break/>    }<break/>    Collections.sort(output);<break/>    System.out.println("Min:" + output.get(0));<break/>    System.out.println("Max:" + output.get(output.size() - 1));<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Almost there.
					<delay>2</delay>
					You are missing an important piece though.
					<delay>2</delay>
					You need to call sort() on Arrays

					<delay>2</delay>
					public static void main(String[] args) {<break/>    int value = 1234;<break/>    char[] arr = String.valueOf(value).toCharArray();<break/>    Arrays.sort(arr);<break/>    System.out.println(arr[0] + " " + arr[arr.length - 1]);<break/>}<break/>
O/P :
1 4 // arr[0] is min and arr[arr.length-1] is max<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can do this using for loop ,only if you want to display these numbers seperately.
					<delay>2</delay>
					I suggest you want to display all four digits in seperate four lines.it will be done by bellow code.

					<delay>2</delay>
					 int value = 1234;<break/> char [] chars = String.valueOf(value).toCharArray();     <break/> for(int i=0; i &lt; chars.length ; i++ )<break/> System.out.println(chars[i]);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You will need a loop to pull of each individual digit and compare it to the current min/max :
int n = 36348;<break/>    int min = Integer.MAX_VALUE;<break/>    int max = Integer.MIN_VALUE;<break/>    if (n &gt; 0) {<break/>        while (n &gt; 0) {<break/>            int digit = n % 10;<break/>            max = Math.max(max, digit);<break/>            min = Math.min(min, digit);<break/>            n /= 10;<break/>        }<break/>    }<break/>    System.out.println(min);<break/>    System.out.println(max);<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ display numbers ^ characters ^ integers </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Is there a way to put "continue" inside a foreach arraylist -->
			^ way ^ put ^ continue ^ inside ^ foreach arraylist 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You can't do that in Java 8.
					<delay>2</delay>
					You could use an Exception to break from code.
					<delay>2</delay>
					It's not pretty, but it's doable if you need to.

					<delay>2</delay>
					Like this:
try {<break/>    Array.forEach((x) -&gt; {<break/>       if (condition) {<break/>          throw new MyException();<break/>       }<break/>    });<break/>} catch (MyException e) {<break/>    // broke from loop<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ way ^ put ^ continue ^ inside ^ foreach arraylist </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to save a line of user inputted integers into an array? -->
			^ save ^ line ^ user inputted integers ^ array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You can let the user input the data as a String delimited by space (or other delimiters)
After you receive the string of input, tokenized the data into tokens where you can store them into a data structure of your choice (array, array list..etc).

					<delay>2</delay>
					You may use String.split() when tokenizing them.

					<delay>2</delay>
					For example:

					<delay>2</delay>
					String input = sc.nextLine();<break/>String[] tokens = input.split(" ");<break/>int[] data = new int[tokens.length];<break/>for(int x=0; x&lt;tokens.length; x++)<break/>    data[x] = Integer.parseInt(tokens[x]);<break/>//Input: 11 22 33 44<break/>//data[0] will be 11<break/>//data[1] will be 22<break/>//data[2] will be 33 and so on<break/>
;

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ save ^ line ^ user inputted integers ^ array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to create a loop for -->
			^ create ^ loop 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					so the idea is to dublicate consonants and put "o" between them, like t becomes tot, s becomes sos.
					<delay>2</delay>
					Vocals are just copied.
					<delay>2</delay>
					So you need a method that tells you if a given character is a vocal or consonant to base your decision on that.

					<delay>2</delay>
					public static boolean isConsonant(char inputChar){<break/>    final String consonantsx = "bBcCdDfFgGhHjJkKlLmMnNpPqQrRsStTvVwWxXzZ"; <break/>    char consonants[] = consonantsx.toCharArray(); // String to charr<break/>    for(int i=0; i &lt; consonants.length;i++){<break/>        if(inputChar == consonants[i]){ //note that in Strings u use the equals method instead of "=="<break/>            return true;<break/>        }<break/>    }<break/>    return false;<break/>}<break/>

					<delay>2</delay>
					Given this method you can use it in the "translator method".

					<delay>2</delay>
					    public String rovarSpraket(String normalString) {<break/>    char[] array = normalString.toCharArray(); // Input to a char array<break/>    System.out.println("På rövarspråk:");<break/>    String slang = "";<break/>    for (int i = 0; i &lt; normalString.length(); i++) {<break/>        String add = "" + array[i];<break/>        if(Goran.isConsonant(array[i])){<break/>            add += "o" + array[i];<break/>        }<break/>        slang += add;<break/>        }<break/>    return slang;<break/>}<break/>

					<delay>2</delay>
					This translates stubborn to sostotubobboborornon like in the wikipedia article https://en.wikipedia.org/wiki/R%C3%B6varspr%C3%A5ket.

					<delay>2</delay>
				</li>
				<li>
					
					I am going to walk you through what I corrected and changed in your code to make it work in order to make it quick and easy for you to comprehend why your code doesn't work and why my answer fixes it.

					<delay>2</delay>
					The mistakes you made are basic ones and frankly you shouldn't have to much of a hard time correcting them yourself if you would use a debugger that walks you step by step in how your code works.
					<delay>2</delay>
					You should look on how to use a debugger (for example the debugger used in Eclipse, hopefully you are using an IDE to make your life easier).

					<delay>2</delay>
					Firstly, when you are looking for a consonant in your code, you are only walking through the half of it because of your condition for(int x = 0; x&lt;20; x++) since your string holding the consonants if of a length of 40 characters.
					<delay>2</delay>
					This means you are missing consonants like the letter s.

					<delay>2</delay>
					Then you are correctly the consonants you find according to your Swedish language game.
					<delay>2</delay>
					But you are never handling characters that are not of these found consonants.
					<delay>2</delay>
					You should make a case where you handle these "non consonant" letters, may they be vowels or any kind of character (like punctuation marks and so on).
					<delay>2</delay>
					I am fixing this with the use of a simple boolean here.

					<delay>2</delay>
					Keep in mind that my goal here is to change your code as little as I can, thus I went for adding a boolean to handle your cases (checking the presence of a consonant).
					<delay>2</delay>
					There are, obviously, many other ways to implement what you are trying to do.

					<delay>2</delay>
					Here come the changes you should add to your code:
    /*This comes after your print "På rövarspråk:"*/<break/>    boolean isConsonant = false; //Boolean to check wether there is a consonant or not<break/>    for(int i = 0; i&lt;length; i++) {<break/>        //You didn't go through the whole consonants list you made with your prevision condition<break/>        for(int x = 0; x&lt;consonants.length; x++){<break/>            if(array[i] == consonants[x])<break/>            {<break/>                isConsonant = true; //Set the boolean accordingly<break/>                String add = array[i]+"o"+array[i];<break/>                slang = slang + add;<break/>                break;<break/>            }<break/>        }<break/>        if(!isConsonant){ //If we don't have a consonant, add the char to the result string<break/>            slang += array[i];<break/>        }<break/>        isConsonant = false; //Reset the boolean for the next character<break/>    }<break/>    /*Here you can print the result (slang) if you want, as you did*/<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ create ^ loop </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to create a new array from another array recursive -->
			^ create ^ new array ^ another array recursive 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					the problem is you are initializing your return array at the same size of the input x array.
					<delay>2</delay>
					int[] will default its values to 0. 

					<delay>2</delay>
					What you should do is if you find an odd, then subtract the size by one, then initialize the array, this way you wont have "empty" bins that are defaulted to 0

					<delay>2</delay>
				</li>
				<li>
					
					When you are searching for some kind of answer and you do not know the exact size it is a good idea to use List for example ArrayList which can help in your case: 
import java.util.ArrayList;<break/>import java.util.List;<break/>public class Main {<break/>    public static void main(String[] args) {<break/>        // TODO Auto-generated method stub<break/>        int[] a = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };<break/>        List&lt;Integer&gt; result = filterOdd(a);<break/>        for (Integer i : result) {<break/>            System.out.println(i);<break/>        }<break/>    }<break/>    public static List&lt;Integer&gt; filterOdd(int[] m) {<break/>        return filterOddHelp(m, 0, m.length - 1);<break/>    }<break/>    public static List&lt;Integer&gt; filterOddHelp(int[] x, int i, int j) {<break/>        List&lt;Integer&gt; returnArray = new ArrayList&lt;Integer&gt;();<break/>        if (i &lt;= j) {<break/>            returnArray = filterOddHelp(x, i + 1, j);<break/>            if (x[i] % 2 != 0) {<break/>                returnArray.add(x[i]);<break/>            }<break/>        }<break/>        return returnArray;<break/>    }<break/>}<break/>
Console: 
9<break/>7<break/>5<break/>3<break/>1<break/>
Consider using List when you do not know how big of an array you will need.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ create ^ new array ^ another array recursive </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to display a string array to a JPanel? -->
			^ display ^ string array ^ jpanel 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					I would display your list using a JList.

					<delay>2</delay>
					Read the section from the Swing tutorial on How to Use List for working examples that show how to add data to the ListModel of the JList.

					<delay>2</delay>
					Basically instead of adding the strings to a List you add them to a DefaultListModel and add the model to the JList.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ display ^ string array ^ jpanel </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- how to display string array? -->
			^ display string array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					JList provides a constructor JList(Object[]) which you can call after unpacking your ArrayList&lt;String&gt; using toArray()
list = new JList(arr.toArray())<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ display string array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Is it possible to sort an ArrayList of integers using comparable or comparator? -->
			^ possible ^ sort ^ arraylist ^ integers using comparable ^ comparator 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You're able to sort an ArrayList if the elements implement Comparable.
					<delay>2</delay>
					For example, Integers can be sorted with sort():

					<delay>2</delay>
					Collections.sort(arrayList)<break/>
Lists (and arrays) of objects that implement this interface can be
sorted automatically by Collections.sort (and Arrays.sort).

					<delay>2</delay>
					from https://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ possible ^ sort ^ arraylist ^ integers using comparable ^ comparator </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How do I return true if ArrayList is empty? -->
			^ return true ^ arraylist ^ empty 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					There is already a method provided by java.

					<delay>2</delay>
					return list.isEmpty();<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ return true ^ arraylist ^ empty </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Google maps android store List of Routes in a List -->
			^ google maps android store list ^ list ^ routes 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Check out this answer which adds the route to the ArrayList.
					<delay>2</delay>
					This way you can add all routes to an ArrayList - https://stackoverflow.com/a/17007360/1649353

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ google maps android store list ^ list ^ routes </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- What is the base class for byte array -->
			^ base class ^ byte array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					The answer is byte[].class.

					<delay>2</delay>
					Example:
byte[] receivedMessage = consumer.receiveBody(byte[].class, 15000); // in ms or 15 seconds<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ base class ^ byte array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- What is the difference between a indexed linked list and a array list? -->
			^ difference ^ indexed linked list ^ array list 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					ArrayList is continuous representation of the data . 

					<delay>2</delay>
					So if base addr is lets say 64 and you want a element at 4th index and size of each element is 4 bytes so by doing the math we can say at what memory addr to look for 4th index element .
					<delay>2</delay>
					So we can land at up at the element directly
On the other hand Linked List we have to traverse node by node and by counting the numbers of node traversed . 

					<delay>2</delay>
					SO index works for both of them.
					<delay>2</delay>
					For arraylist we can access it directly but in Linked list we have to traverse the intermediate nodes  

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ difference ^ indexed linked list ^ array list </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Which is faster - inserting an element at the end of an array or a linked list -->
			^ faster ^ inserting ^ element ^ end ^ array ^ linked list 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					I assume you meant ArrayList when you said "array", since in Java you can't "add" to a full array.

					<delay>2</delay>
					Firstly if you're "inserting at the end" you're actually appending to the end not, "inserting".
					<delay>2</delay>
					This distinction is important because inserting into an ArrayList at an arbitrary position is an O(n) operation, because all elements to the right must be "shifted" along by one position to make room for the element being inserted.

					<delay>2</delay>
					Adding to (the tail of) a LinkedList is always a O(1)
					<delay>2</delay>
					(constant time) operation.

					<delay>2</delay>
					Adding to an ArrayList is usually a O(1) operation, but may be a O(n) operation if the backing array is full, because a new array must be allocated and every element copied across.
					<delay>2</delay>
					In the general case of the array not being full, the performance of ArrayList is (slightly) faster than LinkedList, but the difference is very small.

					<delay>2</delay>
					The amortised cost of both is the same, but if constant time is required every time, only a LinkedList can do it.

					<delay>2</delay>
				</li>
				<li>
					
					Appending an element to the end of Array would be faster then Adding to a LinkedList as adding to a LinkedList always means creation of a cell at the end of the list and then adding a value to it.
					<delay>2</delay>
					In Array you just add a value to existing cell.
					<delay>2</delay>
					However, in Array if it is already full and doesn't have a space you will get IndexOutOfBoundsException while in the LinkedList you will never have this problem as the List will always grow according to your needs.
					<delay>2</delay>
					Also there is distinct difference between LinkedList and ArrayList with ArrayList there is a random access which means the access to any element is always O(1) while in Array0it is always sequential access which means that access time will differ depending on the index and in worst case scenario is O(n).
					<delay>2</delay>
					However, Appending to Array1 is Always O(1) but not so in Array2 With ArrayList if it is not full it will be O(1)
					<delay>2</delay>
					but if it is full it will first grow by more then one cell and only ten
					<delay>2</delay>
					it will add the value, so the worst case scenario is O(n)

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ faster ^ inserting ^ element ^ end ^ array ^ linked list </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- largest increasing sequence of array -->
			^ largest increasing sequence ^ array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					import java.util.Arrays;<break/>public class Main<break/>{<break/>    public static void main(String atrgs[])<break/>    {<break/>        int[] array = {1,2,3,4,2,4,1,1,2,3,4,5,1,2,3,4,5,6,7,4,3,2,1};<break/>        int[] result = biggestIncreasingSeq(array);<break/>        System.out.println(Arrays.toString(result));<break/>    }<break/>    public static int[] biggestIncreasingSeq(int[] array)<break/>    {<break/>        int bestStart = 0;<break/>        int bestEnd = 0;<break/>        int start = 0;<break/>        int end = 0;<break/>        for (int i = 1; i &lt; array.length; ++i)<break/>        {<break/>            // Check if this next element is no longer increasing<break/>            if (array[i] &lt;= array[i - 1])<break/>            {<break/>                // No longer increasing.<break/>                // Update the largest found array, if applicable<break/>                if (end - start &gt; bestEnd - bestStart)<break/>                {<break/>                    // This was a longer sequence<break/>                    bestEnd = end;<break/>                    bestStart = start;<break/>                }<break/>                // Reset for the next sequence<break/>                start = i;<break/>                end = i;<break/>            }<break/>            else<break/>            {<break/>                // Still increasing, update the end<break/>                end = i;<break/>            }<break/>        }<break/>        // Save the sequence to a new array<break/>        int[] result = new int[bestEnd - bestStart + 1];<break/>        for (int i = bestStart; i &lt;= bestEnd; ++i)<break/>        {<break/>            result[i - bestStart] = array[i];<break/>        }<break/>        return result;<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					You can find the solution here
Longest Increasing Subsequence
http://www.geeksforgeeks.org/dynamic-programming-set-3-longest-increasing-subsequence/

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ largest increasing sequence ^ array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Equal ArrayLists (Java) -->
			^ equal arraylists ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You are adding the numbers everytime.
					<delay>2</delay>
					You should use local variables or local initialization.
					<delay>2</delay>
					Else your passcode list gets 5 more numbers everytime
					<delay>2</delay>
					you call your function.

					<delay>2</delay>
				</li>
				<li>
					
					I think you have a problem where you are comparing your arrays.
					<delay>2</delay>
					Have a look at this SO question: equals vs Arrays.equals in Java

					<delay>2</delay>
					if (digitList.size() == 5 &amp;&amp; digitList.equals(passcode)) { // are the arrays the same array?<break/>            guideArea.setText("Correct Password.");<break/>            digitList.clear();<break/> }<break/>

					<delay>2</delay>
					what it should be: 
if (digitList.size() == 5 &amp;&amp; Arrays.equals(digitList, passcode)) { // are the two arrays CONTENT the same<break/>            guideArea.setText("Correct Password.");<break/>            digitList.clear();<break/>  }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Because you said "a security keypad", I have to say ignore what anyone else says that is technically correct, you are doing it wrong.
					<delay>2</delay>
					By storing the passcode in a "plain" format, you might as well just leave a sticky note on the keypad with the passcode on it.

					<delay>2</delay>
					What you should be doing is hashing the input and the passcode and comparing the hashed versions.
					<delay>2</delay>
					And don't use hashCode(), that function is unreliable for this purpose.
					<delay>2</delay>
					(Example of how to hash)
Also, according to the Java Docs, equals is the correct way to check.
					<delay>2</delay>
					You are miss-handling your list instances.
					<delay>2</delay>
					You should step through the debugger to see everywhere in your code that you do something that alters your global variables.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ equal arraylists ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How do I create an array that contains numbers and char? -->
			^ create ^ array ^ contains numbers ^ char 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					An array can contain only a single type of value, but you can create array of object.

					<delay>2</delay>
					this might help you - http://www.javawithus.com/tutorial/array-of-objects

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ create ^ array ^ contains numbers ^ char </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Find all combinations that gives the result A[i]+B[j]=C[k] with 3 arrays at O[n^2] -->
			^ find ^ combinations ^ gives ^ result ^ k ^ 3 arrays ^ n ^ 2 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Update:
					<delay>2</delay>
					Question was later modified to ask specifically for an implementation in Java.
					<delay>2</delay>
					The algorithm and explanation in Python remain valid, but I've also added Java implementation below.

					<delay>2</delay>
					Use a hashmap (or a set) to test for existence in C with time complexity O(1) (on average).
					<delay>2</delay>
					Then all you need is to iterate over all pairs (a,b) | a &lt;- A, b &lt;- B, for a total time complexity of O(n^2).

					<delay>2</delay>
					For example, in Python you could do it like this:
c = set(C)<break/>for a in A:<break/>    for b in B:<break/>        if a + b in c:<break/>            print a, b, a + b<break/>
Quick test:
&gt;&gt;&gt; A = [1,2,3]<break/>&gt;&gt;&gt; B = [3,4,5]<break/>&gt;&gt;&gt; C = [1,4,7]<break/>&gt;&gt;&gt; c = set(C)<break/>&gt;&gt;&gt; for a in A:<break/>...     for b in B:<break/>...         if a + b in c:<break/>...             print a, b, a + b<break/>... <break/>1 3 4<break/>2 5 7<break/>3 4 7<break/>

					<delay>2</delay>
					Or, a shorter version with a list comprehension:
&gt;&gt;&gt; c = set(C)<break/>&gt;&gt;&gt; [(a,b,a+b) for a in A for b in B if a+b in c]<break/>[(1, 3, 4), (2, 5, 7), (3, 4, 7)]<break/>

					<delay>2</delay>
					The Java implementation is essentially the same.
					<delay>2</delay>
					The key observation is to use java.util.HashSet for checking if the sum A[i]+B[j] is present in the array C0:
C1

					<delay>2</delay>
				</li>
				<li>
					
					There is a simpler problem: given two arrays and a number find all combinations from the arrays which give sum=number.
					<delay>2</delay>
					It can be solved in O(n).

					<delay>2</delay>
					We can use its solution as part of solution for the larger one:

					<delay>2</delay>
					(I'm assuming that all elements are different - it simplifies things a bit)
sort(A)<break/>sort(B)<break/>sort(C)<break/>for(int indexC=0;indexC&lt;N;++indexC)<break/>    int indexA=0<break/>    int indexB=N-1<break/>    while(indexA&lt;0)<break/>        //find all combinations in A,B with sum=C[indexC]<break/>        int sum=A[indexA]+B[indexB]<break/>        if(sum==C[indexC])<break/>            OutputCombination(indexA,indexB,indexC)<break/>        if(sum&lt;C[indexC])<break/>            ++indexA<break/>        else if(sum&gt;C[indexC])<break/>            --indexB<break/>        else<break/>            ++indexA<break/>            --indexB<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ find ^ combinations ^ gives ^ result ^ k ^ 3 arrays ^ n ^ 2 </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How can I insert into an AVL tree that does not use rotation? -->
			^ insert ^ avl tree ^ use rotation 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					If the tree is balanced even after insertion of the new element, there is no need for rotation in AVL tree.
					<delay>2</delay>
					However, if the tree is not balanced after insertion of new elements, then rotation is required.

					<delay>2</delay>
					That is, if the Balance Factor is not violated after insertion, then rotation of any type is not required and insertion is possible without rotation in this scenario.

					<delay>2</delay>
					Note that balance factor in AVL tree refers to calculation of difference between the height of the left and the right sub-trees and it must not be more than 1 to avoid rotation.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ insert ^ avl tree ^ use rotation </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- to reverse the elements of an array -->
			^ reverse ^ elements ^ array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Change,
System.out.println(arr[n]);<break/>
to:
System.out.println(Arrays.toString(arr));<break/>

					<delay>2</delay>
				</li>
				<li>
					
					System.out.println(arr[n]);
Here is the problem because there's no index "n" 

					<delay>2</delay>
					n is the number of elements
You have to loop form 0 to n-1
    for(int i =0;i &lt; n;i++){<break/>System.out.println(arr[i]);<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					your code works fine for reversing the array of elements but arrayIndexOutOfBound exception is raised due to System.out.println(arr[n]).
					<delay>2</delay>
					Remember array index starts from zero.
					<delay>2</delay>
					For n size array, the range will be [0,(n-1)]
					<delay>2</delay>
					ie., if n=5 range will be 0 to 4. 

					<delay>2</delay>
					for(int k=0;k&lt;arr.length;k++)<break/>{ <break/>   System.out.println(arr[k]);<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ reverse ^ elements ^ array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Does it matters where you put the square brackets when creating an Array -->
			^ matters ^ put ^ square brackets ^ creating ^ array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					No, int[] i is the same as int i[], but the latter one is discouraged.

					<delay>2</delay>
					See the official documentation on Arrays:
  However, convention discourages this form; the brackets identify the array type and should appear with the type designation.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ matters ^ put ^ square brackets ^ creating ^ array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java: Why is getting the length of an array O(1)? -->
			^ java ^ getting ^ length ^ array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					No, Java arrays have a length property that stores their length (i.e. every arrays knows its own length).
					<delay>2</delay>
					No counting is necessary.

					<delay>2</delay>
				</li>
				<li>
					
					Consider if you were writing a programming language, and you have to implement an array type.
					<delay>2</delay>
					How would you do that?

					<delay>2</delay>
					Clearly, you would need to know how much memory you need to store the array.
					<delay>2</delay>
					It follows that you would probably like to keep track of that somehow.

					<delay>2</delay>
					Thus, in all languages that have arrays, the number of elements in the array is also stored as part of the array.
					<delay>2</delay>
					Knowing the length of the array is nothing more than looking at the length value, an O(1) operation.

					<delay>2</delay>
					C and C++ are special.

					<delay>2</delay>
					They treat pointers and arrays with near-identical syntax.
					<delay>2</delay>
					What this means is that if you treat an actual array as a pointer, you lose the size information.

					<delay>2</delay>
					But even if you don’t, it is convenient for storing things like character strings, which can vary in length.
					<delay>2</delay>
					The old C-style way to mark the end of a string is to use the character with zero value, the null character. 

					<delay>2</delay>
					So to find the end of a C-string, no matter how large the array containing it is, you must count through all the characters until you find the one with a value of zero, an O(n) operation.

					<delay>2</delay>
					This is not the same as not knowing the length of the containing array.

					<delay>2</delay>
					It can be, and often is
					<delay>2</delay>
					when dealing with C-strings, that access to a string array does not come with knowledge of the size of the array containing the string, because of the already-mentioned issue where arrays degenerate into pointers so easily.

					<delay>2</delay>
					So to answer your question, it kind of depends on what you mean by “array”.
					<delay>2</delay>
					If you are talking about some open sequence, such as a character device or pipe, then yes, you must have some way of determining when you have encountered the last element or not.
					<delay>2</delay>
					But for arrays proper, then no, the size of the array is an integral part of its type.

					<delay>2</delay>
				</li>
				<li>
					
					Hm..?
					<delay>2</delay>
					Are you a C developer?

					<delay>2</delay>
					int[] arr = new int[500];<break/>System.out.println(arr.length); //Prints 500<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java ^ getting ^ length ^ array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How can I convert String[][] to ArrayList? -->
			^ arraylist 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					How about this?

					<delay>2</delay>
					ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();<break/>String[][] list = new String[3][2];<break/>list[0][0] = "a";<break/>list[0][1] = "b";<break/>list[1][0] = "c";<break/>list[1][1] = "d";<break/>list[2][0] = "e";<break/>list[2][1] = "f";<break/>for (String[] sublist : list) {<break/>    for (String string : sublist) {<break/>        arrayList.add(string);<break/>    }<break/>}<break/>System.out.println(arrayList);<break/>

					<delay>2</delay>
					This might not be the best way, but it works.

					<delay>2</delay>
					Good luck.

					<delay>2</delay>
				</li>
				<li>
					
					Directly, No.
					<delay>2</delay>
					It is not possible.
					<delay>2</delay>
					This is because an ArrayList is one dimensional, while your array is two dimensional.
					<delay>2</delay>
					You have two options you can work with,
Convert your 2d array into an array of ArrayLists

					<delay>2</delay>
					flatten your 2d array into a 1d array, then convert that into an ArrayList

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ arraylist </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How do I see if an array index I'm accessing is out of range of the array? -->
			^ see ^ array index ^ array ^ accessing ^ range 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					if you have array like this(int[
					<delay>2</delay>
					] a = new in[10])
					<delay>2</delay>
					you can test it like 
if(index &lt; a.length)<break/>
or if you have ArrayList&lt;Integer&gt; b = new ArrayList&lt;Integer&gt;(); you can test it like
if( index &lt; b.size())<break/>

					<delay>2</delay>
				</li>
				<li>
					
					The correct boolean expression to check if an index is out of bounds for array array is:

					<delay>2</delay>
					index &lt; 0 || index &gt;= array.length<break/>

					<delay>2</delay>
					As in:
if (index &lt; 0 || index &gt;= array.length) {<break/>    System.out.println("Index is out of bounds");<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Use array.length to find the length of the array and then compare your index with array.length (it should be less than length of array and greater or equal to 0).

					<delay>2</delay>
					As the index surpasses length java gives you exception(ArrayIndexOutOfBounds Exception).

					<delay>2</delay>
					   //let i be the index<break/>
if(i
					<delay>2</delay>
					>=
					<delay>2</delay>
					array.length
					<delay>2</delay>
					|| i&lt;0)
   
					<delay>2</delay>
					//you will get an error

					<delay>2</delay>
				</li>
				<li>
					
					You can always check if the index you are trying to use can be accessed by doing this:
if(index &gt;= 0 and index &lt;= array.length−1)   //This checks to see if the index you are going to use is greater or equal to 0 (since you cant access a negative index) and make sure it is less than the maximum size of the whole array)

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ see ^ array index ^ array ^ accessing ^ range </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to remove duplicated elements in a List? -->
			^ remove duplicated elements ^ list 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You could have googled once before you posted your question here
					<delay>2</delay>
					, anyway check this link out.

					<delay>2</delay>
					A part of an array cannot be deleted.
					<delay>2</delay>
					You have two options, either you can shift elements to the left or create a new array without the duplicate elements and delete the old array.

					<delay>2</delay>
					This might solve your query.

					<delay>2</delay>
				</li>
				<li>
					
					If you want to have only unique records you can use HashSet, however as you mentioned you want to remove all elements which are duplicates, you can use this simplest piece of code to do it, what you will need to do is create a new list which will only contain uniques and remove duplicates..take a look
List cleanList = new ArrayList&lt;Integer&gt;();<break/>for(int n=0;n&lt;list.size();n++){<break/>  if(!cleanList.contains(list.get(n))){<break/>    cleanList.add(list.get(n));<break/>  }else{<break/>    cleanList.remove(list.get(n));<break/>  }<break/>}<break/>

					<delay>2</delay>
					The result in cleanList will be 3, 5.
					<delay>2</delay>
					See if you can use this or get ideas from the above script

					<delay>2</delay>
				</li>
				<li>
					
					May this can help you:
import java.util.ArrayList;<break/>import java.util.Arrays;<break/>public class RemoveDuplicateElement {<break/>    public static void main(String[] args) {<break/>        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(1,2,1,3,5));<break/>        ArrayList&lt;Integer&gt; duplicateElementsRemovedList = new ArrayList&lt;Integer&gt;();<break/>        for (Integer elementToSearch :list) {<break/>            int found=0;<break/>            for (Integer element :list) {<break/>                if(elementToSearch.equals(element)) {<break/>                    found++;<break/>                }<break/>            }<break/>            if(found==1)<break/>            {<break/>                duplicateElementsRemovedList.add(elementToSearch);<break/>            }<break/>        }<break/>        for (Integer element :duplicateElementsRemovedList) {<break/>            System.out.println(element);<break/>        }<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ remove duplicated elements ^ list </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Whats the equivalent of Java Arrays.copyOfRange in Go? -->
			^ whats ^ equivalent ^ java arrays ^ copyofrange ^ go 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					A simple one-liner would be (index check omitted):
func copyOfRange(src []byte, from, to int) []byte {<break/>    return append([]byte(nil), src[from:to]...)<break/>}<break/>

					<delay>2</delay>
					A simple slice expression "almost" does the job, but since Java's Arrays.copyOfRange() returns a copy independent from the source, we need to copy the slicing result to a new slice (because the result of slicing will share the backing array).

					<delay>2</delay>
					We can do that by allocating one with make(), and use the builtin copy(), or simply use append() to append it to an empty or nil slice, which will take care of the allocation and copying.

					<delay>2</delay>
					Example using the above function:

					<delay>2</delay>
					src := []byte{0, 1, 2, 3, 4, 5}<break/>dst := copyOfRange(src, 2, 4)<break/>fmt.Println(dst)<break/>
Output (try it on the Go Playground):
[2 3]<break/>

					<delay>2</delay>
					For completeness, this is how it would look like with make() and func copyOfRange(src []byte, from, to int) []byte {<break/>    return append([]byte(nil), src[from:to]...)<break/>}<break/>0:
func copyOfRange(src []byte, from, to int) []byte {<break/>    return append([]byte(nil), src[from:to]...)<break/>}<break/>1

					<delay>2</delay>
					One thing to note here
					<delay>2</delay>
					: the builtin func copyOfRange(src []byte, from, to int) []byte {<break/>    return append([]byte(nil), src[from:to]...)<break/>}<break/>2 allocates more space than needed, thinking of future growth.
					<delay>2</delay>
					So if you don't plan to "grow" the returned slice, func copyOfRange(src []byte, from, to int) []byte {<break/>    return append([]byte(nil), src[from:to]...)<break/>}<break/>3 is a better option.

					<delay>2</delay>
					See this comparison:
func copyOfRange(src []byte, from, to int) []byte {<break/>    return append([]byte(nil), src[from:to]...)<break/>}<break/>4
Output (try it on the Go Playground):
func copyOfRange(src []byte, from, to int) []byte {<break/>    return append([]byte(nil), src[from:to]...)<break/>}<break/>5

					<delay>2</delay>
					As you can see, func copyOfRange(src []byte, from, to int) []byte {<break/>    return append([]byte(nil), src[from:to]...)<break/>}<break/>6 (inside func copyOfRange(src []byte, from, to int) []byte {<break/>    return append([]byte(nil), src[from:to]...)<break/>}<break/>7) allocated a backing array with a size of func copyOfRange(src []byte, from, to int) []byte {<break/>    return append([]byte(nil), src[from:to]...)<break/>}<break/>8, while in our func copyOfRange(src []byte, from, to int) []byte {<break/>    return append([]byte(nil), src[from:to]...)<break/>}<break/>9 we explicitly allocated a slice (and backing array) of size Arrays.copyOfRange()0.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ whats ^ equivalent ^ java arrays ^ copyofrange ^ go </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- JAVA How to split by space and store into double array -->
			^ java ^ split ^ space ^ store ^ double array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You should read the line of from the file as a String, split that and convert to double.
					<delay>2</delay>
					Try this:
    try {<break/>        Scanner scan = new Scanner(new File("path/to/file"));<break/>        String str = scan.nextLine();<break/>        String[] split = str.split("\\s+");<break/>        // remove first element<break/>        String[] x = new String[split.length-1];<break/>        for (int i = 0; i &lt; x.length; i++) {<break/>            x[i] = split[i+1];<break/>        }<break/>        double[] numbers = new double[x.length];<break/>        for (int i = 0; i &lt; x.length; i++) {<break/>            numbers[i] = Double.parseDouble(x[i]);<break/>        }<break/>    } catch (FileNotFoundException e) {<break/>        e.printStackTrace();<break/>    }<break/>

					<delay>2</delay>
					I also added a bit to remove the first element since is not a double.
					<delay>2</delay>
					You could condense the two for-loops together, avoiding having a separate x-array.
					<delay>2</delay>
					This can be done as follows:
        String[] split = str.split("\\s+");<break/>        // create double array while ignoring the first element <break/>        double[] numbers = new double[split.length-1];<break/>        for (int i = 0; i &lt; numbers .length; i++) {<break/>            numbers[i] = Double.parseDouble(split[i+1]);<break/>        }<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java ^ split ^ space ^ store ^ double array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java Generic Matrix creation -->
			^ java generic matrix creation 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Creating matrices in Java is not as friendly as say R, or Matlab, or even C.  
					<delay>2</delay>
					The very strong Typing paradigm of Java means that everything has to be defined or initialized.  
					<delay>2</delay>
					So you cant simply do Integers[x][y][z].  
					<delay>2</delay>
					Beyond an array of arrays, things get hairy.

					<delay>2</delay>
					The difference is in a regular matrix moving in +x, -x, +y, -y, +z, -z are all essentially equivalent.  
					<delay>2</delay>
					However in Java, if you want to think of three dimensions of a matrix, they are directional.  
					<delay>2</delay>
					Meaning you have to traverse X, then traverse Y, then traverse Z, always in that order.  
					<delay>2</delay>
					And to move say x+1, you have to go back down z, back down y, and then move your x position, then turn around and traverse y again and z again. 

					<delay>2</delay>
					I am not sure that made sense.
					<delay>2</delay>
					but that is how I have to think about matrices in Java or else
					<delay>2</delay>
					I start making coding errors.

					<delay>2</delay>
					There are libraries for java that focus on creating a matrix.  
					<delay>2</delay>
					You could look there.  
					<delay>2</delay>
					http://ejml.org/wiki/index.php?title=Main_Page

					<delay>2</delay>
					Just creating a random array of arrays (a psuedomatrix as described above) doesn't seem hard overall.

					<delay>2</delay>
					import java.util.Random;<break/>public class Rand<break/>{<break/>   public static void main(String[] args)<break/>   {<break/>      Random random = new Random();<break/>     int dim1 = random.nextInt( 10 );<break/>      int dim2 = random.nextInt( 10 );<break/>      int dim3 = random.nextInt( 10 );<break/>      int[][][] matrix = new int[dim1][dim2][];<break/>      //use dim 3 when you do the specific the declaration for the 3rd dimension<break/>   }<break/>}<break/>
Running quickly through some examples- 
      Int myIntArray
					<delay>2</delay>
					= new int[15]; 
Creates a 15 member int array, initialized to the Default value for that type, which is 0 for 
      //--Assigning
					<delay>2</delay>
					values
      myIntArray[2] =
					<delay>2</delay>
					5; 
      //=  0 0 5 0 0
      
					<delay>2</delay>
					myInt = myIntArray[2];
      
					<delay>2</delay>
					myInt = 5;
// @Initializing with values<break/>   int[5] myIntArray = { 5, 10, 15, 20, 25 };<break/>   int[] myIntArray = { 5, 10, 15, 20, 25 };<break/>
Multidimensional array are not like a matrix in C.
					<delay>2</delay>
					All dimensions are the same type.
					<delay>2</delay>
					Each element is an independent array.
					<delay>2</delay>
					Each array element of an earlier dimension is an array.
					<delay>2</delay>
					All dimensions are of the same type and each element is an independent array.

					<delay>2</delay>
					In Java, each array element of a multidimensional array except the
last dimension is an array, not an individual element
       //    
					<delay>2</delay>
					Two dim array
  int[][] myIntArray2;<break/>  //Or<break/>  int myIntArray[][];<break/>
Use the new operator to allocate.
					<delay>2</delay>
					Allocation initializes to the DEFault
type.
					<delay>2</delay>
					In this case you are initializing an array of arrays, so the DEFault
type is null.

					<delay>2</delay>
					  int[][] myIntArray2d = new int[5][];<break/>  myIntArray2d[3] = new int[5];<break/>

					<delay>2</delay>
					So assigning the array above, you get
  null Null 0 Null Null<break/>  []    []  0 []   [] <break/>  []    []  0 []   [] <break/>  []    []  0 []   [] <break/>  []    []  0 []   [] <break/>

					<delay>2</delay>
					The empty, Defaults in the 1st dim are null - the Default array type.
					<delay>2</delay>
					The second dimension has to be initialized before accessing.

					<delay>2</delay>
					  char[][] charArray = new char[36][];<break/>  //But I cant save anything into  <break/> charArray[4][0]; <break/>  //because it has not been initialized with a separate new statement.<break/>  //This is why you leave the 3rd dim off until later.<break/> char[5]  = new char[5]; // WRONG<break/>  char[] f = new char[5];<break/>  //Now I can follow that with<break/>  charArray[5][5] = 'a';  <break/>  //or from about<break/>  intArray[5][5][5]= 3;<break/>  // But you cant declare the final dimension until later.<break/>  int[3][] arr =  ( { 1, 2, 3 }, { 1, 2 }, { 5, 10, 15, 20 });<break/>  //is an array[2] with 3 arrays<break/>  int[][] arr =   { 1, 2, 3 }, { 1, 2 }, { 5, 10, 15, 20 }; <break/>  //is an array[2] with 3 arrays<break/>

					<delay>2</delay>
					This is why you cant really do matrixes in Java.  
					<delay>2</delay>
					Because each final dimension can technically vary.

					<delay>2</delay>
					When copying an array into a variable - i.e.
  charArrayvars = charArray[5]<break/>  int[] Copies= { 0, 0, 0, 0, 0  } //as a pointer not the data.<break/>  // This means that<break/>  int[3] ArrayA = { 1, 2, 3 };<break/>  Int[3] ArrayB = { 4, 5, 6 };<break/>  ArrayB = Array A;<break/>  //So ArrayB now references Array A.<break/>   //Now if I set<break/>  ArrayA[0] = 0; //then<break/>   if( ArrayB[0] = 0 &amp;&amp;  ArrayA==ArrayB.){}<break/>  //  The logic comparator really just shows they use the same reference.<break/>

					<delay>2</delay>
					I  think though I would evaluate your objectives and see if there is another way.  
					<delay>2</delay>
					Or maybe use a library.  
					<delay>2</delay>
					Because a matrix like you are thinking is not native to Java.  
					<delay>2</delay>
					There are lots of strange behaviors which I have done a terrible job explaining.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java generic matrix creation </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Why does hashcode() returns an integer and not long? -->
			^ integer ^ long 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Well, one good reason is that the hashCode based data structures (HashSet, HashMap) use an array to store the bins, and arrays are limited to int indices.
					<delay>2</delay>
					You will gain nothing by a long hashCode() if you must map it to an int array index.

					<delay>2</delay>
				</li>
				<li>
					
					Using the hashCode is to have N buckets where the hashCode % N determines the bucket of elements, hopefully being 1 (no conflicting hashCodes).

					<delay>2</delay>
					For N, for the hash code, an int is entirely sufficient; indeed one needs to have most variety in the lower bits; having a long without using the higher bits (when N would be a power of 2), would be counter productive.

					<delay>2</delay>
					Speed of course is a requirement too: int being slightly better on the final CPU.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ integer ^ long </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to convert java list to array in scala? -->
			^ convert java list ^ array ^ scala 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You have to create the target array first, and provide it as input for the toArray method:

					<delay>2</delay>
					list.toArray(Array.ofDim[POJO](list.size))<break/>

					<delay>2</delay>
					This API shifts all the problems with array instantiation from the toArray method to you, so it is your responsibility to make sure that POJO is either something concrete, or to provide a ClassTag.

					<delay>2</delay>
					You could also do the conversion in two steps, first using asScala from JavaConverters:
import scala.collection.JavaConverters._<break/>
and then invoking .toArray from the Scala API (unlike Java's API, it preserves the type):
toArray0

					<delay>2</delay>
				</li>
				<li>
					
					Below code works for me:

					<delay>2</delay>
					applcation.conf

					<delay>2</delay>
					mydata.crypto {
ciphers = [<break/>           &quot;TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384&quot;<break/>           &quot;TLS_DHE_RSA_WITH_AES_256_GCM_SHA384&quot;<break/>           &quot;TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384&quot;<break/>          ]<break/> protocols = [<break/>               &quot;TLSv1.2&quot;<break/>             ]<break/>   }<break/>
Sample code in scala
Reading as List:

					<delay>2</delay>
					val
					<delay>2</delay>
					ciphersList = config.getStringList(&quot;mydata.crypto.ciphers&quot;)

					<delay>2</delay>
					val protocolsList
					<delay>2</delay>
					= config.getStringList(&quot;mydata.crypto.protocols&quot;)
import
					<delay>2</delay>
					scala.collection.JavaConverters._

					<delay>2</delay>
					val enableCiphersList = ciphersList.asScala.toArray

					<delay>2</delay>
					val enableProtocolsList = protocolsList.asScala.toArray

					<delay>2</delay>
					Now we can see &quot;enableCiphersList&quot; and &quot;enableProtocolsList&quot; are Array of Strings type.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ convert java list ^ array ^ scala </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to remove duplicate numbers from an array only without using any collections from java.util in java -->
			^ remove duplicate numbers ^ array ^ without using ^ collections ^ java ^ util 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					public class UniqueElementinAnArray <break/>{<break/>    public static void main(String[] args) <break/>    {<break/>        int[] a = {10,10,10,10,10,100};<break/>        int[] output = new int[a.length];<break/>        int count = 0;<break/>        int num = 0;<break/>        //Iterate over an array<break/>        for(int i=0; i&lt;a.length; i++)<break/>        {<break/>            num=a[i];<break/>            boolean flag = check(output,num);<break/>            if(flag==false)<break/>            {<break/>                output[count]=num;<break/>                ++count;<break/>            }<break/>        }<break/>        //print the all the elements from an array except zero's (0)<break/>        for (int i : output) <break/>        {<break/>            if(i!=0 )<break/>                System.out.print(i+"  ");<break/>        }<break/>    }<break/>    /***<break/>     * If a next number from an array is already exists in unique array then return true else false<break/>     * @param arr   Unique number array. Initially this array is an empty.<break/>     * @param num   Number to be search in unique array. Whether it is duplicate or unique.<break/>     * @return  true: If a number is already exists in an array else false <break/>     */<break/>    public static boolean check(int[] arr, int num)<break/>    {<break/>        boolean flag = false;<break/>        for(int i=0;i&lt;arr.length; i++)<break/>        {<break/>            if(arr[i]==num)<break/>            {<break/>                flag = true;<break/>                break;<break/>            }<break/>        }<break/>        return flag;<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ remove duplicate numbers ^ array ^ without using ^ collections ^ java ^ util </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Is it possible in java to insert arithmetic operator(+ - / * ) in an array? -->
			^ possible ^ java ^ array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Yes, you can store them in a char[] or String[]:

					<delay>2</delay>
					char[] chars = new char[10];<break/>chars[0] = '+';<break/>String[] array = new String[10];<break/>array[0] = "+";<break/>
A better way is use some kind of Collection, for example, java.util.List:
List&lt;String&gt; list = new ArrayList&lt;&gt;();<break/>list.add("+");<break/>list.add("-");<break/>list.add("*");<break/>list.add("/");<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Technically you cannot store operators in array or in variable. 

					<delay>2</delay>
					Instead what you can do is store symbols of arithmetic operators in String or Character arrays.

					<delay>2</delay>
					Which then you can interpret as operators while coding
if(ch == '+')<break/>     result = x + y;<break/>

					<delay>2</delay>
					This is only useful if the calculator, your making, is implementing an input field where the user can write text.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ possible ^ java ^ array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to convert an URL to an Image? -->
			^ convert ^ url ^ image 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Just use them in Glide like this:
GlideApp.with(this).load(ENTER_YOUR_URL_HERE).into(imageView);<break/>
don't forget to implement it first.
					<delay>2</delay>
					For more information just follow this link

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ convert ^ url ^ image </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Replace \r\r\n with \n in byte array java -->
			^ replace ^ r ^ n ^ byte array java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					If you are talking about 0x0D 0x0A characters  you can use intermediate String and replaceAll method to do that:
byte[] result = new String(myByteArray).replaceAll("\r\r\n", "\n").getBytes();<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ replace ^ r ^ n ^ byte array java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How can I override next() for jagged array java? -->
			^ jagged array java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					This might be a wrong answer to your question.
					<delay>2</delay>
					I'll remove it in that case, but maybe you can use it for what you want to achieve:
int[][] it = {{1,2}, {3,4,5}};<break/>OfInt iterator = Arrays.stream(it).flatMapToInt(x -&gt; IntStream.of(x)).iterator();<break/>iterator.forEachRemaining((IntConsumer) System.out::print);<break/>
Stream the jagged array, flatmap it into one single IntStream and then do what you want with it.
					<delay>2</delay>
					In this example I fetched the iterator but you might only want:

					<delay>2</delay>
					Arrays.stream(it).flatMapToInt(x -&gt; IntStream.of(x)).forEach((IntConsumer) System.out::print); <break/>

					<delay>2</delay>
					In forEach you can do what you need, or use some other method of IntStream

					<delay>2</delay>
				</li>
				<li>
					
					Thank you all for your answers, I've found my answer in russian stackoverflow:
https://ru.stackoverflow.com/questions/867881/java-iterator-%D0%B4%D0%BB%D1%8F-%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BC%D0%B5%D1%80%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0
public class IteratorFor2DArray implements Iterator {
private int size;<break/>private int i = 0;<break/>private int j = 0;<break/>private int[][] values = new int[i][j];<break/>private int position = 0;<break/>public IteratorFor2DArray(int[][] values) {<break/>    this.values = values;<break/>    this.size = countOfElements(values);<break/>}<break/>private int countOfElements(int[][] values) {<break/>    int count = 0;<break/>    for (int[] row : values) {<break/>        count += row.length;<break/>    }<break/>    return count;<break/>}<break/>@Override<break/>public boolean hasNext() {<break/>    return position &lt; size;<break/>}<break/>@Override<break/>public Integer next() {<break/>    if (position &gt;= size) {<break/>        throw new NoSuchElementException();<break/>    }<break/>    int element = values[i][j];<break/>    position++;<break/>    j++;<break/>    while (i &lt; values.length &amp;&amp; j &gt;= values[i].length) {<break/>        j = 0;<break/>        i++;<break/>    }<break/>    return element;<break/>}<break/>
}

					<delay>2</delay>
				</li>
				<li>
					
					I've also found another way:
public class IteratorFor2DArray implements Iterator {<break/>    private int[][] data;<break/>    private int i, j;<break/>    public IteratorFor2DArray(int[][] data) {<break/>        this.data = data;<break/>    }<break/>    @Override<break/>    public Integer next() {<break/>        if (!hasNext()) {<break/>            throw new NoSuchElementException();<break/>        }<break/>        int element = data[i][j];<break/>        j++;<break/>        while (i &lt; data.length &amp;&amp; j &gt;= data[i].length) {<break/>            j = 0;<break/>            i++;<break/>        }<break/>        return element;<break/>    }<break/>    @Override<break/>    public boolean hasNext() {<break/>        return (i &lt; data.length &amp;&amp; j &lt; data[i].length);<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ jagged array java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to convert oracle.sql.ARRAY to any java collections (for example, to java lists or any) -->
			^ convert oracle ^ sql ^ array ^ java collections ^ example ^ java lists 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You could try this: 
oracle.sql.ARRAY a = ...<break/>String[] strArray = (String[])a.getArray();<break/>List lstArray = java.util.Arrays.asList(strArray);<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ convert oracle ^ sql ^ array ^ java collections ^ example ^ java lists </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to convert a chess co-ordinate into row, column for 2D array -->
			^ convert ^ chess co ^ ordinate ^ row ^ column ^ 2d array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					The below code shows you how to do the transformation you need:
String str = "g3";<break/>System.out.println(str.charAt(0) - 'a');<break/>System.out.println(str.charAt(1) - '1');<break/>
will print
6<break/>2<break/>

					<delay>2</delay>
					so 

					<delay>2</delay>
					str.charAt(0) - 'a' to transform the letter 
str.charAt(1) - '1' to transform the number

					<delay>2</delay>
				</li>
				<li>
					
					First, consider that character code points are arranged alphabetically.
					<delay>2</delay>
					Since characters in Java are represented as unsigned integers, you could subtract the code point of 'a' from another character to see how far it is from 'a': 'a'-'a' = 0, 'b'-'a' = 1, 'c'-'a' = 2, and so on.
					<delay>2</delay>
					Assuming that the first character of a two-character string is a lowercase letter in the a..h range, you can get your first "coordinate" like this:
int hPos = coord.charAt(0)-'a';<break/>

					<delay>2</delay>
					You can do the same thing for the digit:
int vPos = coord.charAt(1)-'1';<break/>

					<delay>2</delay>
					In addition, Java supplies a way to extract a digit from a numeric codepoint.
					<delay>2</delay>
					Since a..h are considered digits in base-18, you could also use this approach:
int hPos = Character.digit(coord.charAt(0), 18) - 10;<break/>int vPos = Character.digit(coord.charAt(1), 10) - 1;<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Since a chess board is well defined, another approach would be to use an enum.
					<delay>2</delay>
					For example:
    public static void main(String[] args) {<break/>        ChessPosition cp = ChessPosition.valueOf("A1");<break/>        System.out.println(cp);<break/>        cp = ChessPosition.valueOf("H8");<break/>        System.out.println(cp);<break/>    }<break/>    public enum ChessPosition {<break/>        A1(0, 0),<break/>        // ...<break/>        H8(7, 7);<break/>        private final int row;<break/>        private final int column;<break/>        private ChessPosition(int row, int column) {<break/>            this.row = row;<break/>            this.column = column;<break/>        }<break/>        public int getRow() {<break/>            return row;<break/>        }<break/>        public int getColumn() {<break/>            return column;<break/>        }<break/>        public String toString() {<break/>            return name() + " row=" + getRow() + ", column=" + getColumn();<break/>        }<break/>    }<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ convert ^ chess co ^ ordinate ^ row ^ column ^ 2d array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- JAVA 8 : How to initialize List Of List in one line -->
			^ java 8 ^ initialize list ^ list ^ one line 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					List&lt;List&lt;Integer&gt;&gt; list = <break/>    Arrays.asList(Arrays.asList(1,2,3), Arrays.asList(4,5,6));<break/>

					<delay>2</delay>
				</li>
				<li>
					
					List&lt;List&lt;Integer&gt;&gt; list = Arrays.asList(Arrays.asList(1,2), Arrays.asList(3,4));<break/>

					<delay>2</delay>
					In Java 9
					<delay>2</delay>
					+ you can replace Arrays.asList() with List.of().

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java 8 ^ initialize list ^ list ^ one line </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Can you use an enhanced for each loop to add elements to an array? -->
			^ use ^ enhanced ^ loop ^ add elements ^ array 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You can never "add" an element to an array.
					<delay>2</delay>
					It is a fixed-size data structure, with or without an enhanced for loop.
					<delay>2</delay>
					All you can do is to allocate an array, and then set its elements.

					<delay>2</delay>
					It doesn't make sense to allocate the array you are iterating in the enhanced for loop - what then are you iterating?
					<delay>2</delay>
					- and as you have stated in the question, you cannot set array elements (directly) in a for loop.

					<delay>2</delay>
					So, no.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ use ^ enhanced ^ loop ^ add elements ^ array </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Subclasses of collection in Java -->
			^ subclasses ^ collection ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Collection us an interface,  not a class, so pedantically it has no sub classes.
					<delay>2</delay>
					Rather, it has classes that implement it, and interfaces that extend it.
					<delay>2</delay>
					As it is a public interface,  anyone could,  in principle, write a class that implements it.
					<delay>2</delay>
					So it is impossible to list all those classes. 

					<delay>2</delay>
				</li>
				<li>
					
					As Raedwald pointed out, Collection is an interface so classes implement it rather than subclass it.
					<delay>2</delay>
					The Java documentation lists the Java classes that implement it.
					<delay>2</delay>
					I feel like that might be what you're looking for: Java 8 Collection Interface

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ subclasses ^ collection ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Is it possible to have array index as char? -->
			^ possible ^ array index ^ char 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					YES!
					<delay>2</delay>
					It is possible.

					<delay>2</delay>
					It is a basic rule of java.

					<delay>2</delay>
					We can assign char value to int type of variable.
					<delay>2</delay>
					Now that int type variable will not store a character but its ASCII value.
					<delay>2</delay>
					See the example
class Test{<break/>    public static void main(String[] args){<break/>        int num='a';<break/>        System.out.println(num);//97<break/>    }<break/>}<break/>

					<delay>2</delay>
					you can see i've assigned 'a' into int type of variable.

					<delay>2</delay>
					In same case, whenever we pass char as index value, always ASCII value will be passed.
					<delay>2</delay>
					As we know, 97 is the ASCII value of a.

					<delay>2</delay>
					So if we access an array by passing 'a', internally 97th index of array will be called.

					<delay>2</delay>
					int num='a';<break/>System.out.println(args[num]);//AIOOBE <break/>

					<delay>2</delay>
					Here we got Exception like
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 97
        at Test.main(Test.java:4)

					<delay>2</delay>
					Program is compiled fine, but we got exception at runtime because args is empty array right now.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ possible ^ array index ^ char </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to remove duplicate elements from list? -->
			^ remove duplicate elements ^ list 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Here are a couple answers from https://www.geeksforgeeks.org/how-to-remove-duplicates-from-arraylist-in-java/
Java 7
    // Create a new ArrayList <break/>    ArrayList&lt;String&gt; uniqueList = new ArrayList&lt;String&gt;(); <break/>    // Traverse through the first list <break/>    for ( element : list) { <break/>        // If this element is not present in uniqueList<break/>        // then add it <break/>        if (!uniqueList.contains(element)) { <break/>            uniqueList.add(element); <break/>        } <break/>    } <break/>
Java 8
    List&lt;String&gt; uniqueList = list.stream() <break/>        .distinct() <break/>        .collect(Collectors.toList()); <break/>

					<delay>2</delay>
				</li>
				<li>
					
					I have created a class to model the pairs and override the equals method to treat "
					<delay>2</delay>
					f1,f2" and "f2,f1" as equals and then found out the duplicates using HashSet.

					<delay>2</delay>
					import java.util.ArrayList;<break/>import java.util.Arrays;<break/>import java.util.HashSet;<break/>import java.util.Iterator;<break/>import java.util.List;<break/>public class so1 {<break/>    public static void main(String[] args) {<break/>        List&lt;String&gt; list = Arrays.asList(new String[] {"f1,f2","f2,f3","f4,f5","f2,f1","f5,f4"});<break/>        List&lt;pair&gt; plist = new ArrayList&lt;pair&gt;();<break/>        for (int i = 0; i &lt; list.size(); i++) {<break/>            plist.add(new pair(list.get(i)));<break/>        }<break/>        HashSet&lt;pair&gt; hs = new HashSet&lt;pair&gt;(); <break/>        for (int i = 0; i &lt; plist.size(); i++) {<break/>            if(!hs.add(plist.get(i))){<break/>                System.out.println("Found duplicate "+plist.get(i).toString());<break/>            }<break/>        }<break/>        List&lt;String&gt; uniqueItems = new ArrayList&lt;String&gt;();<break/>        for (Iterator iterator = hs.iterator(); iterator.hasNext();) {<break/>            pair pair = (pair) iterator.next();<break/>            uniqueItems.add(pair.toString());<break/>        }<break/>        System.out.println(uniqueItems);<break/>    }<break/>}<break/>class pair{<break/>    pair(String inp){<break/>        String[] tokens = inp.split(",");<break/>        Arrays.sort(tokens);<break/>        for(String t: tokens){<break/>            elements.add(t);<break/>        }<break/>    }<break/>    List&lt;String&gt; elements = new ArrayList&lt;&gt;();<break/>    @Override<break/>    public String toString() {<break/>        return ""+elements;<break/>    }<break/>    @Override<break/>    public int hashCode() {<break/>        final int prime = 31;<break/>        int result = 1;<break/>        result = prime * result + ((elements == null) ? 0 : elements.hashCode());<break/>        return result;<break/>    }<break/>    @Override<break/>    public boolean equals(Object obj) {<break/>        if (this == obj)<break/>            return true;<break/>        if (obj == null)<break/>            return false;<break/>        if (getClass() != obj.getClass())<break/>            return false;<break/>        pair other = (pair) obj;<break/>        if (elements == null) {<break/>            if (other.elements != null)<break/>                return false;<break/>        } else if (!elements.equals(other.elements))<break/>            return false;<break/>        return true;<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Using an additional class:
    static class Pair {<break/>    String a, b;<break/>    Pair(String s) {<break/>        String[] arr = s.split(",");<break/>        this.a = arr[0];<break/>        this.b = arr[1];<break/>    }<break/>    static String pairToString(Pair p) {<break/>        return p.a + "," + p.b;<break/>    }<break/>    @Override<break/>    public int hashCode() {<break/>        return Objects.hash(a, b) + Objects.hash(b, a);<break/>    }<break/>    @Override<break/>    public boolean equals(Object o) {<break/>        if (this == o) return true;<break/>        if (o == null || getClass() != o.getClass()) return false;<break/>        Pair p = (Pair) o;<break/>        return (p.a.equals(a) &amp;&amp; p.b.equals(b)) || (p.b.equals(a) &amp;&amp; p.a.equals(b));<break/>    }<break/>
}
Now you can use:
 public static void main(String[] args) {<break/>        List&lt;String&gt; list = Arrays.asList("f1,f2", "f2,f3", "f4,f5", "f2,f1", "f5,f4");<break/>        List&lt;String&gt; strings = list<break/>                .stream()<break/>                .map(Pair::new)<break/>                .distinct()<break/>                .map(Pair::pairToString)<break/>                .collect(Collectors.toList());<break/>    }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					I have another solution .
					<delay>2</delay>
					If you dont want to prepare another class to compare values inside List .
					<delay>2</delay>
					You can separete each value by comma and sort those data.
					<delay>2</delay>
					After that you can again converte them to Set of String 
public static void main(String[] args) {<break/>    List&lt;String&gt; stringList = Arrays.asList("f1,f2", "f2,f3", "f4,f5", "f2,f1", "f5,f4");<break/>    Set&lt;String&gt; result = new HashSet&lt;&gt;();<break/>    for (String s : stringList) {<break/>        String[] elements = s.split(",");<break/>        Arrays.sort(elements);<break/>        result.add(Arrays.toString(elements));<break/>    }<break/>    for (String e : result){<break/>        System.out.println(e);<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ remove duplicate elements ^ list </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Why Array initializer is not Allowed here? What is the problem -->
			^ array initializer ^ allowed ^ problem 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					    public static void main(String[] args) {<break/>            int[] array = new int[] {1,2,3,4,5};<break/>        }<break/>}<break/>

					<delay>2</delay>
					You are currently declaring the size of the array twice, the above will work. 

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ array initializer ^ allowed ^ problem </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- can we use ArrayList as value(datatype) in key-value pair of HashMap? -->
			^ use arraylist ^ value ^ datatype ^ key ^ value pair ^ hashmap 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Little test with jshell (comes with OpenJDK 13):
var map = new HashMap&lt;String, List&lt;String&gt;&gt;();<break/>map.put("first", new ArrayList&lt;String&gt;());<break/>map.get("first").add("one");<break/>

					<delay>2</delay>
				</li>
				<li>
					
					     Map&lt;Integer, List&lt;Integer&gt;&gt; m_Map1 = new <break/>      HashMap&lt;Integer, List&lt;Integer&gt;&gt;();<break/>       // Add values<break/>        m_Map1.put(1, new ArrayList&lt;Integer&gt;(list1));<break/>         m_Map1.put(2, new ArrayList&lt;Integer&gt;(list2));<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ use arraylist ^ value ^ datatype ^ key ^ value pair ^ hashmap </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- New String value on each execution -->
			^ new string value ^ execution 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					The way you ask the question doesn't really fit to stackoverflow, as you are asking for a rather basic technique and do not provide at all what you have tried so far.
					<delay>2</delay>
					I'll answer you nonetheless.

					<delay>2</delay>
					You'd need to save the last picked String (or its index, a hash, some representation of your choice, ...) to a file, then when executing the code again you'd pick a random int, check if the File exists and if yes pick a new random Int until !
					<delay>2</delay>
					list[random].equals(lastString).
					<delay>2</delay>
					Again, save that string to said file.

					<delay>2</delay>
					Plus, you need to specify what exactly you mean by code being executed again.
					<delay>2</delay>
					Are we speaking about persistent or temporal memory?

					<delay>2</delay>
				</li>
				<li>
					
					Thats the way to get a value from the same "pool" of numbers if your question was like that you could use the code from below.     

					<delay>2</delay>
					import java.util.Random;<break/>import java.util.ArrayList;<break/>class Main {<break/>  private static ArrayList&lt;String&gt; YourList = new ArrayList&lt;String&gt;(); // creates your List<break/>  public static void main(String[] args) {<break/>    for(int i = 0; i &lt; 5; i++) {<break/>      YourList.add(Integer.toString(i)); // fills it with random values<break/>    }<break/>    for(int i = 0; i &lt; 5; i++) {<break/>      String return_value = GetValue(); // returns the string you wanna output<break/>      System.out.println(return_value); // output<break/>    }<break/>  }<break/>  private static String GetValue() {<break/>    Random r = new Random(); // new random created<break/>    int index = r.nextInt(5); // get a new random index to select from your list<break/>    String temp = YourList.get(index); // cast the valu from the list to a temp String<break/>    return temp; // reutrn statement<break/>  }<break/>}<break/>

					<delay>2</delay>
					If you dont want to use the same number again you will need to add the line 
YourList.remove(index)<break/>
into the function GetValue(). 

					<delay>2</delay>
					And change 
int index = r.nextInt(5);<break/>
into
int index = r.nextInt(YourList.length);<break/>

					<delay>2</delay>
					I hope this helps

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ new string value ^ execution </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Is there any way to extend a Array without copy or without using Arraylist and increase the array size dynamically? -->
			^ way ^ extend ^ array without copy ^ without using arraylist ^ increase ^ array size dynamically 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					
  I should not increase the array size by using Array copy or I should not use Arraylist
If you can't use Arrays.copy() and you can't use ArrayList, then just do the resize yourself, e.g.:

					<delay>2</delay>
					public static String[] increaseSize(String[] array, int newLength) {<break/>    if (array.length &gt;= newLength)<break/>        return array;<break/>    String[] newArray = new String[newLength];<break/>    for (int i = 0; i &lt; array.length; i++)<break/>        newArray[i] = array[i];<break/>    return newArray;<break/>}<break/>
Since Java arrays are fixed-size, the only way to change the size is to create a new array and copy the elements.
					<delay>2</delay>
					Whether doing it yourself, or using some API methods to help you, that's what has to happen.

					<delay>2</delay>
					There is no such thing as a dynamically-sized array in Java.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ way ^ extend ^ array without copy ^ without using arraylist ^ increase ^ array size dynamically </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to Pass size to array for two dimensional Array in Swift -->
			^ pass size ^ array ^ two dimensional array ^ swift 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You can initiate and reserve capacity of an array in swift as follows.

					<delay>2</delay>
					var tempArray: [Span] = []<break/>tempArray.reserveCapacity(count)<break/>

					<delay>2</delay>
				</li>
				<li>
					
					The Java code is creating an array of length count, of ArrayList&lt;Span&gt; - it is an array of ArrayList&lt;Span&gt;s.

					<delay>2</delay>
					Since there are no separate types for ArrayList and Array in Swift, you can just use arrays for both of them.
					<delay>2</delay>
					The type overall is a [[Span]].

					<delay>2</delay>
					var tempArray = Array(repeating: [Span](), count: count)<break/>
tempArray will have count elements, each one is an empty array of count0s, into which you can add more count1s.

					<delay>2</delay>
					Note that translating code is quite like translating a spoken language.
					<delay>2</delay>
					Translating a spoken language word-by-word usually results in very unnatural sounding text.
					<delay>2</delay>
					Similarly, translating code line by line usually doesn't give you good-looking Swift code.
					<delay>2</delay>
					You should get a high-level understanding of what the code is doing, and, in your own "words", write the code that does the same.

					<delay>2</delay>
				</li>
				<li>
					
					// you can init it like this.<break/>var array = Array&lt;Span&gt;()<break/>// or use init it samply like this<break/>// var array:[Span] =  []<break/>let tmp = span.init()<break/>// you can add element by this method<break/>array.append(tmp)<break/>

					<delay>2</delay>
				</li>
				<li>
					
					I think it is better to use just var tempArray = [Span]

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ pass size ^ array ^ two dimensional array ^ swift </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Why int[] aa={'12','2'}; is invalid and int[] aa={'1','2'}; is valid? error showing is Invalid character constant -->
			^ invalid ^ valid ^ error showing ^ invalid character constant 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					'1' and '2' are chars, which can be promoted to int, so they can be assigned to an int array.
					<delay>2</delay>
					Note that the numeric values of '1' and '2' is not equal to the numbers 1 and 2.
					<delay>2</delay>
					They are actually 49 and 50.

					<delay>2</delay>
					i.e. 
int[] aa={'1','2'}; <break/>
will result in the same array as:
$
					<delay>2</delay>
					code_placeholder_5
'12' is not a valid constant in Java.

					<delay>2</delay>
					If you want a String, it should be "12" (but in that case, you can't assign it to an int array).
					<delay>2</delay>
					If you want an int, it should be 12 (i.e. without any quotes).

					<delay>2</delay>
				</li>
				<li>
					
					Because the single quotes indicate 'single character value', and '12' is not a single character, but 2 characters in one go.
					<delay>2</delay>
					Note that int a = '1' is valid, and doesn't do what you think it does.
					<delay>2</delay>
					Run this code:
int a = '1';<break/>System.out.println(a); // This prints... 49????<break/>

					<delay>2</delay>
					Yes, it prints 49.
					<delay>2</delay>
					'1' is a character.
					<delay>2</delay>
					It will silently upcast to an integer here, at which point, you're looking at its UTF codepoint (49).
					<delay>2</delay>
					If you want an int array containing the value 12 and 2, it's just: int[] aa = {12, 2}; - forget the quotes.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ invalid ^ valid ^ error showing ^ invalid character constant </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to get an array of character (A-z, no numbers) from a given string? -->
			^ get ^ array ^ character ^ z ^ numbers ^ given string 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					First replace non-letter characters with blank space, then convert String to char array:
char[] onlyLetters = "regex".replaceAll("[^A-Za-z]+", "").toCharArray(); <break/>

					<delay>2</delay>
				</li>
				<li>
					
					As you said in your comment below your question, what you really want, is to get the individual characters of that given string, which can be achieved by the toCharArray() method in the String class.

					<delay>2</delay>
					String s = "ABCDEfghi1234";<break/>char[] chars = s.toCharArray();<break/>

					<delay>2</delay>
					If you also need to limit the resulting chars to a defined set of characters, you have to remove all others from the string first, which can be done with a simple regex-replace.

					<delay>2</delay>
					String s = "ABCDEfghi1234_.,-DSsf";<break/>s = s.replaceAll("[^A-Za-z]", "");<break/>char[] chars = s.toCharArray();<break/>

					<delay>2</delay>
					The split method you used is normally used to split strings at defined positions, e.g. if you want to split a sentence, separated by spaces.

					<delay>2</delay>
					String sentence = "The quick brown fox jumps over the lazy dog";<break/>String[] words = sentence.split("\\s");<break/>// words now contains the extracted words of the sentence<break/>// words[0] == "The"<break/>// words[1] == "quick"<break/>// ...<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ get ^ array ^ character ^ z ^ numbers ^ given string </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to get list of year in java between two value? -->
			^ get list ^ year ^ java ^ two value 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					You can do the following :
List&lt;Integer&gt; years = new ArrayList&lt;Integer&gt;();<break/>int endYear = Calendar.getInstance().get(Calendar.YEAR);<break/>for(int year = 2018;year &lt;= endYear; year++){<break/>    System.out.println(year);// if you just want to print the years.<break/>    years.add(year);// if you want to store the years in an array list.<break/>}<break/>
Here, Calendar.getInstance().get(Calendar.YEAR) can be used to get the current year.
					<delay>2</delay>
					As you already know the starting year(for eg 2018), we can use this to create a loop for obtaining the required result.

					<delay>2</delay>
				</li>
				<li>
					
					You can use LocalDate or LocalDateTime (jdk 8+):
LocalDate fromDate =  LocalDate.of(2018, 3, 11);<break/>LocalDate toDate = LocalDate.now(); // 2020-03-11<break/>long yearsD = fromDate.until(toDate, ChronoUnit.YEARS); // 2 years<break/>LocalDateTime fromDateTime =  LocalDateTime.of(2018, 3, 11, 5, 45, 30);<break/>LocalDateTime toDateTime = LocalDateTime.now(); // 2020-01-11T10:00:00.0000<break/>long yearsDT = fromDateTime.until(toDateTime, ChronoUnit.YEARS); // 2 years<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ get list ^ year ^ java ^ two value </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- arrays (little a) work in java without the import statement (import java.util.Arrays), why is this? -->
			^ arrays ^ little ^ work ^ java without ^ import statement ^ import java ^ util 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					No, java.util.Arrays is not imported by default.

					<delay>2</delay>
					class Test {<break/>    public static void main(String[] args) {<break/>        int[] a = {1,2};<break/>        int[] b = {1,3};<break/>        System.out.println(Arrays.equals(a,b));<break/>    }<break/>}<break/>
Trying to compile this class will fail, due to Arrays being unknown.
					<delay>2</delay>
					You will need to prepend the file with import java.util.Arrays; for it to compile.

					<delay>2</delay>
					If you're talking about arrays generally, as in how int[] is supported by default, that's a different question, and you'll need to clarify and reword what you mean.
					<delay>2</delay>
					Simply, arrays are supported in C, the language Java is built upon.

					<delay>2</delay>
					EDIT:
					<delay>2</delay>
					Further reading here

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ arrays ^ little ^ work ^ java without ^ import statement ^ import java ^ util </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to write 2d arraylists in java? -->
			^ write 2d arraylists ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					SomeObject[] is array and SomeObject[][] is 2D array.
					<delay>2</delay>
					Below you can see example integer 2D array.

					<delay>2</delay>
					int[][] array2d = new int[][] {<break/>  {1,2,3},<break/>  {4,5,6},<break/>  {7,8,9}<break/>};<break/>array2d[1][1] == 5; // this is true<break/>

					<delay>2</delay>
					There are no 2D ArrayLists, you can fake it by making normal array of ArrayLists or ArrayList containing multiple ArrayLists.

					<delay>2</delay>
					// Array of ArrayLists<break/>ArrayList[] arr = new ArrayList[arraysize];<break/>// ArrayList containing another ArrayList<break/>ArrayList a = new ArrayList();<break/>ArrayList b = new ArrayList();<break/>a.add(b);<break/>

					<delay>2</delay>
				</li>
				<li>
					
					2D arrays in Java are essentially arrays consisting of arrays.
					<delay>2</delay>
					Each element in the array is itself an array. 

					<delay>2</delay>
					int[][] arr = {<break/>    new int[] = { 1, 2, 3 },<break/>    new int[] = { 4, 5, 6 },<break/>    new int[] = { 7, 8, 9 }<break/>}<break/>

					<delay>2</delay>
					The same can be created with ArrayLists. 

					<delay>2</delay>
					ArrayList arrList = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();<break/>arrList.add(new ArrayList&lt;Integer&gt;(Arrays.asList(1, 2, 3)));<break/>arrList.add(new ArrayList&lt;Integer&gt;(Arrays.asList(4, 5, 6)));<break/>arrList.add(new ArrayList&lt;Integer&gt;(Arrays.asList(7, 8, 9)));<break/>

					<delay>2</delay>
					The data type of the parent ArrayList is &lt;ArrayList&lt;Integer&gt;&gt;.
					<delay>2</delay>
					Each element in the parent arrList is itself of type ArrayList which contains Integers.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ write 2d arraylists ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Array index value increment ?i am trying to understand this - count[str.charAt(i)]++ -->
			^ array index value increment ^ trying ^ understand ^ count ^ str ^ charat 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Is count an array of a numeric type (int, long)?

					<delay>2</delay>
					You're indexing into a string, getting the ASCII character value blindly, and using it to index into another array. 

					<delay>2</delay>
					Then incrementing?
					<delay>2</delay>
					You may find that you aren't incrementing what you think you are.
					<delay>2</delay>
					What are you trying to do?
					<delay>2</delay>
					Hmm.

					<delay>2</delay>
					So, like "1" is 31, which is I think perhaps not what you wanted.

					<delay>2</delay>
					Perhaps something more like
Int idx
					<delay>2</delay>
					= Integer.parseInt(are.charAt(t))
					<delay>2</delay>
					; //gives you 1 instead of 31
count [idx]++
Also -
YOUR ARRAY SIZE WON'T CHANGE
					<delay>2</delay>
					BUT YOU ARE HIGHLY LIKELY TO THROW AN EXCEPTION

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ array index value increment ^ trying ^ understand ^ count ^ str ^ charat </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- How to add element to that variable list like this "List listObject" in java? -->
			^ add element ^ variable list like ^ list listobject ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					If you want to add element in List then simply do:
listObject.add(new Object[]{});<break/>

					<delay>2</delay>
					Or if you want to add to Object array inside list then use (Which is quite a long root due to restrictive behavior of array data structure,
					<delay>2</delay>
					Thats why ArrayList is alternative to achieve this. ):

					<delay>2</delay>
					    @Test<break/>    public void testArray()  {<break/>        List&lt;Object[]&gt; listObjects =  new ArrayList&lt;&gt;();<break/>        listObjects.add(new Object[]{1,2});<break/>         addX( listObjects.get(0).length , listObjects.get(0) , 3);<break/>        listObjects.set(0,addX( listObjects.get(0).length , listObjects.get(0) , 3));<break/>        System.out.println(listObjects.get(0));<break/>    }<break/>    public Object[] addX(int n, Object arr[], Object x)<break/>    {<break/>        int i;<break/>        // create a new array of size n+1<break/>        Object newarr[] = new Object[n + 1];<break/>        // insert the elements from<break/>        // the old array into the new array<break/>        // insert all elements till n<break/>        // then insert x at n+1<break/>        for (i = 0; i &lt; n; i++)<break/>            newarr[i] = arr[i];<break/>        newarr[n] = x;<break/>        return newarr;<break/>    }<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ add element ^ variable list like ^ list listobject ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Why can't we directly print Arrays in java? -->
			^ directly print arrays ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Because in Java, arrays are treated like Objects and not as a primitive type.
					<delay>2</delay>
					By default, when printing any object, the object's toString() method is called.
					<delay>2</delay>
					Arrays do not override the default toString method and such do not provide useful information about the contents of the array, so you should call Arrays.toString() instead. 

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ directly print arrays ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Java sorting algorithm problems -->
			^ java sorting algorithm problems 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Problem with this code is that it doesn't swap numbers.
					<delay>2</delay>
					Instead, it replaces array[i] with the minimum number found.
					<delay>2</delay>
					You can modify your loop like this to do the swapping.

					<delay>2</delay>
					        for (int i = 0; i &lt; array.length; i++) {<break/>          int minIndex = i;<break/>          for (int j = i; j &lt; array.length; j++) {<break/>              if (array[j] &lt; array[minIndex]) {<break/>                  minIndex = j;<break/>              }<break/>          }<break/>          if (array[minIndex] != array[i]) {<break/>            int wert = array[minIndex];<break/>            array[minIndex] = array[i];<break/>            array[i] = wert;<break/>          }<break/>        }<break/>

					<delay>2</delay>
				</li>
				<li>
					
					For selection sort use this method
public static void selectionSort(int[] arr) {<break/>    for (int i = 0; i &lt; arr.length - 1; i++) {<break/>        int index = i;<break/>        for (int j = i + 1; j &lt; arr.length; j++) {<break/>            if (arr[j] &lt; arr[index]) {<break/>                index = j;//searching for lowest index<break/>            }<break/>        }<break/>        int smallerNumber = arr[index];<break/>        arr[index] = arr[i];<break/>        arr[i] = smallerNumber;<break/>    }<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					If you need an ascend order just use:
Arrays.sort(array) from java.util library

					<delay>2</delay>
					But if you need to sort descending I'd suggested to reffer to:
https://www.baeldung.com/java-sorting-arrays

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java sorting algorithm problems </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- how to create any array list of **numbers** and not strings? -->
			^ create ^ array list ^ strings 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					List&lt;Number&gt; someList = new ArrayList&lt;&gt;();<break/>someList.add(1);<break/>someList.add(5.5);<break/>
Java has List interface.
					<delay>2</delay>
					And Number - like it says, accepts numbers only.

					<delay>2</delay>
				</li>
				<li>
					
					This should work:
import java.util.ArrayList;<break/>public class NumberTest {<break/>ArrayList&lt;Object&gt; numbersAlone = new ArrayList&lt;Object&gt;();<break/>public ArrayList&lt;Object&gt; numbersList(Object number){<break/>    if(number instanceof Integer) {<break/>        System.out.println("This is an Integer: "+number);<break/>        numbersAlone.add(number);<break/>    }else if(number instanceof Double){<break/>        numbersAlone.add(number);<break/>        System.out.println("This is a Double: "+number);<break/>    }else if(number instanceof Float){<break/>        System.out.println("This is a Float: "+number);<break/>        numbersAlone.add(number);<break/>    }else if(number instanceof Long){<break/>        System.out.println("This is a Long: "+number);<break/>        numbersAlone.add(number);<break/>    }else{<break/>        System.out.println("This is not a number: "+number);<break/>    }<break/>    return numbersAlone;<break/>}<break/>public static void main(String[] args)<break/>{<break/>  NumberTest test = new NumberTest();<break/>  float a = 2.356f;  long b = -200000L;<break/>    ArrayList&lt;Object&gt; c = new ArrayList&lt;&gt;();<break/>    for(int x=0; x&lt;10; x++){<break/>      if(x&gt;0 &amp;&amp; x&lt;3){<break/>            c = test.numbersList(3.45);<break/>      }else if(x&gt; 2 &amp;&amp; x&lt;5){<break/>            c = test.numbersList(a);<break/>      }else if(x&gt; 5 &amp;&amp; x&lt;8){<break/>            c = test.numbersList(b);<break/>      }else if(x&gt;7 &amp;&amp; x&lt;=10){<break/>            c = test.numbersList(x);<break/>      }<break/>    }<break/>    System.out.println(c.toString());<break/>}<break/>}<break/>

					<delay>2</delay>
					So create an ArrayList of Objects and put in your numbers.
					<delay>2</delay>
					The reverse is the case to get your numbers back.
					<delay>2</delay>
					If you want me to add code on how to retrieve the objects, let me know.

					<delay>2</delay>
				</li>
				<li>
					
					Since you've tagged the question as Java, there's a nice solution - just declare your List like this:
List&lt;Number&gt; numberList = new ArrayList&lt;&gt;();
and upon numberList.add(x); calls only those x values will be accepted that are representing numbers.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ create ^ array list ^ strings </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Does java really support rectangular arrays? If not what are non-jagged arrays called in java? -->
			^ java really support rectangular arrays ^ java ^ non ^ jagged arrays called 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					A rectangular 2-dimensional array is just a special case of a jagged array.
					<delay>2</delay>
					Therefore, any language that supports jagged arrays will also support rectangular arrays, while the inverse is not necessarily true.

					<delay>2</delay>
					The expression int[][] numbers = new int[3][5]; is just syntactic sugar, and actually boils down to something like:
int[][] numbers = new int[3][];<break/>numbers[0] = new int[5];<break/>numbers[1] = new int[5];<break/>numbers[2] = new int[5];<break/>
Nothing prevents you from turning a rectangular array into a jagged array after declaration:
int[][] numbers = new int[3][5];<break/>numbers[0] = new int[10]; // works<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Wikipedia says:
In computer science, a ragged array, also known as a jagged array, is an array of arrays of which the member arrays can be of different sizes and producing rows of jagged edges when visualized as output.
					<delay>2</delay>
					In contrast, two-dimensional arrays are always rectangular so jagged arrays should not be confused with multidimensional arrays, but the former is often used to emulate the latter.

					<delay>2</delay>
					According to that, a jagged array is not a 2D array, i.e. the term 2D implies rectangular.

					<delay>2</delay>
					Your question was: What are non-jagged arrays called in java?

					<delay>2</delay>
					Answer:
					<delay>2</delay>
					A two-dimensional array.

					<delay>2</delay>
					Or more precisely &quot;a multidimensional array&quot;, since non-jagged is not limited to only 2 dimensions.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ java really support rectangular arrays ^ java ^ non ^ jagged arrays called </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Is there a material difference between pop() and remove() in Java ArrayDeque? -->
			^ material difference ^ java arraydeque 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					There is no difference.
					<delay>2</delay>
					In fact, pop() and remove() methods both call removeFirst.
					<delay>2</delay>
					See https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/ArrayDeque.java
public E remove() {<break/>    return removeFirst();<break/>}<break/>public E pop() {<break/>    return removeFirst();<break/>}<break/>

					<delay>2</delay>
				</li>
				<li>
					
					Both the methods internally calls removeFirst(), so there is not difference.
					<delay>2</delay>
					ArrayDeque can be used as stack as well as LinkedList
					<delay>2</delay>
					hence we have different interfaces, based on how we want to use it (as a stack, queue or linkedlist).
					<delay>2</delay>
					It was introduced in version 1.6 of java API which is much later than Stack and LinkedList.
					<delay>2</delay>
					As per oracle documentation
ArrayDeque class is likely to be faster than Stack when used as a
stack, and faster than LinkedList when used as a queue.

					<delay>2</delay>
					public E remove() {<break/>    return removeFirst();<break/>}<break/>public E pop() {<break/>    return removeFirst();<break/>}<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ material difference ^ java arraydeque </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- What happens when there are less elements in ArrayList than its capacity? -->
			^ happens ^ less elements ^ arraylist ^ capacity 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					The javadoc states:
Each ArrayList instance has a capacity.
					<delay>2</delay>
					The capacity is the size of the array used to store the elements in the list.
					<delay>2</delay>
					It is always at least as large as the list size.
					<delay>2</delay>
					As elements are added to an ArrayList, its capacity grows automatically.
					<delay>2</delay>
					The details of the growth policy are not specified beyond the fact that adding an element has constant amortized time cost.

					<delay>2</delay>
					Based on the above:

					<delay>2</delay>
					What happens when there are less elements in ArrayList than its capacity?

					<delay>2</delay>
					Given that the backing array's size is the &quot;capacity&quot;, there will be unused slots in the array.

					<delay>2</delay>
					(The implementation ensures that those unused slots contain null to avoid any memory leaks.)

					<delay>2</delay>
					Say capacity is 10, I add 5 elements to ArrayList.
					<delay>2</delay>
					Would they take 5 or 10 elements size in memory?

					<delay>2</delay>
					The size would be the size of 10 object references, since an ArrayList holds references to objects ... not the actual element objects themselves.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ happens ^ less elements ^ arraylist ^ capacity </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Convertion array ['xx=yy'] to map of xx=yy -->
			^ xx ^ yy ^ map 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					In Java you can use stream to convert your array to map.
					<delay>2</delay>
					I think below code snippet might help you:
Map&lt;String,String&gt; resultMap =  Arrays.stream(arr)<break/>    .map(elem-&gt; elem.split(&quot;=&quot;))<break/>    .collect(Collectors.toMap(val-&gt; val[0], val-&gt; val[1]));<break/>

					<delay>2</delay>
				</li>
				<li>
					
					In Javascript / Typescript you can map the array and split the string on '='
var array = [&quot;statusCode=1&quot;];<break/>var object = array.map(v =&gt; {<break/>  let keyValueArr = v.split('=');<break/>  return { [keyValueArr[0]]: keyValueArr[1] }<break/>});<break/>console.log(object)<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ xx ^ yy ^ map </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Storing multiple objects in a single array element in Java -->
			^ storing multiple objects ^ single array element ^ java 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					No.
					<delay>2</delay>
					Any given element of an array is just that, one element.
					<delay>2</delay>
					The type of element does matter, though.

					<delay>2</delay>
					Consider an array of integers:

					<delay>2</delay>
					int[] x = {1, 4, 7, 10};<break/>

					<delay>2</delay>
					One element cannot 'hold' multiple elements.

					<delay>2</delay>
					But now consider an array of arrays of integers:

					<delay>2</delay>
					int[][] x = {<break/>    {1},<break/>    {2, 3},<break/>    {4, 5, 6},<break/>    {7, 8, 9, 10}<break/>};<break/>

					<delay>2</delay>
					Each element is still just a single element.
					<delay>2</delay>
					There are four elements each of type int[].
					<delay>2</delay>
					Then, each of those has one element per element.
					<delay>2</delay>
					You can theoretically have as many layers of this as you want.
					<delay>2</delay>
					It can get confusing very quickly.

					<delay>2</delay>
					Another way to fit 'multiple elements into one element' would be to write your own class that holds multiple elements in whatever way is most useful to you, and make an array of those.

					<delay>2</delay>
					Note: above, I've used primitive arrays to demonstrate.
					<delay>2</delay>
					However, this also works with Java List objects:
ArrayList&lt;Integer&gt; x;  // list of integers<break/>ArrayList&lt;ArrayList&lt;Integer&gt;&gt; x;  // list of ArrayList&lt;Integer&gt; objects, each of which is itself a list of integers<break/>ArrayList&lt;Integer&gt;[] x;  // primitive array of ArrayList&lt;Integer&gt; objects<break/>                         // (I recommend not doing this, it can get confusing)<break/>
If your question is about putting multiple types of objects in a single element, then you have to figure out what superclass encompasses both types (usually Object, if the types are remotely different), and make your list that type:
Object[] x = {Integer.valueOf(5), Double.valueOf(3.14), &quot;some_string&quot;};<break/>
Getting those objects back out again and putting them into their correct type, is difficult, so I don't recommend this.

					<delay>2</delay>
					You can also try building your own Union type, and making the list be that type.

					<delay>2</delay>
				</li>
				<li>
					
					You can store anything in an Object[] object array.

					<delay>2</delay>
					Something like this:
Object[] objArr = new Object[10];<break/>objArr[0] = &quot;String&quot;;<break/>objArr[1] = Arrays.asList(1, 2, 4);<break/>objArr[2] = new ArrayList&lt;&gt;(); <break/>objArr[3] = 1;<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ storing multiple objects ^ single array element ^ java </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Is there a difference between new Class[]{} and new Class[0]? -->
			^ difference ^ new class 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					No difference.

					<delay>2</delay>
					Decompiling this:
final class Foo {<break/>  Class[] a = new Class[]{};<break/>  Class[] b = new Class[0];<break/>}<break/>
yields
$
					<delay>2</delay>
					code_placeholder_2
That is, the two forms yield identical bytecode.

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ difference ^ new class </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
	<category>
		
		<pattern>
			<!-- Can you create a code in array form with this? -->
			^ create ^ code ^ array form 
		</pattern>
		<template>
			
			<random>
				
				<li>
					
					Create a Strint array with all weekdays ({&quot;Sunday&quot;, &quot;Monday&quot;...}) and than get the name by index like this:
int day = 2;<break/>System.out.println(weekdays[day - 1]);//output Monday<break/>

					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				
				<text>Yes</text>
				<postback>^ create ^ code ^ array form </postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>goodanswer</postback>
			</reply>
		</template>
	</category>
</aiml>
