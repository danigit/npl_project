<?xml version="1.0" encoding="UTF-8"?>
<aiml>
    <category>
        <pattern>*</pattern>
        <template>
            <condition name="presentation_done">
                <li value="yes">
                    I do not know how to reply on that, but I can ask a friend of mine
                    <delay>2</delay>
                    His name is StackOverflow. Do you want me to ask him?
                    <think><set name="stacksearchquery"><star/></set></think>
                    <reply>
                        <text>Yes</text>
                        <postback>STACKSEARCH</postback>
                    </reply>
                    <reply>
                        <text>No</text>
                        <postback>GIVEALTERNATIVE</postback>
                    </reply>
                </li> 
                <li value="no"><srai>HI *</srai>r</li>
            </condition>
        </template>
    </category>
    <category>
        <pattern>GIVEALTERNATIVE</pattern>
        <template>
            <random>
                <li>Maibe if you reformulate your statement, I would be able to answer</li>
                <li>Wel, you could always ask me something else :-)</li>
                <li>
                    I realy think that my friend Stackoverflow could help you. <break/>Should I ask him?
                    <reply>
                        <text>Yes</text>
                        <postback>STACKSEARCH</postback>
                    </reply>
                    <reply>
                        <text>No</text>
                        <postback>GIVEALTERNATIVE</postback>
                    </reply>
                </li>
                <li>Undortunately I don't know everithing</li>
            </random>
        </template>
    </category>
    <category>
        <pattern>STACKSEARCH</pattern>
        <template>
            Ok, you should find the informations here
            <button>
                <text><get name="stacksearchquery"/></text>
                <url>http://www.stackoverflow.com/search?q=<get name="stacksearchquery" /></url>
            </button>
            <delay>4</delay>
            Did you find the information you are looking for?
            <reply>
                <text>Yes</text>
                <postback>QUESTIONANSWERED</postback>
            </reply>
            <reply>
                <text>No</text>
                <postback>GOOGLESEARCH</postback>
            </reply>
        </template>
    </category>
    <category>
        <pattern>QUESTIONANSWERED</pattern>
        <template>
            <random>
                <li>I'm glad that I was able to help you</li>
                <li>Nice, I'm here whenever you need me</li>
                <li>Ohhh... I was afraid for a seccond...</li>
            </random>
        </template>
    </category>
    <category>
        <pattern>GOOGLESEARCH</pattern>
        <template>
            I have this other friend that might know the answers.<break/>
            It's name is Google, do you waht to ask him?
            <reply>
                <text>Yes</text>
                <postback>GOOGLESEARCHQUERY</postback>
            </reply>
            <reply>
                <text>No</text>
                <postback>GIVEALTERNATIVE</postback>
            </reply>
        </template>
    </category>
    <category>
        <pattern>GOOGLESEARCHQUERY</pattern>
        <template>
            This is what I was able to find
            <button>
                <text><get name="stacksearchquery"/></text>
                <url>http://www.google.com/search?q=<get name="stacksearchquery" /></url>
            </button>
            <delay>3</delay>
            I have no other friends to ask to, so if you didn't find the answer, maybe you could try to reformulate the question
        </template>
    </category>
    <category>
        <pattern>GOODANSWER</pattern>
        <template>
					<random>
						<li>Thank you, I'm glad that my answer was clear</li>
						<li>Glad to help</li>
						<li>I'm here whenever you need me</li>
					</random>
				</template>
    </category>
    <category>
        <pattern>^ HI ^</pattern>
        <template>
            <condition name="presentation_done">
                <li value="yes">
                    <condition name="username">
                        <li value="*">
                            Hi <get name="username"/>, what is your question?
                        </li>
                        <li>
                            <random>
                                <li>I don't know you, could you tell me your name please</li>
                                <li>I don't think you told me your name, could you tell it to me now please</li>
                                <li>You are new to me, please tell me you name</li>
																<li>I first need to know who I am talking to. Please tell me your name</li>
                            </random>
                        </li>
                    </condition>
                </li>
                <li>
                    <think><set name="presentation_done">yes</set></think>
                    Hi there! First of all I would like to introduce my self!
                    <delay>2</delay>
                    My name is StackBot, and I am able to answer to questions about Arrays and 
                    Lists in Java
                    <delay>2</delay>
                    What is your name?
                </li>
            </condition>
        </template>
    </category>
    <category>
        <pattern>^ HELLO ^</pattern>
        <template><srai>^ HI ^</srai></template>
    </category>
    <category>
        <pattern>^ ARE YOU ^</pattern>
        <template><srai>^ HI ^</srai></template>
    </category>
    <category>
        <pattern>* QUESTION ^</pattern>
        <template>
            <random>
                <li>Ok lets here it</li>
                <li>You can ask me questions about Arrays and Lists in Java
                    <delay>2</delay>
                    So let's see it!
                </li>
                <li>
                    I can answer to some questions about Java Arrays and Lists<break/>
                    So lets see you question
                </li>
            </random>
        </template>
    </category>
    <category>
        <pattern>* QUESTIONS ^</pattern>
        <template><srai>* question ^</srai></template>
    </category>
    <category>
        <pattern>MY NAME IS *</pattern>
        <template>
            <condition name="username">
                <li value="*">Ok I wil remember this name <star/></li>
                <li>
                    Hello <set name="username"><star/></set>
                    <break/>
                    Nice to meet you!
                    <delay>2</delay>
                    Now tell me your question please.
                </li>
            </condition>
        </template>
    </category>
		<category>
			<pattern>I AM *</pattern>
			<template><srai>MY NAME IS *</srai></template>
		</category>
		<category>
			<pattern>I'M *</pattern>
			<template><srai>MY NAME IS *</srai></template>
		</category>
	<category>
		<pattern>
			<!-- 1. How do I remove repeated elements from ArrayList? -->
			^ remove repeated elements ^ arraylist ^
		</pattern>
		<template>
			<random>
				<li>
					If you don't want duplicates in a Collection, you should consider why you're using a Collection 
					that allows duplicates.
					<delay>2</delay>
					The easiest way to remove repeated elements is to add the contents to a Set (which will not allow 
					duplicates) and then add the Set back to the ArrayList:
					<delay>2</delay>
					Set&lt;String&gt; set = new HashSet&lt;&gt;(yourList);<break/>
						yourList.clear();<break/>
						yourList.addAll(set);<break/>
					<delay>2</delay>
					Of course, this destroys the ordering of the elements in the ArrayList.
					<delay>2</delay>
				</li>
				<li>
					If you don't want duplicates, use a Set instead of a List.
					<delay>2</delay>
					To convert a List to a Set you can use the following code:
					// list is some List of Strings<break/>
					Set&lt;String&gt; s = new HashSet&lt;String&gt;(list);<break/>
					If really necessary you can use the same construction to convert a Set back into a List.
					<delay>2</delay>
				</li>
				<li>
					Although converting the ArrayList to a HashSet effectively removes duplicates, if you need to 
					preserve insertion order, I'd rather suggest you to use this variant:
					<delay>2</delay>
					// list is some List of Strings<break/>
					Set&lt;String&gt; s = new LinkedHashSet&lt;&gt;(list);<break/>
					Then, if you need to get back a List reference, you can use again the conversion constructor.
					<delay>2</delay>
				</li>
				<li>
					I think you should use a class implementing the Set interface instead of List to be sure of the 
					unicity of elements.
					<delay>2</delay>
					If you have to keep the order of elements, the SortedSet interface can then be used; the TreeSet 
					class implements that interface.
					<delay>2</delay>
				</li>
				<li>
					Probably a bit overkill, but I enjoy this kind of isolated problem.
					<delay>2</delay>
					This code uses a temporary Set (for the uniqueness check) but removes elements directly inside 
					the original list.
					<delay>2</delay>
					Since element removal inside an ArrayList can induce a huge amount of array copying, the 
					remove(int)-method is avoided.
					<delay>2</delay>
					public static &lt;T&gt; void removeDuplicates(ArrayList&lt;T&gt; list) {<break/>    
						int size = list.size();<break/>    
						int out = 0;<break/>    
						{<break/>        
							final Set&lt;T&gt; encountered = new HashSet&lt;T&gt;();<break/>        
								for (int in = 0; in &lt; size; in++) {<break/>            
									final T t = list.get(in);<break/>            
									final boolean first = encountered.add(t);<break/>            
									if (first) {<break/>                
										list.set(out++, t);<break/>            
									}<break/>        
								}<break/>    
						}<break/>    
						while (out &lt; size) {<break/>        
							list.remove(--size);<break/>    
						}<break/>
					}<break/>
					<delay>2</delay>
					While we're at it, here's a version for LinkedList (a lot nicer!):
					<delay>2</delay>
					public static &lt;T&gt; void removeDuplicates(LinkedList&lt;T&gt; list) {<break/>    
						final Set&lt;T&gt; encountered = new HashSet&lt;T&gt;();<break/>    
						for (Iterator&lt;T&gt; iter = list.iterator(); iter.hasNext(); ) {<break/>        
							final T t = iter.next();<break/>        
							final boolean first = encountered.add(t);<break/>        
								if (!first) {<break/>            
									iter.remove();<break/>        
								}<break/>    
						}<break/>
					}<break/>
					Use the marker interface to present a unified solution for List:
					<delay>2</delay>
					public static &lt;T&gt; void removeDuplicates(List&lt;T&gt; list) {<break/>    
						if (list instanceof RandomAccess) {<break/>        
							// use first version here<break/>    
						} else {<break/>        
							// use other version here<break/>    
						}<break/>
					}<break/>
					<delay>2</delay>
				</li>
				<li>
					Here's a way that doesn't affect your list ordering:
					ArrayList l1 = new ArrayList();<break/>
					ArrayList l2 = new ArrayList();<break/>
					Iterator iterator = l1.iterator();<break/>
					while (iterator.hasNext()) {<break/>    
						YourClass o = (YourClass) iterator.next();<break/>    
						if(!l2.contains(o)) l2.add(o);<break/>
					}<break/>
					l1 is the original list, and l2 is the list without repeated items
					(Make sure YourClass has the equals method according to what you want to stand for equality)
					<delay>2</delay>
				</li>
				<li>
					When you are filling the ArrayList, use a condition for each element.
					<delay>2</delay>
					For example:
					ArrayList&lt; Integer &gt; al = new ArrayList&lt; Integer &gt;(); <break/>    
					// fill 1 <break/>    
					for ( int i = 0; i &lt;= 5; i++ ) <break/>        
						if ( !al.contains( i ) ) <break/>            
							al.add( i ); <break/>    
					// fill 2 <break/>    
					for (int i = 0; i &lt;= 10; i++ ) <break/>        
						if ( !al.contains( i ) ) <break/>            
							al.add( i ); <break/>    
					for( Integer i: al )<break/>    {<break/>        
						System.out.print( i + " ");     <break/>    
					}<break/>
					<delay>2</delay>
					We will get an array {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
					<delay>2</delay>
				</li>
				<li>
					There is the ImmutableSet from Guava as an option (here is the documentation):
					<button>
						<text>Guava Documentation</text>
						<url>https://github.com/google/guava/wiki/ImmutableCollectionsExplained</url>
					</button>
					<delay>2</delay>
					ImmutableSet.copyOf(list);<break/>
				</li>
				<li>
					Here you have some code that you can use:
					<delay>2</delay>
					for(int a=0;a&lt;myArray.size();a++){<break/>        
						for(int b=a+1;b&lt;myArray.size();b++){<break/>            
							if(myArray.get(a).equalsIgnoreCase(myArray.get(b))){<break/>                
								myArray.remove(b); <break/>                
								dups++;<break/>                
								b--;<break/>            
							}<break/>        
						}<break/>
					}<break/>
				</li>
				<li>
					Try to use this code, it shoul work
					import java.util.*;<break/>
					class RemoveDupFrmString<break/>{<break/>    
						public static void main(String[] args)<break/>    {<break/>        
							String s="appsc";<break/>        
							Set&lt;Character&gt; unique = new LinkedHashSet&lt;Character&gt; ();<break/>        
							for(char c : s.toCharArray()) {<break/>            
								System.out.println(unique.add(c));<break/>        
							}<break/>        
							for(char dis:unique){<break/>            
								System.out.println(dis);<break/>        
							}<break/>    
						}<break/>
					}<break/>
				</li>
				<li>
					LinkedHashSet will do the trick.
					<delay>2</delay>
					String[] arr2 = {"5","1","2","3","3","4","1","2"};<break/>
					Set&lt;String&gt; set = new LinkedHashSet&lt;String&gt;(Arrays.asList(arr2));<break/>
					for(String s1 : set)<break/>    
						System.out.println(s1);<break/>
						System.out.println( "------------------------" );<break/>
						String[] arr3 = set.toArray(new String[0]);<break/>
						for(int i = 0; i &lt; arr3.length; i++)<break/>     
							System.out.println(arr3[i].toString());<break/>
					//output: 5,1,2,3,4
				</li>
				<li>
					This method should do the trick:<break/>
					public Set&lt;Object&gt; findDuplicates(List&lt;Object&gt; list) {<break/>        
						Set&lt;Object&gt; items = new HashSet&lt;Object&gt;();<break/>        
						Set&lt;Object&gt; duplicates = new HashSet&lt;Object&gt;();<break/>        
						for (Object item : list) {<break/>            
							if (items.contains(item)) {<break/>                
								duplicates.add(item);<break/>                
							} else { <break/>                    
								items.add(item);<break/>                    
							} <break/>            
						} <break/>        
						return duplicates;<break/>        
					}<break/>
				</li>
				<li>
					This should solve the problem:
					private List&lt;SomeClass&gt; clearListFromDuplicateFirstName(List&lt;SomeClass&gt; list1) {<break/>     
						Map&lt;String, SomeClass&gt; cleanMap = new LinkedHashMap&lt;String, SomeClass&gt;();<break/>     
							for (int i = 0; i &lt; list1.size(); i++) {<break/>         
								cleanMap.put(list1.get(i).getFirstName(), list1.get(i));<break/>     
							}<break/>     
						List&lt;SomeClass&gt; list = new ArrayList&lt;SomeClass&gt;(cleanMap.values());<break/>     
						return list;<break/>
					}<break/>
				</li>
				<li>
					If you want to preserve your Order then it is best to use LinkedHashSet.
					<delay>2</delay>
					Because if you want to pass this List to an Insert Query by Iterating it, the order would be preserved.
					<delay>2</delay>
					Try this code:<break/>
					LinkedHashSet link=new LinkedHashSet();<break/>
					List listOfValues=new ArrayList();<break/>
					listOfValues.add(link);<break/>
					<delay>2</delay>
					This conversion will be very helpful when you want to return a List but not a Set.
				</li>
				<li>
					It is possible to remove duplicates from arraylist using this: 
					<delay>2</delay>
					ArrayList&lt;String&gt; lst = new ArrayList&lt;String&gt;();<break/>    
					lst.add("ABC");<break/>    
					lst.add("ABC");<break/>    
					lst.add("ABCD");<break/>    
					lst.add("ABCD");<break/>    
					lst.add("ABCE");<break/>    
					System.out.println("Duplicates List "+lst);<break/>    
					Object[] st = lst.toArray();<break/>      
					for (Object s : st) {<break/>        
						if (lst.indexOf(s) != lst.lastIndexOf(s)) {<break/>            
							lst.remove(lst.lastIndexOf(s));<break/>         
						}<break/>      
					}<break/>    
					System.out.println("Distinct List "+lst);<break/>
					The output is:<break/>
					Duplicates List [ABC, ABC, ABCD, ABCD, ABCE]<break/>Distinct List [ABC, ABCD, ABCE]<break/>
				</li>
				<li>
					In Java 8:
					List&lt;String&gt; deduped = list.stream().distinct().collect(Collectors.toList());<break/>
					Please note that the hashCode-equals contract for list members should be respected for the 
					filtering to work properly.
				</li>
				<li>
					If you want to remove duplicates from ArrayList means find the below logic,
					public static Object[] removeDuplicate(Object[] inputArray)<break/>{<break/>    
						long startTime = System.nanoTime();<break/>    
						int totalSize = inputArray.length;<break/>    
						Object[] resultArray = new Object[totalSize];<break/>    
						int newSize = 0;<break/>    
						for(int i=0; i&lt;totalSize; i++){<break/>        
							Object value = inputArray[i];<break/>        
							if(value == null){<break/>            
								continue;<break/>        
							}<break/>        
							for(int j=i+1; j&lt;totalSize; j++){<break/>            
								if(value.equals(inputArray[j])){<break/>                
									inputArray[j] = null;}<break/>        
								}<break/>        
								resultArray[newSize++] = value;<break/>    
							}<break/>    
							long endTime = System.nanoTime()-startTime;<break/>    
							System.out.println("Total Time-B:"+endTime);<break/>    
							return resultArray;<break/>
					}<break/>
				</li>
				<li>
					This three lines of code can remove the duplicated element from ArrayList or any collection.
					<delay>2</delay>
					List&lt;Entity&gt; entities = repository.findByUserId(userId);<break/>
					Set&lt;Entity&gt; s = new LinkedHashSet&lt;Entity&gt;(entities);<break/>
					entities.clear();<break/>
					entities.addAll(s);<break/>
				</li>
				<li>
				</li>
				<li>
					Java 8 streams provide a very simple way to remove duplicate elements from a list.
					<delay>2</delay>
					Using the distinct method.
					<delay>2</delay>
					If we have a list of cities and we want to remove duplicates from that list it can be done in a 
					single line 
					List&lt;String&gt; cityList = new ArrayList&lt;&gt;();<break/> 
					cityList.add("Delhi");<break/> 
					cityList.add("Mumbai");<break/> 
					cityList.add("Bangalore");<break/> 
					cityList.add("Chennai");<break/> 
					cityList.add("Kolkata");<break/> 
					cityList.add("Mumbai");<break/> 
					cityList = cityList.stream().distinct().collect(Collectors.toList());<break/>
				</li>
				<li>
					Here is my answer without using any other data structure like set or hashmap etc.
					<delay>2</delay>
					public static &lt;T&gt; ArrayList&lt;T&gt; uniquefy(ArrayList&lt;T&gt; myList) {<break/>    
						ArrayList &lt;T&gt; uniqueArrayList = new ArrayList&lt;T&gt;();<break/>    
						for (int i = 0; i &lt; myList.size(); i++){<break/>        
							if (!uniqueArrayList.contains(myList.get(i))){<break/>            
								uniqueArrayList.add(myList.get(i));<break/>        
							}<break/>    
						}<break/>    
						return uniqueArrayList;<break/>
					}<break/>
				</li>
				<li>
					In Java, List permits ordered access of their elements.
					<delay>2</delay>
					They can have duplicates because their lookup key is the position not some hash code, every 
					element can be modified while they remain in the list where as Set represents a collection of 
					unique elements and while elements are in set, they must not be modified.
					<delay>2</delay>
					While there is no restriction preventing you from modifying elements in a set, if an element is 
					modified, then it could become forever lost in the set.
					<delay>2</delay>
					public static void main(String[] args) {  <break/>           
						List&lt;String&gt; l = new ArrayList&lt;String&gt;();  <break/>           
						l.add("A");  <break/>           
						l.add("B");  <break/>           
						l.add("C");  <break/>           
						l.add("A");  <break/>           
						System.out.println("Before removing duplicates: ");  <break/>           
						for (String s : l) {  <break/>                
							System.out.println(s);  <break/>           
						}  <break/>           
						Set&lt;String&gt; set = new HashSet&lt;String&gt;(l);  <break/>           
						List&lt;String&gt; newlist = new ArrayList&lt;String&gt;(set);  <break/>           
						System.out.println("after removing duplicates: ");  <break/>           
						for (String s : newlist) {  <break/>                
							System.out.println(s);  <break/>           
						}  <break/>     
					}  <break/>
				</li>
				<li>
					If you're willing to use a third-party library, you can use the method distinct() in Eclipse 
					Collections (formerly GS Collections).
					<delay>2</delay>
					ListIterable&lt;Integer&gt; integers = FastList.newListWith(1, 3, 1, 2, 2, 1);<break/>
					Assert.assertEquals(<break/>    
					FastList.newListWith(1, 3, 2),<break/>    
					integers.distinct());<break/>
					<delay>2</delay>
					The advantage of using distinct() instead of converting to a Set and then back to a List is that distinct() preserves the order of the original List, retaining the first occurrence of each element.
					<delay>2</delay>
					It's implemented by using both a Set and a List.
					<delay>2</delay>
					MutableSet&lt;T&gt; seenSoFar = UnifiedSet.newSet();<break/>
					int size = list.size();<break/>
					for (int i = 0; i &lt; size; i++){<break/>    
						T item = list.get(i);<break/>    
						if (seenSoFar.add(item)){<break/>        
							targetCollection.add(item);<break/>
						}<break/>
					}<break/>
					return targetCollection;<break/>
					<delay>2</delay>
					If you cannot convert your original List into an Eclipse Collections type, you can use ListAdapter to get the same API.
					<delay>2</delay>
					MutableList&lt;Integer&gt; distinct = ListAdapter.adapt(integers).distinct();<break/>
				</li>
				<li>
					If you want your list to automatically ignore duplicates and preserve its order, you could 
					create a HashList(a HashMap embedded List).
					<delay>2</delay>
					public static class HashList&lt;T&gt; extends ArrayList&lt;T&gt;{<break/>        
						private HashMap &lt;T,T&gt; hashMap;<break/>        
						public HashList(){<break/>            
							hashMap=new HashMap&lt;&gt;();<break/>        
						}<break/>        
						@Override<break/>        
						public boolean add(T t){<break/>            
							if(hashMap.get(t)==null){<break/>                
								hashMap.put(t,t);<break/>                
								return super.add(t);<break/>            
							}else return false;<break/>        
						}<break/>        
						@Override<break/>        
						public boolean addAll(Collection&lt;? extends T&gt; c){<break/>            
							HashList&lt;T&gt; addup=(HashList&lt;T&gt;)c;<break/>            
							for(int i=0;i&lt;addup.size();i++){<break/>                
								add(addup.get(i));<break/>            
							}return true;<break/>        
						}<break/>    
					}<break/>
					Usage Example:
					HashList&lt;String&gt; hashlist=new HashList&lt;&gt;();<break/>
					hashList.add("hello");<break/>
					hashList.add("hello");<break/>
					System.out.println(" HashList: "+hashlist);<break/>
					</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ remove repeated elements ^ arraylist ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ arraylist ^ remove ^ repeated ^</pattern>
		<template><srai>^ remove repeated elements ^ arraylist</srai></template> 
	</category>
	<category>
		<pattern>^ remove ^ repeated ^ arraylist ^</pattern>
		<template><srai>^ remove repeated elements ^ arraylist</srai></template> 
	</category>
	<category>
		<pattern>^ remove ^ duplicated ^ arraylist ^</pattern>
		<template><srai>^ remove repeated elements ^ arraylist</srai></template> 
	</category>
	<category>
		<pattern>
			<!-- 2. How can I see if an element in an int array is empty? -->
			^ see ^ element ^ int array ^ empty ^
		</pattern>
		<template>
			<random>
				<li>
					There is no such thing as an "empty" element in a Java array.
					<delay>2</delay>
					If the array's length is at least six, then element 5 exists and it has a value.
					<delay>2</delay>
					If you have not assigned anything else to that location, then it will have the value zero, 
					just like an object's uninitialized field would have.
					<delay>2</delay>
					If it is an array of Object descendants, then you can check whether the element is equal to null.
					<delay>2</delay>
				</li>
				<li>
					Elements in primitive arrays can't be empty.  
					<delay>2</delay>
					They'll always get initialized to something (usually 0 for int arrays, but depends on how you declare the array).
					<delay>2</delay>
					If you declare the array like so (for example):
					int [] myArray ;<break/>myArray = new int[7] ;<break/>
					then all of the elements will default to 0.
					<delay>2</delay>
					An alternative syntax for declaring arrays is
					int[] myArray = { 12, 7, 32, 15, 113, 0, 7 };<break/>
					where the initial values for an array (of size seven in this case) are given in the curly braces {}.
				</li>
				<li>
					You have to define what you mean by empty.
					<delay>2</delay>
					Depending on the datatype of the array you can decide on the semantics of empty.
					<delay>2</delay>
					For example, if you have an array of ints you can decide that 0 is empty.
					<delay>2</delay>
					Or if the array is of reference types then you can decide that null is empty.
					<delay>2</delay>
					Then you simply check by comparing array[5] == null or array[5] == 0
				</li>
				<li>
					Primitive arrays (int, float, char, etc) are never "empty" (by which I assume you mean "null"), 
					because primitive array elements can never be null.
					<delay>2</delay>
					By default, an int array usually contains 0 when allocated.  
					<delay>2</delay>
					However, I never rely on this (spent too much time writing C code, I guess).
					<delay>2</delay>
					One way is to pick a value that you want to treat as "uninitialized".  
					<delay>2</delay>
					It could be 0, or -1, or some other value that you're not going to use as a valid value.  
					<delay>2</delay>
					Initialize your array to that value after allocating it.
					<delay>2</delay>
					Object arrays (String[] and any array of objects that extend Object), can have null elements, so you could create an Integer[] array and initialize it to nulls.
					<delay>2</delay>
					I think I like that idea better than using a magic value as described above.
					<delay>2</delay>
				</li>
				<li>
					Create a constant to define the empty value, eg:
					private static final int EMPTY = -1;<break/>
					then create the array like this:
					<delay>2</delay>
					int[] myArray = new int[size];<break/>
					Arrays.fill(myArray, EMPTY);<break/>
					then to check if an element is 'empty', do this:
					if (myArray[i] == EMPTY){<break/>   
						//element i is empty<break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ see ^ element ^ int array ^ empty ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ element ^ int array ^ empty ^</pattern>
		<template><srai>^ see ^ element ^ int array ^ empty ^</srai></template>
	</category>
	<category>
		<pattern>^ int array ^ element ^ empty ^</pattern>
		<template><srai>^ see ^ element ^ int array ^ empty ^</srai></template>
	</category>
	<category>
		<pattern>^ element ^ empty ^ int array ^</pattern>
		<template><srai>^ see ^ element ^ int array ^ empty ^</srai></template>
	</category>
	<category>
		<pattern>^ item ^ empty ^ int array ^</pattern>
		<template><srai>^ see ^ element ^ int array ^ empty ^</srai></template>
	</category>
	<category>
		<pattern>^ item ^ int array ^ empty ^</pattern>
		<template><srai>^ see ^ element ^ int array ^ empty ^</srai></template>
	</category>
	<category>	
		<pattern>
			<!-- 3. Is there a Java array/list which is statically typed AND variable length -->
			^ array ^ list ^ statically typed ^ variable length ^
		</pattern>
		<template>
			<random>
				<li>
					If by "variable length" you mean that the size will change over time, then you probably want a 
					LinkedList rather than an ArrayList:
					<delay>2</delay>
					print("List&lt;Foo&gt; fooList = new LinkedList&lt;Foo&gt;();");<break/>
					<delay>2</delay>
					That way you get better performance when adding a bunch of elements.
					<delay>2</delay>
				</li>
				<li>
					I think this is pretty easy:
					<delay>2</delay>
					List&lt;Foo&gt; fooList = new ArrayList&lt;Foo&gt;();<break/>
					<delay>2</delay>
					I guess you could define a class:
					<delay>2</delay>
					public class FooList extends ArrayList&lt;Foo&gt; {<break/>    
						...<break/>
					}<break/>
					if you want to avoid the angle brackets...
				</li>
				<li>
					If you use generics (java 5), you can avoid all casting with
					List&lt;String&gt; myList = new ArrayList&lt;String&gt;();<break/> 
					myList.add(" a test");<break/> 
					String temp = myList.get(0);<break/>
					Unless I am missing something in your question that should cover both needs.
					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ array ^ list ^ statically typed ^ variable length ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ array ^ list ^ statically typed ^ variable length ^</pattern>
		<template><srai>^ array ^ list ^ statically typed ^ variable length ^</srai></template>
	</category>
	<category>
		<pattern>^ array ^ statically typed ^ variable length ^</pattern>
		<template><srai>^ array ^ list ^ statically typed ^ variable length ^</srai></template>
	</category>
	<category>
		<pattern>^ list ^ statically typed ^ variable length ^</pattern>
		<template><srai>^ array ^ list ^ statically typed ^ variable length ^</srai></template>
	</category>
	<category>
		<pattern>^ variable length ^ statically typed ^ list ^</pattern>
		<template><srai>^ array ^ list ^ statically typed ^ variable length ^</srai></template>
	</category>
	<category>
		<pattern>
			<!-- 4. Java sort String array of file names by their extension -->
			^ sort string array ^ file names ^ extension ^
		</pattern>
		<template>
			<random>
				<li>
					If I remember correctly, the Arrays.sort(...) takes a Comparator&lt;> that it will use to do the 
					sorting.  
					<delay>2</delay>
					You can provide an implementation of it that looks at the extension part of the string.
				</li>
				<li>
					You can implement a custom Comparator of Strings.  
					<delay>2</delay>
					Make it sort them by the substring after the last index of '.'.  
					<delay>2</delay>
					Then pass in the comparator and your array into 
					Arrays.sort(stringArray, yourComparator);<break/>
					//  An implementation of the compare method<break/>
					public int compare(String o1, String o2) {<break/>    
						return o1.substring(o1.lastIndexOf('.')).compareTo(o2.substring(o2.lastIndexOf('.'));<break/>
					}<break/>
				</li>
				<li>
					Create a Comparator and compare the string extensions.
					<delay>2</delay>
					Take a look at the following
					<button>
						<text>Comparator example</text>
						<url>http://java.sun.com/j2se/1.4.2/docs/api/java/util/Comparator.html</url>
					</button>
					<delay>2</delay>
					Then pass in your List of strings to Arrays.sort(List, Comparator)
				</li>
				<li>
					Create your own Comparator that treats the strings as filenames and compares them based on the extensions.  
					<delay>2</delay>
					Then use Arrays.sort with the Comparator argument.
				</li>
				<li>
					If you just want to group the files by their extension and do not care about the actual alphabetical 
					order, you can use this:
					<delay>2</delay>
					I think the simplest thing you can do that also works when the filenname does not have a "." is to just reverse the names and compare them.

					<delay>2</delay>
					Arrays.sort(ary, new Comparator&lt;String&gt;() {<break/>    
						@Override<break/>    
						public int compare(String o1, String o2) {<break/>        
							String r1 = new StringBuffer(o1).reverse().toString();<break/>        
							String r2 = new StringBuffer(o2).reverse().toString();<break/>        
							return r1.compareTo(r2);<break/>    
						}<break/>
					});<break/>
					<delay>2</delay>
					Its a shame that java's string does not even have a reverse().
				</li>
				<li>
					Comparators are often hard to get exactly right, and the comparison key has to be generated for 
					every comparison which for most sorting algorithms mean O(n log n).  
					<delay>2</delay>
					Another approach is to create (key, value) pairs for each item you need to sort, put them in a 
					TreeMap, and then ask for the values as these are sorted according to the key.
					<delay>2</delay>
					For instance 
					import java.util.Arrays;<break/>
					import java.util.TreeMap;<break/>
					public class Bar {<break/>    
						public static void main(String[] args) {<break/>        
							TreeMap&lt;String, String&gt; m2 = new TreeMap&lt;String, String&gt;();<break/>        
							for (String string : Arrays.asList(new String[] { "#3", "#2", "#1" })) {<break/>            
								String key = string.substring(string.length() - 1);<break/>            
								String value = string;<break/>            
								m2.put(key, value);<break/>        
							}<break/>        
							System.out.println(m2.values());<break/>    
						}<break/>
					}<break/>
					<delay>2</delay>
					You should easily be able to adapt the key calculation to your problem.
					<delay>2</delay>
					This only calculates the key once per entry, hence O(n) - (but the sort is still O(n log n)).  
					<delay>2</delay>
					If the key calculation is expensive or n is large this might be quite measurable.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ java sort string array ^ file names ^ extension ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ sort ^ array ^ strings ^ file extension ^</pattern>
		<template><srai>^ sort string array ^ file names ^ extension ^</srai></template>
	</category>
	<category>
		<pattern>^ sort ^ strings ^ array ^ file extensions ^</pattern>
		<template><srai>^ sort string array ^ file names ^ extension ^</srai></template>
	</category>
	<category>
		<pattern>^ array ^ strings ^ sort ^ file extension ^</pattern>
		<template><srai>^ sort string array ^ file names ^ extension ^</srai></template>
	</category>
	<category>
		<pattern>
			<!-- 5. Do 2D arrays use more resources than 1D arrays in Java? -->
			^ 2d arrays use ^ resources ^ 1d arrays ^ java ^
		</pattern>
		<template>
			<random>
				<li>
					int[50][8] is 50 arrays of length 8<break/>
					int[8][50] is 8 arrays of length 50<break/>
					int[400] is one array 400<break/>
					<delay>2</delay>
					Each array has an overhead of about 16 bytes.
					<delay>2</delay>
					However, for the sizes you have here, it really doesn't matter.
					<delay>2</delay>
					You are not going to be saving much either way.
					<delay>2</delay>
				</li>
				<li>
					I suggest writing a small performance test for this with very large arrays to see the 
					actual difference.
					<delay>2</delay>
					In reality I don't think this would make the slightest difference.
					<delay>2</delay>
				</li>
				<li>
					Let assume the following arrays:
					<delay>2</delay>
					new int[50][8]<break/>
					new int[8][50]<break/>
					new int[400]
					<delay>2</delay>
					Now, I get this confused, but the way to remember is to think of new int[50][] which is valid.
					<delay>2</delay>
					So new int[50][8] is an array of 50 arrays of size 8 (51 objects).
					<delay>2</delay>
					new int[8][50] is an array of 8 arrays of size 50 (9 objects).
					<delay>2</delay>
					9 objects will have a lower overhead than 51.
					<delay>2</delay>
					new int[400] is just one object.
					<delay>2</delay>
					However, it at this size it probably doesn't make any measurable difference to the performance of 
					your program.
					<delay>2</delay>
					You might want to encapsulate the array(s) within an object that will allow you to change the 
					implementation and provide a more natural interface to client code.
					<delay>2</delay>
				</li>
				<li>
					Let assume the following arrays:
					<delay>2</delay>
					new int[50][8]<break/>
					new int[8][50]<break/>
					new int[400]
					In the first case you have one array object pointing to fifty array objects holding 8 int's.
					<delay>2</delay>
					So 1 + 50 array objects + fifty pointers in the first array object.
					<delay>2</delay>
					In the second case you have one array object pointing to 8 array objects holding 50 int's.
					<delay>2</delay>
					So 1 + 8 array objects + eight pointers in the first array object.  
					<delay>2</delay>
					Holding the int's is a wash. 
					<delay>2</delay>
					There is not a good way to evaluate CPU usage for this.
					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ 2d arrays use ^ resources ^ 1d arrays ^ java ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ 2d ^ 1d ^ usage</pattern>
		<template><srai>^ 2d arrays use ^ resources ^ 1d arrays ^ java ^</srai></template>
	</category>
	<category>
		<pattern>^ 1d ^ 2d ^ usage</pattern>
		<template><srai>^ 2d arrays use ^ resources ^ 1d arrays ^ java ^</srai></template>
	</category>
	<category>
		<pattern>^ resource ^ usage ^ 1d ^ 2d ^</pattern>
		<template><srai>^ 2d arrays use ^ resources ^ 1d arrays ^ java ^</srai></template>
	</category>
	<category>
		<pattern>^ resource ^ 1d ^ 2d ^</pattern>
		<template><srai>^ 2d arrays use ^ resources ^ 1d arrays ^ java ^</srai></template>
	</category>
	<category>
		<pattern>
			<!-- 6. Removing an element from an Array (Java) -->
			^ removing ^ element ^ array ^ java ^
		</pattern>
		<template>
			<random>
				<li>
					You can't remove an element from the basic Java array.
					<delay>2</delay>
					Take a look at various Collections and ArrayList instead.
					<delay>2</delay>
				</li>
				<li>
					Sure, create another array :)
					<delay>2</delay>
				</li>
				<li>
					Nice looking solution would be to use a List instead of array in the first place.
					<delay>2</delay>
					List.remove(index)<break/>
					<delay>2</delay>
					If you have to use arrays, two calls to System.arraycopy will most likely be the fastest.
					<delay>2</delay>
					Foo[] result = new Foo[source.length - 1];<break/>
					System.arraycopy(source, 0, result, 0, index);<break/>
					if (source.length != index) {<break/>    
						System.arraycopy(source, index + 1, result, index, source.length - index - 1);<break/>
					}<break/>
					Arrays.asList is also a good candidate for working with arrays, but it doesn't seem to support remove.
				</li>
				<li>
					Use an ArrayList:
					alist.remove(1); //removes the element at position 1<break/>
				</li>
				<li>
					I hope you use the java collection / java commons collections!
					<delay>2</delay>
					With an java.util.ArrayList you can do things like the following: 
					yourArrayList.remove(someObject);<break/>
					yourArrayList.add(someObject);<break/>
				</li>
				<li>
					Copy your original array into another array, without the element to be removed.
					<delay>2</delay>
					A simplier way to do that is to use a List, Set... and use the remove() method.
					<delay>2</delay>
				</li>
				<li>
					Swap the item to be removed with the last item, if resizing the array down is not an interest.
					<delay>2</delay>
				</li>
				<li>
					
					The best choice would be to use a collection, but if that is out for some reason, use arraycopy.
					<delay>2</delay>
					You can use it to copy from and to the same array at a slightly different offset.
					<delay>2</delay>
					For example:
					public void removeElement(Object[] arr, int removedIdx) {<break/>    
						System.arraycopy(arr, removedIdx + 1, arr, removedIdx, arr.length - 1 - removedIdx);<break/>
					}<break/>
					<delay>2</delay>
					ArrayList or the apache utils) will use this method under the covers.  
					<delay>2</delay>
					Also, you REALLY should be using ArrayList (or linked list if you delete from the middle a lot) 
					so this shouldn't even be an issue unless you are doing it as homework.
					<delay>2</delay>
					To allocate a collection (creates a new array), then delete an element (which the collection will 
					do using arraycopy) then call toArray on it (creates a SECOND new array) for every delete brings 
					us to the point where it's not an optimizing issue, it's criminally bad programming.
					<delay>2</delay>
					Suppose you had an array taking up, say, 100mb of ram.
					<delay>2</delay>
					Now  you want to iterate over it and delete 20 elements.
					<delay>2</delay>
					I know you ASSUME that it's not going to be that big, or that if you were deleting that many at 
					once you'd code it differently, but I've fixed an awful lot of code where someone made assumptions 
					like that.
					<delay>2</delay>
				</li>
				<li>
					You could use the ArrayUtils API to remove it in a "nice looking way".
					<delay>2</delay>
					It implements many operations (remove, find, add, contains,etc) on Arrays.
				</li>
				<li>
					I think the question was asking for a solution without the use of the Collections API.
					<delay>2</delay>
					One uses arrays either for low level details, where performance matters, or for a loosely coupled SOA integration.
					<delay>2</delay>
					In the later, it is OK to convert them to Collections and pass them to the business logic as that.

					<delay>2</delay>
					For the low level performance stuff, it is usually already obfuscated by the quick-and-dirty 
					imperative state-mingling by for loops, etc.
					<delay>2</delay>
					In that case converting back and forth between Collections and arrays is cumbersome, unreadable, and 
					even resource intensive.
					
					<delay>2</delay>
					public char[] remove(char[] symbols, char c)<break/>{<break/>    
						for (int i = 0; i &lt; symbols.length; i++){<break/>        
							if (symbols[i] == c){<break/>            
								char[] copy = new char[symbols.length-1];<break/>            
								System.arraycopy(symbols, 0, copy, 0, i);<break/>            
								System.arraycopy(symbols, i+1, copy, i, symbols.length-i-1);<break/>            
								return copy;<break/>        
							}<break/>    
						}<break/>    
						return symbols;<break/>
					}<break/>
				</li>
				<li>
					You can not change the length of an array, but you can change the values the index holds by 
					copying new values and store them to a existing index number.
					<delay>2</delay>
					Object[] array = new Object[10];<break/>
					int count = -1;<break/>
					public void myFunction(String string) {<break/>    
						count++;<break/>    
						if(count == array.length) { <break/>        
							count = 0;  // overwrite first<break/>    
						}<break/>    
						array[count] = string;    <break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ removing ^ element ^ array ^ java ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ array ^ remove ^ element ^</pattern>
		<template><srai>^ removing ^ element ^ array ^ java ^</srai></template>
	</category>
	<category>
		<pattern>^ array ^ remove ^ item ^</pattern>
		<template><srai>^ removing ^ element ^ array ^ java ^</srai></template>
	</category>
	<category>
		<pattern>^ remove ^ arrray ^ item ^</pattern>
		<template><srai>^ removing ^ element ^ array ^ java ^</srai></template>
	</category>
	<category>
		<pattern>^ remove ^ arrray ^ element ^</pattern>
		<template><srai>^ removing ^ element ^ array ^ java ^</srai></template>
	</category>
	<category>
		<pattern>^ delete ^ arrray ^ element ^</pattern>
		<template><srai>^ removing ^ element ^ array ^ java ^</srai></template>
	</category>
	<category>
		<pattern>^ delete ^ arrray ^ item ^</pattern>
		<template><srai>^ removing ^ element ^ array ^ java ^</srai></template>
	</category>
	<category>
		<pattern>^ array ^ delete ^ item ^</pattern>
		<template><srai>^ removing ^ element ^ array ^ java ^</srai></template>
	</category>
	<category>
		<pattern>^ arrray ^ remove ^ item ^</pattern>
		<template><srai>^ removing ^ element ^ array ^ java ^</srai></template>
	</category>
	<category>
		<pattern>^ cancel ^ arrray ^ item ^</pattern>
		<template><srai>^ removing ^ element ^ array ^ java ^</srai></template>
	</category>
	<category>
		<pattern>
			<!-- 7. Converting a Bidimensional Array (Numbers) Into A Dimensional Array and Viceversa on Java -->
			^ converting ^ bidimensional array ^ dimensional array ^ viceversa ^
		</pattern>
		<template>
			<random>
				<li>
					Do you mean something like this?
					<delay>2</delay>
					import java.util.*; <break/>
					public class Test {<break/>    
					public static void main(String[] args) {<break/>        
						String[][] data = new String[][] {<break/>            
							{ "Foo", "Bar" },<break/>            
							{ "A", "B" }<break/>        
						};<break/>        
						String[] flattened = flatten(data);<break/>        
						for (String x : flattened) {<break/>            
							System.out.println(x);<break/>        
						}<break/>    
					}<break/>    
					public static &lt;T&gt; T[] flatten(T[][] source) {<break/>        
						int size = 0;<break/>        
						for (int i=0; i &lt; source.length; i++) {<break/>            
							size += source[i].length;<break/>        
						}<break/>        
						// Use the first subarray to create the new big one<break/>        
						T[] ret = Arrays.copyOf(source[0], size);<break/>        
						int index = source[0].length;<break/>        
						for (int i=1; i &lt; source.length; i++) {<break/>            
							System.arraycopy(source[i], 0, ret, index, source[i].length);<break/>            
							index += source[i].length;<break/>        
						}<break/>        
						return ret;<break/>    
					}<break/>
					<delay>2</delay>
					If you want it for primitive types, you'll have to write an overload for each primitive type, 
					but you can use new int[size] instead of Arrays.copyOf at that point.
				</li>
				<li>
					A Java 8 solution could look something like this:
					import java.util.stream.Stream;<break/>
					public class ArrayConverter {<break/>
						public static String[] flatten(String[][] array) {<break/>    
							// Create a stream of the given array<break/>    
							return Stream.of(array)<break/>            
							// Map each of its elements to a stream (thus creating a<break/>            
							// one-dim-array inside the stream, so to say)<break/>            
							.flatMap(Stream::of)<break/>            
							// Retrieve the stream as array, explicitly calling String to<break/>            
							// keep the type<break/>            
							.toArray(size -&gt; new String[size]);<break/>
						}<break/>
					}<break/>
					<delay>2</delay>
					I consciously left out generic types in this example since it makes the Array Initialization 
					somewhat confusing.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ converting ^ bidimensional array ^ numbers ^ dimensional array ^ viceversa ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ converting ^ 2d array ^ numbers ^ 1d array ^ viceversa ^</pattern>
		<template><srai>^ converting ^ bidimensional array ^ numbers ^ dimensional array ^ viceversa ^</srai></template>
	</category>
	<category>
		<pattern>^ convert ^ 2d array ^ numbers ^ 1d array ^ viceversa ^</pattern>
		<template><srai>^ converting ^ bidimensional array ^ numbers ^ dimensional array ^ viceversa ^</srai></template>
	</category>
	<category>
		<pattern>^ convert ^ 2d array ^ 1d array ^ viceversa ^</pattern>
		<template><srai>^ converting ^ bidimensional array ^ numbers ^ dimensional array ^ viceversa ^</srai></template>
	</category>
	<category>
		<pattern>^  2d array ^ numbers ^ 1d array ^ viceversa ^</pattern>
		<template><srai>^ converting ^ bidimensional array ^ numbers ^ dimensional array ^ viceversa ^</srai></template>
	</category>
	<category>
		<pattern>^ 1d array ^ numbers ^ 2d array ^ viceversa ^</pattern>
		<template><srai>^ converting ^ bidimensional array ^ numbers ^ dimensional array ^ viceversa ^</srai></template>
	</category>
	<category>
		<pattern>
			<!-- 8. How to get the last value of an ArrayList -->
			^ get ^ last value ^ arraylist ^
		</pattern>
		<template>
			<random>
				<li>
					This should do it:
					if (arrayList != null &amp;&amp; !arrayList.isEmpty()) {<break/>  
						T item = arrayList.get(arrayList.size()-1);<break/>
					}<break/>
				</li>
				<li>
					The following is part of the List interface (which ArrayList implements):
					<delay>2</delay>
					E e = list.get(list.size() - 1);<break/>
					E is the element type.
					<delay>2</delay>
					If the list is empty, get throws an IndexOutOfBoundsException.
					<delay>2</delay>
					You can find the whole API documentation here
					<button>
						<text>API documentation</text>
						<url>https://docs.oracle.com/javase/6/docs/api/</url>
					</button>
					<delay>2</delay>
				</li>
				<li>
					The size() method returns the number of elements in the ArrayList.  
					<delay>2</delay>
					The index values of the elements are 0 through (size()-1), so you would use myArrayList.get(myArrayList.size()-1) 
					to retrieve the last element.
					<delay>2</delay>
				</li>
				<li>
					If you modify your list, then use listIterator() and iterate from last index 
					(that is size()-1 respectively).
				</li>
				<li>
					I use micro-util class for getting last (and first) element of list:
					public final class Lists {<break/>    
						private Lists() {}<break/>    
						public static &lt;T&gt; T getFirst(List&lt;T&gt; list) {<break/>        
							return list != null &amp;&amp; !list.isEmpty() ? list.get(0) : null;<break/>    
						}<break/>    
						public static &lt;T&gt; T getLast(List&lt;T&gt; list) {<break/>        
							return list != null &amp;&amp; !list.isEmpty() ? list.get(list.size() - 1) : null;<break/>    
						}<break/>
					}<break/>
					<delay>2</delay>
					Slightly more flexible:
					<delay>2</delay>
					import java.util.List;<break/>
					public final class Lists {<break/>  
						private Lists() {}<break/>  
						public static &lt;T&gt; T getFirst( final List&lt;T&gt; list ) {<break/>    
							return getFirst( list, null );<break/>  
						}<break/>  
						public static &lt;T&gt; T getLast( final List&lt;T&gt; list ) {<break/>    
							return getLast( list, null );<break/>  
						}<break/>  
						public static &lt;T&gt; T getFirst( final List&lt;T&gt; list, final T t ) {<break/>    
							return isEmpty( list ) ? t : list.get( 0 );<break/>  
						}<break/>  
						public static &lt;T&gt; T getLast( final List&lt;T&gt; list, final T t ) {<break/>    
							return isEmpty( list ) ? t : list.get( list.size() - 1 );<break/>  
						}<break/>  
						public static &lt;T&gt; boolean isEmpty( final List&lt;T&gt; list ) {<break/>    
							return list == null || list.isEmpty();<break/>  
						}<break/>
					}<break/>
				</li>
				<li>
					If you can, swap out the ArrayList for an ArrayDeque, which has convenient methods like removeLast.
					<delay>2</delay>
				</li>
				<li>
					The last item in the list is list.size() - 1.
					<delay>2</delay>
					The collection is backed by an array and arrays start at index 0.
					<delay>2</delay>
					So element 1 in the list is at index 0 in the array 
					Element 2 in the list is at index 1 in the array
					Element 3 in the list is at index 2 in the array 
					and so on..
				</li>
				<li>
					All you need to do is use size() to get the last value of the Arraylist. 
					<delay>2</delay>
					For example:
					<delay>2</delay>
					if you ArrayList of integers, then to get last value you will have to
					int lastValue = arrList.get(arrList.size()-1);<break/>
					Remember, elements in an Arraylist can be accessed using index values.
					<delay>2</delay>
					Therefore, ArrayLists are generally used to search items.
					<delay>2</delay>
				</li>
				<li>
					Arrays store their size in a local variable called 'length'.  
					<delay>2</delay>
					Given an array named "a" you could use the following to reference the last index without knowing 
					the index value
					<delay>2</delay> 
					a[a.length-1]
					to assign a value of 5 to this last index you would use:
					a[a.length-1]=5;
				</li>
				<li>
					Using lambdas:
					<delay>2</delay>
					Function&lt;ArrayList&lt;T&gt;, T&gt; getLast = a -&gt; a.get(a.size() - 1);<break/>
				</li>
				<li>
					If you use a LinkedList instead , you can access the first element and the last one with 
					just getFirst() and getLast() (if you want a cleaner way than size() -1 and get(0))
					<delay>2</delay>
					Implementation
					Declare a LinkedList
					LinkedList&lt;Object&gt; mLinkedList = new LinkedList&lt;&gt;();<break/>
					<delay>2</delay>
					Then this are the methods you can use to get what you want, in this case we are talking about FIRST and LAST element of a list
					<delay>2</delay>
					public E getFirst() {<break/>        
						final Node&lt;E&gt; f = first;<break/>        
						if (f == null)<break/>            
							throw new NoSuchElementException();<break/>        
						return f.item;<break/>    
					}<break/>    
					@ublic E getLast() {<break/>        
						final Node&lt;E&gt; l = last;<break/>        
						if (l == null)<break/>            
							throw new NoSuchElementException();<break/>        
						return l.item;<break/>    
					}<break/>    
					public E removeFirst() {<break/>        
						final Node&lt;E&gt; f = first;<break/>        
						if (f == null)<break/>            
							throw new NoSuchElementException();<break/>        
						return unlinkFirst(f);<break/>    
					}<break/>    
					public E removeLast() {<break/>        
						final Node&lt;E&gt; l = last;<break/>        
						if (l == null)<break/>            
							throw new NoSuchElementException();<break/>        
						return unlinkLast(l);<break/>    
					}<break/>    
					public void addFirst(E e) {<break/>        
						linkFirst(e);<break/>    
					}<break/>    
					public void addLast(E e) {<break/>        
						linkLast(e);<break/>    
					}<break/>
					So , then you can use 
					mLinkedList.getLast(); <break/>
					to get the last element of the list.
				</li>
				<li>
					There is no elegant way of getting the last element of a list in Java (compared to e.g. items[-1] 
					in Python).
					<delay>2</delay>
					You have to use list.get(list.size()-1).
					<delay>2</delay>
					When working with lists obtained by complicated method calls, the workaround lies in temporary 
					variable:
					<delay>2</delay>
					List&lt;E&gt; list = someObject.someMethod(someArgument, anotherObject.anotherMethod());<break/>
					return list.get(list.size()-1);<break/>
					This is the only option to avoid ugly and often expensive or even not working version:
					<delay>2</delay>
					return someObject.someMethod(someArgument, anotherObject.anotherMethod()).get(<break/>    
					someObject.someMethod(someArgument, anotherObject.anotherMethod()).size() - 1<break/>);<break/>
					It would be nice if fix for this design flaw was introduced to Java API.
				</li>
				<li>
					Since the indexing in ArrayList starts from 0 and ends one place before the actual size 
					hence the correct statement to return the last arraylist element would be:
					int last = mylist.get(mylist.size()-1);
					<delay>2</delay>
					For example:
					if size of array list is 5, then size-1 = 4 would return the last array element.
				</li>
				<li>
					In case you have a spring project, you can also use the CollectionUtils.lastElement from 
					Spring (javadoc) and you don't need to add an extra dependency like Google Guave if you didn't 
					need to before.
					<delay>2</delay>
					It is null-safe so if you pass null, you will simply receive null in return.
					<delay>2</delay>
					Be careful when handling the response though.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ get ^ last value ^ arraylist ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ retrieve ^ last value ^ arraylist ^</pattern>
		<template><srai>^ get ^ last value ^ arraylist ^</srai></template>
	</category>
	<category>
		<pattern>^ arraylist ^ get ^ last value</pattern>
		<template><srai>^ get ^ last value ^ arraylist ^</srai></template>
	</category>
	<category>
		<pattern>^ last value ^ arraylist</pattern>
		<template><srai>^ get ^ last value ^ arraylist ^</srai></template>
	</category>
	<category>
		<pattern>^ get ^ last element ^ arraylist ^</pattern>
		<template><srai>^ get ^ last value ^ arraylist ^</srai></template>
	</category>
	<category>
		<pattern>^ last element ^ arraylist ^</pattern>
		<template><srai>^ get ^ last value ^ arraylist ^</srai></template>
	</category>
	<category>
		<pattern>^ arraylist ^ get ^ last elment</pattern>
		<template><srai>^ get ^ last value ^ arraylist ^</srai></template>
	</category>
	<category>
		<pattern>
			<!-- 9. Java array: direct access to component in array -->
			^ array ^ direct access ^ component 
		</pattern>
		<template>
			<random>
				<li>
					Yes, you can access an array component directly.
					<delay>2</delay>
					For example:
					String[] test = new String[] { "first", "second" };<break/>
					System.out.println(test[1]); // Prints second<break/>
				</li>
				<li>
					Surely you can use args[1] too.
				</li>
				<li>
					<delay>2</delay>
					You can do that, assuming args[1] exists, otherwise you'll get an ArrayIndexOutOfBoundsException.
					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ array ^ direct access ^ component ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ array ^ access ^ component ^</pattern>
		<template><srai>^ array ^ direct access ^ component ^</srai></template>
	</category>
	<category>
		<pattern>^ array ^ direct access ^ element ^</pattern>
		<template><srai>^ array ^ direct access ^ component ^</srai></template>
	</category>
	<category>
		<pattern>^ array ^ access ^ element ^</pattern>
		<template><srai>^ array ^ direct access ^ component ^</srai></template>
	</category>
	<category>
		<pattern>^ array ^ direct access ^ item ^</pattern>
		<template><srai>^ array ^ direct access ^ component ^</srai></template>
	</category>
	<category>
		<pattern>^ array ^ access ^ item ^</pattern>
		<template><srai>^ array ^ direct access ^ component ^</srai></template>
	</category>
	<category>
		<pattern>^ access ^ array ^ element ^</pattern>
		<template><srai>^ array ^ direct access ^ component ^</srai></template>
	</category>
	<category>
		<pattern>^ access ^ array ^ item ^</pattern>
		<template><srai>^ array ^ direct access ^ component ^</srai></template>
	</category>
	<category>
		<pattern>
			<!-- 10. How to check whether the elements of an ArrayList are all contained in another ArrayList -->
			^ check ^ elements ^ arraylist ^ contained ^ another ^
		</pattern>
		<template>
			<random>
				<li>
					Use Collection.containsAll():
					boolean isSubset = listA.containsAll(listB);<break/>
				</li>
				<li>
					There is a containsAll method in all collections.
					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ check ^ elements ^ arraylist ^ contained ^ another ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ arraylist elements ^ contained ^ another ^</pattern>
		<template><srai>^ check ^ elements ^ arraylist ^ contained ^ another ^</srai></template>
	</category>
	<category>
		<pattern>^ elements ^ arraylist ^ contained ^ another ^</pattern>
		<template><srai>^ check ^ elements ^ arraylist ^ contained ^ another ^</srai></template>
	</category>
	<category>
		<pattern>^ items ^ arraylist ^ contained ^ another ^</pattern>
		<template><srai>^ check ^ elements ^ arraylist ^ contained ^ another ^</srai></template>
	</category>
	<category>
		<pattern>^ arraylist items ^ contained ^ another ^</pattern>
		<template><srai>^ check ^ elements ^ arraylist ^ contained ^ another ^</srai></template>
	</category>
	<category>
		<pattern>
			<!-- 11. Java Iterate Bits in Byte Array -->
			^ iterate bits ^ byte array ^
		</pattern>
		<template>
			<random>
				<li>
					You'd have to write your own implementation of Iterable&lt;Boolean&gt; which took an array 
					of bytes, and then created Iterator&lt;Boolean&gt; values which remembered the current 
					index into the byte array and the current index within the current byte.
					<delay>2</delay>
					Then a utility method like this would come in handy:
					<delay>2</delay>
					private static Boolean isBitSet(byte b, int bit){<break/>    
						return (b &amp; (1 &lt;&lt; bit)) != 0;<break/>
					}<break/>
					(where bit ranges from 0 to 7).
					<delay>2</delay>
					Each time next() was called you'd have to increment your bit index within the current byte, 
					and increment the byte index within byte array if you reached "the 9th bit".
					<delay>2</delay>
					It's not really hard - but a bit of a pain.
				</li>
				<li>
					You can iterate through the byte array, and for each byte use the bitwise operators to iterate 
					though its bits.
				</li>
				<li>
					An alternative would be to use a BitInputStream like the one you can find here and write code 
					like this:
					BitInputStream bin = new BitInputStream(new ByteArrayInputStream(bytes));<break/>    
					while(true){<break/>        
						int bit = bin.readBit();<break/>        
						// do something<break/>    
					}<break/>
					bin.close();<break/>
					<delay>2</delay>
					(Note: Code doesn't contain EOFException or IOException handling for brevity.)
					<delay>2</delay>
				</li>
				<li>
					I know, probably not the "coolest" way to do it, but you can extract each bit with the 
					following code.
					<delay>2</delay>
					int n = 156;<break/>
					String bin = Integer.toBinaryString(n);<break/>
					System.out.println(bin);<break/>
					char arr[] = bin.toCharArray();<break/>
					for(int i = 0; i &lt; arr.length; ++i) {<break/>    
						System.out.println("Bit number " + (i + 1) + " = " + arr[i]);<break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ iterate bits ^ byte array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ iterate bits ^ byte array ^</pattern>
		<template><srai>^ iterate bits ^ byte array ^</srai></template>
	</category>
	<category>
		<pattern>^ loop bits ^ byte array ^</pattern>
		<template><srai>^ iterate bits ^ byte array ^</srai></template>
	</category>
	<category>
		<pattern>^ cycle bits ^ byte array ^</pattern>
		<template><srai>^ iterate bits ^ byte array ^</srai></template>
	</category>
	<category>
		<pattern>^ byte array ^ iterate bits ^</pattern>
		<template><srai>^ iterate bits ^ byte array ^</srai></template>
	</category>
	<category>
		<pattern>^ byte array ^ cycle bits ^</pattern>
		<template><srai>^ iterate bits ^ byte array ^</srai></template>
	</category>
	<category>
		<pattern>^ byte array ^ iterate bits</pattern>
		<template><srai>^ iterate bits ^ byte array ^</srai></template>
	</category>
	<category>
		<pattern>
			<!-- 12. Is it more efficient to remove elements from an ArrayList or a LinkedList? -->
			^ efficient ^ remove elements ^ arraylist ^ linkedlist ^
		</pattern>
		<template>
			<random>
				<li>
					It is "easier" (that is, more efficient) to remove them from a LinkedList, because removal from 
					an ArrayList requires moving all subsequent elements to a new position in the list all 
					subsequent elements of the array must be assigned a new value.
					<delay>2</delay>
					With a linked list, only one pointer (or two, with a doubly-linked list) must be re-assigned.
					<delay>2</delay>
				</li>
				<li>
					Well, removal of an element from a (doubly-linked-)list is O(1).
					<delay>2</delay>
					But removal from an array will require that the remaining elements are shifted down one space 
					in the array, which is O(n).
					<delay>2</delay>
					That said, getting a specific element in a list by index is O(n), while getting a specific element 
					in an array by index is O(1).
					<delay>2</delay>
					So, the for actual removal, LinkedList will be better.
					<delay>2</delay>
					There is more info on Array's versus LinkedList here.
				</li>
				<li>
					ArrayList internally uses a dynamic array to store the elements so manipulation with 
					ArrayList is slow because it internally uses an array.
					<delay>2</delay>
					If any element is removed from the array, all the bits are shifted in memory while LinkedList 
					internally uses a doubly linked list to store the elements.
					<delay>2</delay>
					Manipulation with LinkedList is faster than ArrayList because it uses a doubly linked list, 
					so no bit shifting is required in memory.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ efficient ^ remove elements ^ arraylist ^ linkedlist ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ efficient ^ delete elements ^ arraylist ^ linkedlist ^</pattern>
		<template><srai>^ efficient ^ remove elements ^ arraylist ^ linkedlist ^</srai></template>
	</category>
	<category>
		<pattern>^ efficient ^ remove elements ^ linkedlist ^ arraylist ^</pattern>
		<template><srai>^ efficient ^ remove elements ^ arraylist ^ linkedlist ^</srai></template>
	</category>
	<category>
		<pattern>^ efficient ^ delete elements ^ linkedlist ^ arraylist ^</pattern>
		<template><srai>^ efficient ^ remove elements ^ arraylist ^ linkedlist ^</srai></template>
	</category>
	<category>
		<pattern>^ efficient ^ delete items ^ linkedlist ^ arraylist ^</pattern>
		<template><srai>^ efficient ^ remove elements ^ arraylist ^ linkedlist ^</srai></template>
	</category>
	<category>
		<pattern>^ efficient ^ remove items ^ linkedlist ^ arraylist ^</pattern>
		<template><srai>^ efficient ^ remove elements ^ arraylist ^ linkedlist ^</srai></template>
	</category>
	<category>
		<pattern>^ efficient ^ remove items ^ arraylist ^ linkedlist ^</pattern>
		<template><srai>^ efficient ^ remove elements ^ arraylist ^ linkedlist ^</srai></template>
	</category>
	<category>
		
		<pattern>
			<!-- 13. Java: how to convert HashMap to array -->
			^ convert ^ hashmap ^ array ^
		</pattern>
		<template>
			<random>
				<li>
					hashMap.keySet().toArray(); // returns an array of keys<break/>
					hashMap.values().toArray(); // returns an array of values<break/>
					<delay>2</delay>
					It should be noted that the ordering of both arrays may not be the same,
					See oxbow_lakes answer for a better approach for iteration when the pair key/values are needed.
					<delay>2</delay>
				</li>
				<li>
					If you want the keys and values, you can always do this via the entrySet:
					hashMap.entrySet().toArray(); // returns a Map.Entry&lt;K,V&gt;[]<break/>
					From each entry you can (of course) get both the key and value via the getKey and getValue methods
				</li>
				<li>
					You could try something like this:
					<delay>2</delay>
					Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();<break/>
					map.put("key1", "value1");<break/>
					map.put("key2", "value2");<break/>
					Object[][] twoDarray = new Object[map.size()][2];<break/>
					Object[] keys = map.keySet().toArray();<break/>
					Object[] values = map.values().toArray();<break/>
					for (int row = 0; row &lt; twoDarray.length; row++) {<break/>    
						twoDarray[row][0] = keys[row];<break/>    
						twoDarray[row][1] = values[row];<break/>
					}<break/> 
					for (int i = 0; i &lt; twoDarray.length; i++) {<break/>    
						for (int j = 0; j &lt; twoDarray[i].length; j++) {<break/>        
						System.out.println(twoDarray[i][j]);<break/>    
						}<break/>
					}<break/>
				</li>
				<li>
					If you have HashMap&lt;String, SomeObject&gt; hashMap then:
					hashMap.values().toArray();<break/>
					Will return an Object[].
					<delay>2</delay>
					If instead you want an array of the type SomeObject, you could use:
					hashMap.values().toArray(new SomeObject[0]);<break/>
					<delay>2</delay>
				</li>
				<li>
					To guarantee the correct order for each array of Keys and Values, use this (the other answers 
					use individual Sets which offer no guarantee as to order.
					<delay>2</delay>
					Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();<break/>
					String[] keys = new String[map.size()];<break/>
					Object[] values = new Object[map.size()];<break/>
					int index = 0;<break/>
					for (Map.Entry&lt;String, Object&gt; mapEntry : map.entrySet()) {<break/>    
						keys[index] = mapEntry.getKey();<break/>    
						values[index] = mapEntry.getValue();<break/>    
						index++;<break/>
					}<break/>
				</li>
				<li>
					You may try this:
					<delay>2</delay>
					public static String[][] getArrayFromHash(Hashtable&lt;String,String&gt; data){<break/>        
						String[][] str = null;
						{<break/>            
							Object[] keys = data.keySet().toArray();<break/>            
							Object[] values = data.values().toArray();<break/>            
							str = new String[keys.length][values.length];<break/>            
							for(int i=0;i&lt;keys.length;i++) {<break/>                
								str[0][i] = (String)keys[i];<break/>                
								str[1][i] = (String)values[i];<break/>            
							}<break/>        
						}<break/>        
						return str;<break/>    
					}<break/>
					<delay>2</delay>
					Here I am using String as return type.
					<delay>2</delay>
					You may change it to required return type by you.
					<delay>2</delay>
				</li>
				<li>
					This could be a way to do it:
					<delay>2</delay>
					HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();<break/>
					String[] stringValues= new String[hashMap.values().size()];<break/>
					hashMap.values().toArray(stringValues);<break/>
				</li>
				<li>
					If you are using Java 8+ and need a 2 dimensional Array, perhaps for TestNG data providers, 
					you can try:
					map.entrySet()<break/>    
						.stream()<break/>    
						.map(e -&gt; new Object[]{e.getKey(), e.getValue()})<break/>    
						.toArray(Object[][]::new);<break/>
					<delay>2</delay>
					If your Objects are Strings and you need a String[][], try:
					map.entrySet()<break/>    
						.stream()<break/>    
						.map(e -&gt; new String[]{e.getKey(), e.getValue().toString()})<break/>    
						.toArray(String[][]::new);<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ convert hashmap ^ array </postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ hashmap ^ array ^</pattern>
		<template><srai>^ convert hashmap ^ array ^</srai></template>
	</category>
	<category>
		<pattern>^ convert ^ hashmap ^ array ^</pattern>
		<template><srai>^ convert hashmap ^ array ^</srai></template>
	</category>
	<category>
		<pattern>^ hashmap ^ converted ^ array ^</pattern>
		<template><srai>^ convert hashmap ^ array ^</srai></template>
	</category>
	<category>
		<pattern>^ hashmap ^ transformed ^ array ^</pattern>
		<template><srai>^ convert hashmap ^ array ^</srai></template>
	</category>
	<category>
		<pattern>
			<!-- 14. Using generics for arrays -->
			^ using generics ^ arrays ^
		</pattern>
		<template>
			<random>
				<li>
					I don't think this is possible because an array is a basic datatype. 
					<delay>2</delay>
					But you can use a ArrayList to have something similar.
					<delay>2</delay>
					In most of the cases using a collection of some kind pays of very well.
					<delay>2</delay>
				</li>
				<li>
					No.
					<delay>2</delay>
					Arrays must have a compile-time type.
					<delay>2</delay>
				</li>
				<li>
					Arrays are already basic objects types, that is to say they're not a class that describes a 
					collection of other objects like ArrayList or HashMap.
					<delay>2</delay>
					You cannot have an array of generified types either.
					<delay>2</delay>
					The following is illegal in Java:
					<delay>2</delay>
					List&lt;String&gt;[] lists = new List&lt;String&gt;[ 10 ];<break/>
					<delay>2</delay>
					This is because arrays must be typed properly by the compiler, and since Java's generics 
					are subject to type erasure you cannot satisfy the compiler this way.
					<delay>2</delay>
				</li>
				<li>
					It's possible, but far from pretty.
					<delay>2</delay>
					In general, you're better of using the Collections framework instead.
					<delay>2</delay>
					See Sun's Generics tutorial, page 15, for a detailed explanation.
					<delay>2</delay>
				</li>
				<li>
					If I ever want to, say, refactor the elements of an array to a better type, like from 
					String to MyPairClass&lt;String, Integer&gt;, I tend to avoid the unchecked cast problem 
					by making an empty subclass that "bakes in" the generic parameters, e.g. 
					class Maguffin {<break/>    
						private static class StringIntegerPair extends MyPairClass&lt;String, Integer&gt; {<break/>        
							private static final long serialVersionUID = 1L;<break/>    
						};<break/>    
						...<break/>    
						private final StringIntegerPair[] horribleOldArray;<break/>    
						...<break/>
						<delay>2</delay>
						This nested class will probably also need constructors that delegate up to the generic type's 
						constructors, depending on what you do when adding new array elements.
						<delay>2</delay>
						When passing the elements out of the enclosing class, just cast them up to the generic type:
						...<break/>    
						MyPairClass&lt;String, Integer&gt; getSomethingFromTheArray(int index) {<break/>        
							return horribleOldArray[index];<break/>    
						}<break/>    
						...<break/>
					}<break/>
					All this being said, there should rarely be a need to do something like this if you are writing something 
					new from scratch.
					<delay>2</delay>
					The only real benefit of arrays over the Collections framework classes is that you can write them out as 
					literals, and this will no longer be an advantage come next year when Java 8 is released.
				</li>
				<li>
					If you mean having an array of List then the answer is no.
					<delay>2</delay>
					new List&lt;Number&gt;[10] is illegal in java.
					<delay>2</delay>
					questions like these could be answerable by searching it in Google alone or checking out the 
					official Generics tutorial
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ using generics ^ arrays ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ generics ^ arrays ^</pattern>
		<template><srai>^ using generics ^ arrays ^</srai></template>
	</category>
	<category>
		<pattern>^ generic ^ arrays ^</pattern>
		<template><srai>^ using generics ^ arrays ^</srai></template>
	</category>
	<category>
		<pattern>
			<!-- 15. How do I declare and initialize an array in Java? -->
			^ declare ^ initialize ^ array ^
		</pattern>
		<template>
			<random>
				<li>
					You can either use array declaration or array literal (but only when you declare and affect the 
					variable right away, array literals cannot be used for re-assigning an array). 
					<delay>2</delay>
					For primitive types: 
					int[] myIntArray = new int[3];<break/>
					int[] myIntArray = {1, 2, 3};<break/>
					int[] myIntArray = new int[]{1, 2, 3};<break/>// 
					Since Java 8<break/>
					<button>
						<text>Java 8 documentation</text>
						<url>https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html</url>
					</button>
					int [] myIntArray = IntStream.range(0, 100).toArray(); // From 0 to 99<break/>
					int [] myIntArray = IntStream.rangeClosed(0, 100).toArray(); // From 0 to 100<break/>
					int [] myIntArray = IntStream.of(12,25,36,85,28,96,47).toArray(); // The order is preserved.<break/>
					int [] myIntArray = IntStream.of(12,25,36,85,28,96,47).sorted().toArray(); // Sort <break/>
					For classes, for example String, it's the same:
					<delay>2</delay>
					String[] myStringArray = new String[3];<break/>
					String[] myStringArray = {"a", "b", "c"};<break/>
					String[] myStringArray = new String[]{"a", "b", "c"};<break/>
					<delay>2</delay>
					The third way of initializing is useful when you declare the array first and then initialize it.
					<delay>2</delay>
					The cast is necessary here.
					<delay>2</delay>
					String[] myStringArray;<break/>
					myStringArray = new String[]{"a", "b", "c"};<break/>
					<delay>2</delay>
				</li>
				<li>
					There are various ways in which you can declare an array in Java:
					float floatArray[]; // Initialize later<break/>
					int[] integerArray = new int[10];<break/>
					String[] array = new String[] {"a", "b"};<break/>
					<delay>2</delay>
					You can find more information in the Sun tutorial site and the JavaDoc.
				</li>
				<li>
					I find it is helpful if you understand each part:
					Type[] name = new Type[5];<break/>
					Type[] is the type of the variable called name ("name" is called the identifier).  
					<delay>2</delay>
					The literal "Type" is the base type, and the brackets mean this is the array type of that base.
					<delay>2</delay>
					Array types are in turn types of their own, which allows you to make multidimensional arrays like 
					Type[][] (the array type of Type[]).
					<delay>2</delay>
					The keyword new says to allocate memory for the new array.  
					<delay>2</delay>
					The number between the bracket says how large the new array will be and how much memory to allocate.
					<delay>2</delay>
					For instance, if Java knows that the base type Type takes 32 bytes, and you want an array of size 5, 
					it needs to internally allocate 32 * 5 = 160 bytes.
					<delay>2</delay>
					You can also create arrays with the values already there, such as
					int[] name = {1, 2, 3, 4, 5};<break/>
					which not only creates the empty space but fills it with those values.
					<delay>2</delay>
					Java can tell that the primitives are integers and that there are 5 of them, so the size of the array 
					can be determined implicitly.
					<delay>2</delay>
				</li>
				<li>
					Also, in case you want something more dynamic there is the List interface.  
					<delay>2</delay>
					This will not perform as well, but is more flexible:
					List&lt;String&gt; listOfString = new ArrayList&lt;String&gt;();<break/>
					listOfString.add("foo");<break/>
					listOfString.add("bar");<break/>
					String value = listOfString.get(0);<break/>
					assertEquals( value, "foo" );<break/>
				</li>
				<li>
					The following shows the declaration of an array, but the array is not initialized:
					int[] myIntArray = new int[3];<break/>
					<delay>2</delay>
					The following shows the declaration as well as initialization of the array:
					<delay>2</delay>
					int[] myIntArray = {1,2,3};<break/>
					<delay>2</delay>
					Now, the following also shows the declaration as well as initialization of the array:
					int[] myIntArray = new int[]{1,2,3};<break/>

					<delay>2</delay>
					But this third one shows the property of anonymous array-object creation which is pointed by 
					a reference variable "myIntArray", so if we write just "new int[]{1,2,3};" then this is how anonymous array-object can be created.

					If we just write:
					int[] myIntArray;<break/>
					this is not declaration of array, but the following statement makes the above declaration complete:
					myIntArray=new int[3];<break/>
				</li>
				<li>
					If you want to create arrays using reflections then you can do like this:
					int size = 3;<break/> int[] intArray = (int[]) Array.newInstance(int.class, size ); <break/>
				</li>
				<li>
					Take the primitive type int for example.
					<delay>2</delay>
					There are several ways to declare and int array:
					int[] i = new int[capacity];<break/>
					int[] i = new int[] {value1, value2, value3, etc};<break/>
					int[] i = {value1, value2, value3, etc};<break/>
					where in all of these, you can use int i[] instead of int[] i.
					<delay>2</delay>
					With reflection, you can use (Type[]) Array.newInstance(Type.class, capacity);
					Note that in method parameters, ... indicates variable arguments.
					<delay>2</delay>
					Essentially, any number of parameters is fine.
					<delay>2</delay>
					It's easier to explain with code:
					<delay>2</delay>
					public static void varargs(int fixed1, String fixed2, int... varargs) {...}<break/>...<break/>
					varargs(0, "", 100); // fixed1 = 0, fixed2 = "", varargs = {100}<break/>
					varargs(0, "", 100, 200); // fixed1 = 0, fixed2 = "", varargs = {100, 200};<break/>
					Inside the method, int0 is treated as a normal int1.
					<delay>2</delay>
					Note that when passing an int4 to a method (or any other int5), you cannot use the third way.
					<delay>2</delay>
					In the statement int6, the compiler assumes that the int7 means an int8.
					<delay>2</delay>
					But that is because you are declaring a variable.
					<delay>2</delay>
					When passing an array to a method, the declaration must either be int9 or int0.
					<delay>2</delay>
					Multidimensional Arrays
					<delay>2</delay>
					Multidimensional arrays are much harder to deal with.
					<delay>2</delay>
					Essentially, a 2D array is an array of arrays.
					<delay>2</delay>
					int1 means an array of int2s.
					<delay>2</delay>
					The key is that if an int3 is declared as int4, the maximum index is int5.
					<delay>2</delay>
					Essentially, a rectangular int6 is: int7
				</li>
				<li>
					Array is a sequential list of items
					int item = value;<break/>
					int [] one_dimensional_array = { value, value, value, .., value };<break/>
					int [][] two_dimensional_array ={<break/>  
						{ value, value, value, .. value },<break/>  
						{ value, value, value, .. value },<break/>    
						..     ..     ..        ..<break/>  
						{ value, value, value, .. value }<break/>
					};<break/>

					<delay>2</delay>
					If it's an object, then it's the same concept
					Object item = new Object();<break/>
					Object [] one_dimensional_array = { new Object(), new Object(), .. new Object() };<break/>
					Object [][] two_dimensional_array ={<break/>  
						{ new Object(), new Object(), .. new Object() },<break/>  
						{ new Object(), new Object(), .. new Object() },<break/>    
						..            ..               ..<break/>  
						{ new Object(), new Object(), .. new Object() }<break/>
					};<break/>

					<delay>2</delay>
					In case of objects, you need to either assign it to null to initialize them using new Type(..),
					<delay>2</delay>
					classes like String and Integer are special cases that will be handled as following
					String [] a = { "hello", "world" };<break/>
					String [] a = { new String({'h','e','l','l','o'}), new String({'w','o','r','l','d'}) };<break/>
					Integer [] b = { 1234, 5678 };<break/>
					<delay>2</delay>
					It's worthy to note that creating an int item = value;<break/>
					int [] one_dimensional_array = { value, value, value, .., value };<break/>
					int [][] two_dimensional_array ={<break/>  
						{ value, value, value, .. value },<break/>  
						{ value, value, value, .. value },<break/>    
						..     ..     ..        ..<break/>  
						{ value, value, value, .. value }<break/>
					};<break/>
					0 dimensional array is expensive in terms of Space.
					<delay>2</delay>
					Since when you create an int item = value;<break/>
					int [] one_dimensional_array = { value, value, value, .., value };<break/>
					int [][] two_dimensional_array =<break/>{<break/>  
						{ value, value, value, .. value },<break/>  
						{ value, value, value, .. value },<break/>    
						..     ..     ..        ..<break/>  
						{ value, value, value, .. value }<break/>
					};<break/>
					1 dimensional array with 
					int item = value;<break/>
					int [] one_dimensional_array = { value, value, value, .., value };<break/>
					int [][] two_dimensional_array ={<break/>  
						{ value, value, value, .. value },<break/>  
						{ value, value, value, .. value },<break/>    
						..     ..     ..        ..<break/>  
						{ value, value, value, .. value }<break/>
					};<break/>
					2 on all the dimensions, The total size of the array is bigger than 
					int item = value;<break/>
					int [] one_dimensional_array = { value, value, value, .., value };<break/>
					int [][] two_dimensional_array ={<break/>  
						{ value, value, value, .. value },<break/>  
						{ value, value, value, .. value },<break/>    
						..     ..     ..        ..<break/>  
						{ value, value, value, .. value }<break/>
					};<break/>
					3, since each array has a reference, and at the M-dimension there is an (M-1)-dimensional array of references.
					<delay>2</delay>
					The total size is as following
					int item = value;<break/>
					int [] one_dimensional_array = { value, value, value, .., value };<break/>
					int [][] two_dimensional_array ={<break/>  
						{ value, value, value, .. value },<break/>  
						{ value, value, value, .. value },<break/>    
						..     ..     ..        ..<break/>  
						{ value, value, value, .. value }<break/>
					};<break/>4
				</li>
				<li>
					This should do:
					<delay>2</delay>
					int[] SingleDimensionalArray = new int[2]<break/>
					int[][] MultiDimensionalArray = new int[3][4]<break/>
					<delay>2</delay>
				</li>
				<li>
					For creating arrays of class Objects you can use the java.util.ArrayList.
					<delay>2</delay>
					to define an array:
					public ArrayList&lt;ClassName&gt; arrayName;<break/>
					arrayName = new ArrayList&lt;ClassName&gt;();<break/>
					Assign values to the array:
					<delay>2</delay>
					arrayName.add(new ClassName(class parameters go here);<break/>
					Read from the array:
					<delay>2</delay>
					ClassName variableName = arrayName.get(index);<break/>
					<delay>2</delay>
					variableName is a reference to the array meaning that manipulating variableName will manipulate arrayName
					for loops:
					//repeats for every value in the array<break/>
					for (ClassName variableName : arrayName){<break/>}<break/>
					//Note that using this for loop prevents you from editing arrayName<break/>
					for loop that allows you to edit arrayName (conventional for loop): java.util.ArrayList0
				</li>
				<li>
					This is how you can declare and initialize ArrayList:
					private List&lt;String&gt; list = new ArrayList&lt;String&gt;(){{<break/>    
						add("e1");<break/>    
						add("e2");<break/>
					}};<break/>
				</li>
				<li>
					Declare and initialize for Java 8 and later.
					<delay>2</delay>
					Create a simple integer array:
					<delay>2</delay>
					int [] a1 = IntStream.range(1, 20).toArray();<break/>
					System.out.println(Arrays.toString(a1));<break/> 
					Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]<break/>

					Create a random array for integers between [-50, 50] and for doubles [0, 1E17]:
					int [] a2 = new Random().ints(15, -50, 50).toArray();<break/>
					double [] a3 = new Random().doubles(5, 0, 1e17).toArray();<break/>
					Power-of-two sequence:
					double [] a4 = LongStream.range(0, 7).mapToDouble(i -&gt; Math.pow(2, i)).toArray();<break/>
					System.out.println(Arrays.toString(a4));<break/>
					Output: [1.0, 2.0, 4.0, 8.0, 16.0, 32.0, 64.0]<break/>
					For String[] you must specify a constructor:
					String [] a5 = Stream.generate(()-&gt;"I will not squeak chalk").limit(5).toArray(String[]::new);<break/>
					System.out.println(Arrays.toString(a5));<break/>
					Multidimensional arrays:
					String [][] a6 = List.of(new String[]{"a", "b", "c"} , new String[]{"d", "e", "f", "g"})<break/>    
						.toArray(new String[0][]);<break/>
					System.out.println(Arrays.deepToString(a6));<break/>
					Output: [[a, b, c], [d, e, f, g]]<break/>
				</li>
				<li>
					In Java 9
					Using different IntStream.iterate and IntStream.takeWhile methods:
					int[] a = IntStream.iterate(10, x -&gt; x &lt;= 100, x -&gt; x + 10).toArray();<break/>
					Out: [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]<break/>
					int[] b = IntStream.iterate(0, x -&gt; x + 1).takeWhile(x -&gt; x &lt; 10).toArray();<break/>
					Out: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<break/>
					In Java 10
					Using the Local Variable Type Inference:
					var letters = new String[]{"A", "B", "C"};<break/>
				</li>
				<li>
					
					With local variable type inference you only have to specify the type once:
					var values = new int[] { 1, 2, 3 };<break/>
					Or
					int[] values = { 1, 2, 3 }<break/>
				</li>
				<li>
					If by &quot;array&quot; you meant using java.util.Arrays, you can do it like that :
					<delay>2</delay>
					List&lt;String&gt; number = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);<break/>
					Out: [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]<break/>
					<delay>2</delay>
					This one is pretty simple and straightforward.
				</li>
				<li>
					
					Declare Array: int[] arr;
					Initialize Array: int[] arr = new int[10]; 10
					<delay>2</delay>
					represents the number of elements allowed in the array
					Declare Multidimensional Array: int[][] arr;
					Initialize Multidimensional Array: int[][] arr = new int[10][17]; 10 rows and 17 columns and 170 
					elements because 10 times 17 is 170.
					<delay>2</delay>
					Initializing an array means specifying the size of it. 
				</li>
				<li>
					int[] x=new int[enter the size of array here];<break/>
					example: <break/>
					int[] x=new int[10];<break/>
					or<break/>
					int[] x={enter the elements of array here];<break/>
					example:<break/>
					int[] x={10,65,40,5,48,31};<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ declare ^ initialize ^ array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ declare ^ initialize ^ array ^</pattern>
		<template><srai>^ declare ^ initialize ^ array ^</srai></template>
	</category>
	<category>
		<pattern>^ create ^ initialize ^ array ^</pattern>
		<template><srai>^ declare ^ initialize ^ array ^</srai></template>
	</category>
	<category>
		<pattern>^ build ^ initialize ^ array ^</pattern>
		<template><srai>^ declare ^ initialize ^ array ^</srai></template>
	</category>
	<category>
		<pattern>
			<!-- 16. Convert InputStream to byte array in Java -->
			^ convert inputstream ^ byte array ^
		</pattern>
		<template>
			<random>
				<li>
					You need to read each byte from your InputStream and write it to a ByteArrayOutputStream. 
					<delay>2</delay>
					You can then retrieve the underlying byte array by calling toByteArray():
					InputStream is = ...<break/>
					ByteArrayOutputStream buffer = new ByteArrayOutputStream();<break/>
					int nRead;<break/>
					byte[] data = new byte[16384];<break/>
					while ((nRead = is.read(data, 0, data.length)) != -1) {<break/>  
						buffer.write(data, 0, nRead);<break/>
					}<break/>
					buffer.toByteArray();<break/>
				</li>
				<li>
					You can use Apache Commons IO to handle this and similar tasks.
					<delay>2</delay>
					The IOUtils type has a static method to read an InputStream and return a byte[].
					<delay>2</delay>
					InputStream is;<break/>byte[] bytes = IOUtils.toByteArray(is);<break/>
					Internally this creates a ByteArrayOutputStream and copies the bytes to the output, then calls 
					toByteArray().
					<delay>2</delay>
					It handles large files by copying the bytes in blocks of 4KiB.
				</li>
				<li>
					Below Codes
					public static byte[] serializeObj(Object obj) throws IOException {<break/>  
						ByteArrayOutputStream baOStream = new ByteArrayOutputStream();<break/>  
						ObjectOutputStream objOStream = new ObjectOutputStream(baOStream);<break/>  
						objOStream.writeObject(obj); <break/>  
						objOStream.flush();<break/>  
						objOStream.close();<break/>  
						return baOStream.toByteArray(); <break/>
					}<break/>
					OR<break/>
					BufferedImage img = ...<break/>
					ByteArrayOutputStream baos = new ByteArrayOutputStream(1000);<break/>
					ImageIO.write(img, "jpeg", baos);<break/>
					baos.flush();<break/>
					byte[] result = baos.toByteArray();<break/>
					baos.close();<break/>
				</li>
				<li>
					Do you really need the image as a byte[]?
					<delay>2</delay>
					What exactly do you expect in the byte[] - the complete content of an image file, encoded in 
					whatever format the image file is in, or RGB pixel values?
					<delay>2</delay>
					Other answers here show you how to read a file into a byte[].
					<delay>2</delay>
					Your byte[] will contain the exact contents of the file, and you'd need to decode that to do 
					anything with the image data.
					<delay>2</delay>
					Java's standard API for reading (and writing) images is the ImageIO API, which you can find in the package javax.imageio.
					<delay>2</delay>
					You can read in an image from a file with just a single line of code:
					BufferedImage image = ImageIO.read(new File("image.jpg"));<break/>
					<delay>2</delay>
					This will give you a BufferedImage, not a byte[].
					<delay>2</delay>
					To get at the image data, you can call getRaster() on the byte[]0.
					<delay>2</delay>
					This will give you a byte[]1 object, which has methods to access the pixel data (it has 
					several byte[]2 / byte[]3 methods).
					<delay>2</delay>
					Lookup the API documentation for byte[]4, byte[]5, byte[]6 etc.
					<delay>2</delay>
					ImageIO supports a number of image formats by default: JPEG, PNG, BMP, WBMP and GIF.
					<delay>2</delay>
					It's possible to add support for more formats (you'd need a plug-in that implements the ImageIO 
					service provider interface).
					<delay>2</delay>
					See also the following tutorial: Working with Images
				</li>
				<li>
					Input Stream is ...<break/>
					ByteArrayOutputStream bos = new ByteArrayOutputStream();<break/>
					int next = in.read();<break/>
					while (next &gt; -1) {<break/>    
						bos.write(next);<break/>    
						next = in.read();<break/>
					}<break/>
					bos.flush();<break/>
					byte[] result = bos.toByteArray();<break/>
					bos.close();<break/>
				</li>
				<li>
					Use vanilla Java's DataInputStream and its readFully Method (exists since at least Java 1.4):
					...<break/>
					byte[] bytes = new byte[(int) file.length()];<break/>
					DataInputStream dis = new DataInputStream(new FileInputStream(file));<break/>
					dis.readFully(bytes);<break/>...<break/>
					<delay>2</delay>
					There are some other flavors of this method, but I use this all the time for this use case.
				</li>
				<li>
					
					I tried to edit @numan's answer with a fix for writing garbage data but edit was rejected.
					<delay>2</delay>
					While this short piece of code is nothing brilliant I can't see any other better answer.
					<delay>2</delay>
					Here's what makes most sense to me:
					ByteArrayOutputStream out = new ByteArrayOutputStream();<break/>
					byte[] buffer = new byte[1024]; // you can configure the buffer size<break/>
					int length;<break/>
					while ((length = in.read(buffer)) != -1) out.write(buffer, 0, length); <break/>
					in.close(); // call this in a finally block<break/>
					byte[] result = out.toByteArray();<break/>
				</li>
				<li>
					This should work:<break/>
					public static byte[] getBytesFromInputStream(InputStream is) throws IOException {<break/>    
						ByteArrayOutputStream os = new ByteArrayOutputStream(); <break/>    
						byte[] buffer = new byte[0xFFFF];<break/>    
						for (int len = is.read(buffer); len != -1; len = is.read(buffer)) { <break/>        
							os.write(buffer, 0, len);<break/>    
						}<break/>    
						return os.toByteArray();<break/>
					}<break/>
				</li>
				<li>
					If you happen to use google guava, it'll be as simple as :
					byte[] bytes = ByteStreams.toByteArray(inputStream);<break/>
				</li>
				<li>
					You're doing an extra copy if you use ByteArrayOutputStream.
					<delay>2</delay>
					If you know the length of the stream before you start reading it (e.g. the InputStream is actually 
					a FileInputStream, and you can call file.length() on the file, <break/>
					or the InputStream is a zipfile entry InputStream, and you can call zipEntry.length()), 
					then it's far better to write directly into the byte[] array -- it uses half the memory, 
					and saves time.
					<delay>2</delay>
					// Read the file contents into a byte[] array<break/>
					byte[] buf = new byte[inputStreamLength];<break/>
					int bytesRead = Math.max(0, inputStream.read(buf));<break/>
					byte[] contents = bytesRead == inputStreamLength ? buf : Arrays.copyOf(buf, bytesRead);<break/>
					<delay>2</delay>
					the last line above deals with files getting truncated while the stream is being read, if you 
					need to handle that possibility, but if the file gets longer while the stream is being read, 
					the contents in the byte[] array will not be lengthened to include the new file content, the array 
					will simply be truncated to the old length inputStreamLength.
				</li>
				<li>
					See the InputStream.available() documentation:
					It is particularly important to realize that you must not use this
					method to size a container and assume that you can read the entirety
					of the stream without needing to resize the container.
					<delay>2</delay>
					Such callers should probably write everything they read to a ByteArrayOutputStream
					and convert that to a byte array.
					<delay>2</delay>
					Alternatively, if you're reading from a file, File.length returns the current length of the file
					(though assuming the file's length can't change may be incorrect reading a file is inherently racy).
				</li>
				<li>
					I use this.
					<delay>2</delay>
					public static byte[] toByteArray(InputStream is) throws IOException {<break/>        
						ByteArrayOutputStream output = new ByteArrayOutputStream();<break/>        
						try {<break/>            
							byte[] b = new byte[4096];<break/>            
							int n = 0;<break/>            
							while ((n = is.read(b)) != -1) {<break/>                
								output.write(b, 0, n);<break/>            
							}<break/>            
							return output.toByteArray();<break/>        
						} finally {<break/>            
							output.close();<break/>        
						}<break/>    
					}<break/>
				</li>
				<li>
					Java 7 and later:
					import sun.misc.IOUtils;<break/>...<break/>
					InputStream in = ...;<break/>
					byte[] buf = IOUtils.readFully(in, -1, false);<break/>
				</li>
				<li>
					Finally, after twenty years, theres a simple solution without the need for a 3rd party library, thanks to Java9:
					<delay>2</delay>
					InputStream is;<break/><break/>byte[] array = is.readAllBytes();<break/>
					Note also the convenience methods readNBytes(byte[] b, int off, int len) and transferTo(OutputStream) 
					addressing recurring needs.
				</li>
				<li>
					Java 9 will give you finally a nice method:
					InputStream in = ...;<break/>
					ByteArrayOutputStream bos = new ByteArrayOutputStream();<break/>
					in.transferTo( bos );<break/>
					byte[] bytes = bos.toByteArray();<break/>
				</li>
				<li>
					As always, also Spring framework (spring-core since 3.2.2) has something for you: 
					StreamUtils.copyToByteArray()
				</li>
				<li>
					In-case someone is still looking for a solution without dependency and If you have a file.
					<delay>2</delay>
					DataInputStream
					<delay>2</delay>
					byte[] data = new byte[(int) file.length()];<break/> 
					DataInputStream dis = new DataInputStream(new FileInputStream(file));<break/> 
					dis.readFully(data);<break/> 
					dis.close();<break/>
					<delay>2</delay>
					ByteArrayOutputStream
					<delay>2</delay>
					InputStream is = new FileInputStream(file);<break/> 
					ByteArrayOutputStream buffer = new ByteArrayOutputStream();<break/> 
					int nRead;<break/> 
					byte[] data = new byte[(int) file.length()];<break/> 
					while ((nRead = is.read(data, 0, data.length)) != -1) {<break/>     
						buffer.write(data, 0, nRead);<break/> 
					}<break/>
					RandomAccessFile
					<delay>2</delay>
					RandomAccessFile raf = new RandomAccessFile(file, &quot;r&quot;);<break/> 
					byte[] data = new byte[(int) raf.length()];<break/> 
					raf.readFully(data);<break/>
				</li>
				<li>
					In new Java version,
					IOUtils.readAllBytes(inputStream)<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ convert inputstream ^ byte array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ inputstream ^ byte array ^</pattern>
		<template><srai>^ convert inputstream ^ byte array ^</srai></template>
	</category>
	<category>
		<pattern>
			<!-- 17. When is an ArrayList preferable to an array in Java? -->
			^ arraylist preferable ^ array ^
		</pattern>
		<template>
			<random>
				<li>
					ArrayLists are useful when you don't know in advance the number of elements you will need.
					<delay>2</delay>
					Simple Example: you are reading a text file and builing a list of all the words you find.
					<delay>2</delay>
					You can just keep adding to your array list, it will grow.
					<delay>2</delay>
					Arrays you need to pre-declare their size.
					<delay>2</delay>
				</li>
				<li>
					An array has to be declared with a fixed size therefore you need to know the number of elements in 
					advance.
					<delay>2</delay>
					An ArrayList is preferable when you don't know how many elements you will need in advance as it 
					can grow as desired.
					<delay>2</delay>
					An ArrayList may also be preferable if you need to perform operations that are available in its 
					API that would required manual implementation for an array.
				</li>
				<li>
					Some differences:
					Arrays are immutable in their size, you cannot easly remove and element and remove the hole whereas using 
					an ArrayList is straightforward
					<delay>2</delay>
					Arrays are fast (handled directly by the JVM as special objects) than an ArrayList and requires 
					less memory 
					<delay>2</delay>
					Arrays have a nice syntax for accessing elements (e.g. a[i] vs a.get(i))
					<delay>2</delay>
					Arrays don't play well with generics (e.g. you cannot create a generic array)
					<delay>2</delay>
					Arrays cannot be easly wrapped as ArrayList (e.g. Collections utils like checkedList, synchronizedList 
					and unmodifiableList) declaring the ArrayList as List you can easly swap implementation with a 
					LinkedList when you need; this imho is the best advantage over plain arrays 
					<delay>2</delay>
					Array's toString, a[i]0 and a[i]1 are weird and error-prone, you must use Arrays class utilities
				</li>
				<li>
					When you want to change its size by adding or removing elements.
					<delay>2</delay>
					When you want to pass it to something that wants a Collection or Iterable (although you can use 
					Arrays.asList(a) to make an array, a, look like a List).
				</li>
				<li>
					Another couple of points:
					<delay>2</delay>
					You may want to consider using an array to represent more than one dimension (e.g. matrix).
					<delay>2</delay>
					Arrays can be used to store primitives and hence offer a more compact representation of your data 
					than using an ArrayList.
				</li>
				<li>
					It's not only about the fact that arrays need to grow, a collection is easier to deal with.
					<delay>2</delay>
					Sometimes arrays are fine, when you just need to iterate over elements, read-only.
					<delay>2</delay>
					However, most of the time you want to use methods like contains, etc. 
					<delay>2</delay>
					You can't create generic arrays
					<delay>2</delay>
					so it 'might' or might not bother you.
					<delay>2</delay>
					When in doubt, use Collections, it will make people that use your API love you :-).
					<delay>2</delay>
					If you only provide them with arrays, the first lines of code that they'll write is : 
					Arrays.asList(thatGuyArray);<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ arraylist preferable ^ array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ arraylist preferable ^ array ^</pattern>
		<template><srai>^ arraylist preferable ^ array ^</srai></template>
	</category>
	<category>
		<pattern>^ arraylist ^ better ^ array ^</pattern>
		<template><srai>^ arraylist preferable ^ array ^</srai></template>
	</category>
	<category>
		<pattern>^ array ^ better ^ arraylist ^</pattern>
		<template><srai>^ arraylist preferable ^ array ^</srai></template>
	</category>
	<category>
		<pattern>^  array ^ preferable ^ arraylist</pattern>
		<template><srai>^ arraylist preferable ^ array ^</srai></template>
	</category>
	<category>
		<pattern>
			<!-- 18. How do I populate a JComboBox with an ArrayList? -->
			^ populate ^ jcombobox ^ arraylist ^
		</pattern>
		<template>
			<random>
				<li>
					Use the toArray() method of the ArrayList class and pass it into the constructor of the JComboBox
					See the JavaDoc and tutorial for more info.
					<delay>2</delay>
				</li>
				<li>
					I think that this could be a solution 
					ArrayList&lt;table&gt; libel = new ArrayList&lt;table&gt;();<break/>
					try {<break/>
						SessionFactory sf = new Configuration().configure().buildSessionFactory();<break/>
						Session s = sf.openSession();<break/>
						s.beginTransaction();<break/>
						String hql = "FROM table ";<break/>
						org.hibernate.Query query = s.createQuery(hql);<break/>
						libel= (ArrayList&lt;table&gt;) query.list();<break/>
						Iterator it = libel.iterator();<break/>
						while(it.hasNext()) {<break/>
							table cat = (table) it.next();<break/>
							cat.getLibCat();//table colonm getter<break/>
							combobox.addItem(cat.getLibCat());<break/>
						}<break/>
						s.getTransaction().commit();<break/>
						s.close();<break/>
						sf.close();<break/>
					} catch (Exception e) {<break/>
					System.out.println("Exception in getSelectedData::"+e.getMessage());<break/>
				</li>
				<li>
					Elegant way to fill combo box with an array list :<break/>
					List&lt;String&gt; ls = new ArrayList&lt;String&gt;(); <break/>
					jComboBox.setModel(new DefaultComboBoxModel&lt;String&gt;(ls.toArray(new String[0])));<break/>
				</li>
				<li>
					I believe you can create a new Vector using your ArrayList and pass that to the 
					JCombobox Constructor.
					<delay>2</delay>
					JComboBox&lt;String&gt; combobox = new JComboBox&lt;String&gt;(new Vector&lt;String&gt;(myArrayList));<break/>
					<delay>2</delay>
					my example is only strings though.
				</li>
				<li>
					Check this simple code
					import java.util.ArrayList;<break/>
					import javax.swing.JComboBox;<break/>
					import javax.swing.JFrame;<break/>
					public class FirstFrame extends JFrame{<break/>
					    static JComboBox&lt;ArrayList&gt; mycombo;<break/>
					    FirstFrame()<break/>
					    {<break/>
					        this.setSize(600,500);<break/>
					        this.setTitle("My combo");<break/>
					        this.setLayout(null);<break/>
					        ArrayList&lt;String&gt; names=new ArrayList&lt;String&gt;();   <break/>
					        names.add("jessy");<break/>
					        names.add("albert");<break/>
					        names.add("grace");<break/>
					        mycombo=new JComboBox(names.toArray());<break/>
					        mycombo.setBounds(60,32,200,50);<break/>
					        this.add(mycombo);<break/>
					        this.setVisible(true); // window visible<break/>
					    }   <break/>
					    public static void main(String[] args) {<break/>
					        FirstFrame frame=new FirstFrame();  <break/>
					    }<break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ populate ^ jcombobox ^ arraylist ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ fill ^ jcombobox ^ arraylist ^</pattern>
		<template><srai>^ populate ^ jcombobox ^ arraylist ^</srai></template>
	</category>
	<category>
		<pattern>^ jcombobox ^ populate ^ arraylist ^</pattern>
		<template><srai>^ populate ^ jcombobox ^ arraylist ^</srai></template>
	</category>
	<category>
		<pattern>^ jcombobox ^ fill ^ arraylist ^</pattern>
		<template><srai>^ populate ^ jcombobox ^ arraylist ^</srai></template>
	</category>
	<category>
		<pattern>
			<!-- 19. Java: Copy array of non-primitive type -->
			^ copy array ^ non ^ primitive type ^
		</pattern>
		<template>
			<random>
				<li>
					System.arraycopy<break/>
					(which gives you the ability to copy arbitrary portions of an array via the offset 
					and length parameters).
					<delay>2</delay>
					<delay>2</delay>
					Or it can narrow a type:
					Number[] is = new Number[]{4, 5};<break/>
					Integer[] copy = Arrays.copyOf(is, is.length, Integer[].class);<break/>
					<delay>2</delay>
					Note that you can also use the clone method on an array:
					Number[] other = is.clone();<break/>
				</li>
				<li>
					The old school way was:
					public static void java.lang.System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)<break/>
					<delay>2</delay>
					This copys from one existing array to another.  
					<delay>2</delay>
					You have to allocate the new array yourself ...
					<delay>2</delay>
					assuming that you are making a copy of an array.
					<delay>2</delay>
					From JDK 6 onwards, the java.util.Arrays class has a number of copyOf methods 
					for making copies of arrays, with a new size.  
					<delay>2</delay>
					The ones that are relevant are:
					public static &lt;T&gt; T[] copyOf(T[] original, int newLength)<break/>
					and
					public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType)<break/>
					This first one makes a copy using the original array type, and the second 
					one makes a copy with a different array type.
					<delay>2</delay>
					Note that both arraycopy and the 3 argument copyOf have to check the types 
					of each of the elements in the original (source) array against the target array type.  
					<delay>2</delay>
					So both can throw type exceptions.  
					<delay>2</delay>
					The 2 argument copyOf (in theory at least) does not need to do any type checking 
					and therefore should be (in theory) faster.  
					<delay>2</delay>
					In practice the relative performance will be implementation dependent.  
					<delay>2</delay>
					For instance, arraycopy is often given special treatment by the JVM.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ copy array ^ non ^ primitive type ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ copy ^ array ^ non ^ primitive type ^</pattern>
		<template><srai>^ copy array ^ non ^ primitive type ^</srai></template>
	</category>
	<category>
		<pattern>^ copy ^ non ^ primitive type ^ array ^</pattern>
		<template><srai>^ copy array ^ non ^ primitive type </srai></template>
	</category>
	<category>
		<pattern>
			<!-- 20. Java ( Counting Distinct Integers ) -->
			^ counting distinct integers ^
		</pattern>
		<template>
			<random>
				<li>
					A set stores each unique (as defined by .equals ()) element in it only once, 
					and you can use this to simplify the problem.
					<delay>2</delay>
					Create a Set (I'd use a HashSet), iterate your array, adding each integer 
					to the Set, then return .size() of the Set.
				</li>
				<li>
					Set&lt;Integer&gt; s = new HashSet&lt;Integer&gt;();<break/>
					for (int i : a) s.add(i);<break/>
						int distinctCount = s.size();<break/>
				</li>
				<li>
					An efficient method:
					<delay>2</delay>
					Sort the array with Arrays.sort.
					<delay>2</delay>
					Write a simple loop to count up adjacent equal values.
				</li>
				<li>
					Really depends on the numbers of elements in the array.
					<delay>2</delay>
					If you're not dealing with a large amount of integers, a HashSet or a binary 
					tree would probably be the best approach.
					<delay>2</delay>
					On the other hand, if you have a large array of diverse integers (say, more 
					than a billion) it might make sense to allocate a 2^32 / 2^8 = 512 MByte byte 
					array in which each bit represents the existence or non-existence of an integer 
					and then count the number of set bits in the end. 
					<delay>2</delay>
					A binary tree approach would take n * log n time, while an array approach would take n time.
					<delay>2</delay>
					Also, a binary tree requires two pointers per node, so your memory usage would 
					be a lot higher as well.
					<delay>2</delay>
					Similar consideration apply to hash tables as well.
					<delay>2</delay>
					Of course, if your set is small, then just use the inbuilt HashSet.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ counting distinct integers ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ counting ^ distinct ^ integers ^</pattern>
		<template><srai>^ counting distinct integers ^</srai></template>
	</category>
	<category>
		<pattern>^ counting distinct int ^</pattern>
		<template><srai>^ counting distinct integers ^</srai></template>
	</category>
	<category>
		<pattern>
			<!-- 21. Java: function for arrays like PHP's join()? -->
			^ function ^ arrays ^ php ^ join ^
		</pattern>
		<template>
			<random>
				<li>
					Starting from Java8 it is possible to use String.join().
					<delay>2</delay>
					String.join(", ", new String[]{"Hello", "World", "!"})<break/>
					Generates: Hello, World, !<break/>
					Otherwise, Apache Commons Lang has a StringUtils class which has a join 
					function which will join arrays together to make a String.
					<delay>2</delay>
					For example:
					StringUtils.join(new String[] {"Hello", "World", "!"}, ", ")<break/>
					Generates the following String: Hello, World, !<break/>
				</li>
				<li>
					Not in core, no.
					<delay>2</delay>
					A search for "java array join string glue" will give you some code snippets on 
					how to achieve this though. For example:
					public static String join(Collection s, String delimiter) {<break/>
					    StringBuffer buffer = new StringBuffer();<break/>
					    Iterator iter = s.iterator();<break/>
					    while (iter.hasNext()) {<break/>
					        buffer.append(iter.next());<break/>
					        if (iter.hasNext()) {<break/>
					            buffer.append(delimiter);<break/>
					        }<break/>
					    }<break/>
					    return buffer.toString();<break/>
					}<break/>
				</li>
				<li>
					Nothing built-in that I know of.
					<delay>2</delay>
					Apache Commons Lang has a class called StringUtils which contains many join functions.
				</li>
				<li>
					You could easily write such a function in about ten lines of code:
					String combine(String[] s, String glue)<break/>
					{<break/>
					  int k = s.length;<break/>
					  if ( k == 0 )<break/>
					  {<break/>
					    return null;<break/>
					  }<break/>
					  StringBuilder out = new StringBuilder();<break/>
					  out.append( s[0] );<break/>
					  for ( int x=1; x &lt; k; ++x )<break/>
					  {<break/>
					    out.append(glue).append(s[x]);<break/>  }<break/>
					  return out.toString();<break/>
					}<break/>
				</li>
				<li>
					java.util.Arrays has an 'asList' method.
					<delay>2</delay>
					Together with the java.util.List/ArrayList API this gives you all you need:;
					private static String[] join(String[] array1, String[] array2) {<break/>
					    List&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(array1));<break/>
					    list.addAll(Arrays.asList(array2));<break/>
					    return list.toArray(new String[0]);<break/>
					}<break/>
				</li>
				<li>
					This is how I do it.
					<delay>2</delay>
					private String join(String[] input, String delimiter)<break/>
					{<break/>
					    StringBuilder sb = new StringBuilder();<break/>
					    for(String value : input)<break/>
					    {<break/>
					        sb.append(value);<break/>
					        sb.append(delimiter);<break/>
					    }<break/>
					    int length = sb.length();<break/>
					    if(length &gt; 0)<break/>
					    {<break/>
					        // Remove the extra delimiter<break/>
					        sb.setLength(length - delimiter.length());<break/>
					    }<break/>
					    return sb.toString();<break/>
					}<break/>

					<delay>2</delay>
				</li>
				<li>
					Given:
					String[] a = new String[] { "Hello", "World", "!" };<break/>
					Then as an alternative to coobird's answer, where the glue is ", ":
					Arrays.asList(a).toString().replaceAll("^\\[|\\]$", "")<break/>
					Or to concatenate with a different string, such as " &amp;amp; ".
					<delay>2</delay>
					Arrays.asList(a).toString().replaceAll(", ", " &amp;amp; ").replaceAll("^\\[|\\]$", "")<break/>
					<delay>2</delay>
					However...
					<delay>2</delay>
					this one ONLY works if you know that the values in the array or list DO NOT 
					contain the character string ", ".
				</li>
				<li>
					If you are using the Spring Framework then you have the StringUtils class:
					import static org.springframework.util.StringUtils.arrayToDelimitedString;<break/>
					arrayToDelimitedString(new String[] {"A", "B", "C"}, "\n");<break/>
				</li>
				<li>
					If you've landed here looking for a quick array-to-string conversion, try 
					Arrays.toString().
					Creates a String representation of the Object[] passed.
					<delay>2</delay>
					The result is surrounded by brackets ("[]"), each element is converted to a String
					via the String.valueOf(Object) and separated by ", ".
					<delay>2</delay>
					If the array is null, then "null" is returned.
				</li>
				<li>
					I do it this way using a StringBuilder:
					public static String join(String[] source, String delimiter) {<break/>
					    if ((null == source) || (source.length &lt; 1)) {<break/>
					        return "";<break/>
					    }<break/>
					    StringBuilder stringbuilder = new StringBuilder();<break/>
					    for (String s : source) {<break/>
					        stringbuilder.append(s + delimiter);<break/>
					    }<break/>
					    return stringbuilder.toString();<break/>
					} // join((String[], String)<break/>
				</li>
				<li>
					There is simple shorthand technique I use most of the times..
					String op = new String;<break/>
					for (int i : is) <break/>
					{<break/>
					    op += candidatesArr[i-1]+",";<break/>
					}<break/>
					op = op.substring(0, op.length()-1);<break/>
				</li>
				<li>
					As with many questions lately, Java 8 to the rescue:
					Java 8 added a new static method to java.lang.String which does exactly what you want:

					<delay>2</delay>
					public static String join(CharSequence delimeter, CharSequence... elements);<break/>
					Using it:
					String s = String.join(", ", new String[] {"Hello", "World", "!"});<break/>
					Results in:
					"Hello, World, !"<break/>
				</li>
				<li>
					To get "str1, str2" from "str1", "str2", "" :
					Stream.of("str1", "str2", "").filter(str -&gt; !str.isEmpty()).collect(Collectors.joining(", ")); <break/>
					Also you can add extra null-check
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ function ^ arrays ^ php ^ join ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ function ^ php ^ join ^</pattern>
		<template><srai>^ function ^ arrays ^ php ^ join ^</srai></template>
	</category>
	<category>
		<pattern>^ php ^ join ^</pattern>
		<template><srai>^ function ^ arrays ^ php ^ join ^</srai></template>
	</category>
	<category>
		<pattern>
			<!-- 22. Creating a byte[] from a List -->
			^ creating ^ array ^ list ^
		</pattern>
		<template>
			<random>
				<li>
					The toArray() method sounds like a good choice.
					<delay>2</delay>
					Update:
					<delay>2</delay>
					Although, as folks have kindly pointed out, this works with "boxed" values.
					<delay>2</delay>
					So a plain for-loop looks like a very good choice, too.
					<delay>2</delay>
				</li>
				<li>
					byte[] byteArray = new byte[byteList.size()];<break/>
					for (int index = 0; index &lt; byteList.size(); index++) {<break/>
					    byteArray[index] = byteList.get(index);<break/>
					}<break/>
					<delay>2</delay>
					You may not like it but thats about the only way to create a Genuine Array of byte.
					<delay>2</delay>
					As pointed out in the comments, there are other ways.
					<delay>2</delay>
					However, none of those ways gets around a) creating an array and b) assigning each element.
					<delay>2</delay>
					This one uses an iterator.
					<delay>2</delay>
					byte[] byteArray = new byte[byteList.size()];<break/>
					int index = 0;<break/>
					for (byte b : byteList) {<break/>
					    byteArray[index++] = b;<break/>
					}<break/>
				</li>
				<li>
					Using Bytes.toArray(Collection&lt;Byte&gt;) (from Google's Guava library.)
					<delay>2</delay>
					Example:
					import java.util.ArrayList;<break/>
					import java.util.Arrays;<break/>
					import java.util.List;<break/>
					import com.google.common.primitives.Bytes;<break/>
					class Test {<break/>
					    public static void main(String[] args) {<break/>
					        List&lt;Byte&gt; byteList = new ArrayList&lt;Byte&gt;();<break/>
					        byteList.add((byte) 1);<break/>
					        byteList.add((byte) 2);<break/>
					        byteList.add((byte) 3);<break/>
					        byte[] byteArray = Bytes.toArray(byteList);<break/>
					        System.out.println(Arrays.toString(byteArray));<break/>
					    }<break/>
					}<break/>
					Or similarly, using PCJ:
					import bak.pcj.Adapter;<break/>
					// ...<break/>
					byte[] byteArray = Adapter.asBytes(byteList).toArray();<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ creating ^ arry ^ list ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ transform ^ list ^ array</pattern>
		<template><srai>^ creating ^ arry ^ list ^</srai></template>
	</category>
	<category>
		<pattern>^ arry ^ list ^ conversion ^</pattern>
		<template><srai>^ creating ^ arry ^ list ^</srai></template>
	</category>
	<category>
		<pattern>
			<!-- 23. When to use a List over an Array in Java? -->
			^ use ^ list ^ array ^
		</pattern>
		<template>
			<random>
				<li>
					If you want the array of items to expand (i.e. if you don't know what the 
					size of the list will be beforehand), a List will be beneficial.
					<delay>2</delay>
					However, if you want performance, you would generally use an array.
				</li>
				<li>
					Pretty much always prefer a list.
					<delay>2</delay>
					Lists have much more functionality, particularly iterator support.
					<delay>2</delay>
					You can convert a list to an array at any time with the toArray() method.
				</li>
				<li>
					It depends on what kind of List.
					<delay>2</delay>
					It's better to use a LinkedList if you know you'll be inserting many elements 
					in positions other than the end.
					<delay>2</delay>
					LinkedList is not suitable for random access (getting the i'th element).
					<delay>2</delay>
					It's better to use an ArrayList if you don't know, in advance, how many 
					elements there are going to be.
					<delay>2</delay>
					The ArrayList correctly amortizes the cost of growing the backing array as 
					you add more elements to it, and is suitable for random access once the elements 
					are in place.
					<delay>2</delay>
					An ArrayList can be efficiently sorted.
				</li>
				<li>
					I see the question as being the opposite- 
					<delay>2</delay>
					When should you use an Array over a List? 
					<delay>2</delay>
					Only you have a specific reason to do so (eg: Project Constraints, Memory ]
					Concerns (not really a good reason), etc.)
					<delay>2</delay>
					Lists are much easier to use (imo), and have much more functionality. 
					<delay>2</delay>
					Note:
					<delay>2</delay>
					You should also consider whether or not something like a Set, or another datastructure is a better fit than a List for what you are trying to do.
					<delay>2</delay>
					Each datastructure, and implmentation, has different pros/cons.
					<delay>2</delay>
					Pick the ones that excel at the things that you need to do.
					<delay>2</delay>
					If you need get() to be O(1) for any item?
					<delay>2</delay>
					Likely use an ArrayList, Need O(1) insert()?
					<delay>2</delay>
					Possibly a Linked List.
					<delay>2</delay>
					Need O(1) contains()?
					<delay>2</delay>
					Possibly a Hashset.
					<delay>2</delay>
					TLDR:
					<delay>2</delay>
					Each data structure is good at some things, and bad at others.
					<delay>2</delay>
					Look at your objectives and choose the data structure that best fits the given problem.
				</li>
				<li>
					In many cases the type of collection used is an implementation detail which 
					shouldn't be exposed to the outside world.
					<delay>2</delay>
					The more generic your returntype is the more flexibility you have changing the 
					implementation afterwards.
					<delay>2</delay>
					Arrays (primitive type, ie.
					<delay>2</delay>
					new int[10]) are not generic, you won't be able to change you implementation 
					without an internal conversion or altering the client code.
					<delay>2</delay>
					You might want to consider Iterable as a returntype.
				</li>
				<li>
					If you know how many things you'll be holding, you'll want an array.  
					<delay>2</delay>
					My screen is 1024x768, and a buffer of pixels for that isn't going to change 
					in size ever during runtime.
					<delay>2</delay>
					If you know you'll need to access specific indexes (go get item #763!), use 
					an array or array-backed list.
					<delay>2</delay>
					If you need to add or remove items from the group regularly, use a linked list.
					<delay>2</delay>
					In general, dealing with hardware, arrays, dealing with users, lists.
				</li>
				<li>
					Rules of thumb:
					Use a List for reference types.
					<delay>2</delay>
					Use arrays for primitives.
					<delay>2</delay>
					If you have to deal with an API that is using arrays, it might be useful to use arrays.
					<delay>2</delay>
					If you are doing a lot of List type operations on the sequence and it is not 
					in a performance/memory critical section, then use List.
					<delay>2</delay>
					Low-level optimisations may use arrays.
					<delay>2</delay>
					Expect nastiness with low-level optimisations.
					<delay>2</delay>
				</li>
				<li>
					Most people have answered it already.
					<delay>2</delay>
					There are almost no good reason to use an array instead of List.
					<delay>2</delay>
					The main exception being the primitive array (like int[]).
					<delay>2</delay>
					You cannot create a primitive list (must have List&lt;Integer&gt;).
					<delay>2</delay>
					The most important difference is that when using List you can decide what 
					implementation will be used.
					<delay>2</delay>
					The most obvious is to chose LinkedList or ArrayList. 
					<delay>2</delay>
					I would like to point out in this answer that choosing the implementation 
					gives you very fine grained control over the data that is simply not available 
					to array:
					<delay>2</delay>
					You can prevent client from modifying your list by wrapping your list in a 
					Collection.unmodifiableList
					<delay>2</delay>
					You can synchronize a list for multithreading using Collection.synchronizedList
					<delay>2</delay>
					You can create a fixed length queue with implementation of LinkedBlockingQueue
					<delay>2</delay>
					In any case, even if you don't want (now) any extra feature of the list.
					<delay>2</delay>
					Just use an ArrayList and size it with the size of the array you would have 
					created.
					<delay>2</delay>
					It will use an Array in the back-end and the performance difference with a real 
					array will be negligible.
					<delay>2</delay>
					(except for primitive arrays) 
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ use ^ list ^ array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ use ^ array ^ list ^</pattern>
		<template><srai>^ use ^ list ^ array ^</srai></template>
	</category>
	<category>
		<pattern>^ use ^ arrays ^ lists ^</pattern>
		<template><srai>^ use ^ list ^ array ^</srai></template>
	</category>
	<category>
		<pattern>^ use ^ lists ^ arrays ^</pattern>
		<template><srai>^ use ^ list ^ array ^</srai></template>
	</category>
	<category>
		<pattern>
			<!-- 24. Final arraylist declaration -->
			^ final arraylist declaration ^
		</pattern>
		<template>
			<random>
				<li>
					Final means that the variable pointing to the arraylist can't change.
					<delay>2</delay>
					But that does not mean that you can not call any method of the object, 
					so you can perform insert, search and any other operation to the object
				</li>
				<li>
					If you're talking about Java's ArrayList, then, yes you can.
					<delay>2</delay>
					Final means just that you can't change which ArrayList instance your 
					variable refers to.
				</li>
				<li>
					If a list is declared final as follows:
					public final List myList = new ArrayList();<break/>
					there's nothing to stop modifications to the list:
					<delay>2</delay>
					myList.add("value");<break/>
					<delay>2</delay>
					However, the following would not be possible:
					myList = new ArrayList();<break/>
					myList = someOtherList;<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ final arraylist declaration ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ declare ^ arraylist ^ final</pattern>
		<template><srai>^ final arraylist declaration ^</srai></template>
	</category>
	<category>
		<pattern>^ arraylist ^ final ^</pattern>
		<template><srai>^ final arraylist declaration ^</srai></template>
	</category>
	<category>
		<pattern>^ declare ^ final ^ arraylist ^</pattern>
		<template><srai>^ final arraylist declaration ^</srai></template>
	</category>
	<category>
		<pattern>
			<!-- 25. What is the best way to combine several arrays into one single array -->
			^ combine ^ arrays ^ one ^ array ^ 
		</pattern>
		<template>
			<random>
				<li>
					Create an array of the right size (by going through and summing the lengths of all 
					the source arrays)
					<delay>2</delay>
					Repeatedly call System.arraycopy to copy one source array at a time into the 
					target array, updating the place where you copy it to on each iteration.

					<delay>2</delay>
					So something like:
					public static double[] Combine(double[][] arrays)<break/>
					{<break/>
					    int totalLength = 0;<break/>
					    for (double[] source : arrays)<break/>
					    {<break/>
					        totalLength += source.length;<break/>
					    }<break/>
					    double[] ret = new double[totalLength];<break/>
					    int index = 0;<break/>
					    for (double[] source : arrays)<break/>
					    {<break/>
					        System.arraycopy(source, 0, ret, index, source.length);<break/>
					        index += source.length;<break/>
					    }<break/>
					    return ret;<break/>
					}<break/>
				</li>
				<li>
					You can use this method from the Guava library, which is open-source and will 
					have an actual binary release probably later this month:
					Doubles.concat(double[]...)
					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ combine ^ arrays ^ one ^ array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ combine ^ arrays ^ one ^ array ^</pattern>
		<template><srai>^ arrays ^ one ^ array ^</srai></template>
	</category>
	<category>
		<pattern>^ arrays ^ single ^ array ^</pattern>
		<template><srai>^ combine ^ arrays ^ one ^ array ^</srai></template>
	</category>
	<category>
		<pattern>^  one ^ array ^ arrays</pattern>
		<template><srai>^ combine ^ arrays ^ one ^ array ^</srai></template>
	</category>
	<category>
		<pattern>
			<!-- 26. list of 2D array in java -->
			^ list ^ 2d array ^
		</pattern>
		<template>
			<random>
				<li>
					This could be the solution: <break/>
					List&lt;String[][]&gt; myFunc( Set&lt;String[][]&gt; s ) {<break/>
					  List&lt;String[][]&gt; l = new ArrayList&lt;String[][]&gt;( s.length() );<break/>
					  l.addAll( s );<break/>
					  return l;<break/>
					}<break/>
				</li>
				<li>
					Can't you just pass the set into a list like so:
					int [][]a = new int[3][3];<break/>
					Set&lt;int[][]&gt; set = new HashSet&lt;int[][]&gt;();<break/>
					set.add(a);<break/>
					ArrayList&lt;int[][]&gt; list = new ArrayList&lt;int[][]&gt;(set);<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ list ^ 2d array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ create ^ list ^ 2d array ^</pattern>
		<template><srai>^ list ^ 2d array ^</srai></template>
	</category>
	<category>
		<pattern>^ list ^ 2d arrays ^</pattern>
		<template><srai>^ list ^ 2d array ^</srai></template>
	</category>
	<category>
		<pattern>
			<!-- 27. Array of Dates in Java -->
			^ array ^ dates ^
		</pattern>
		<template>
			<random>
				<li>
					The same way you do for String  and Int , you just place different types inside: 
					Date [] dates = {<break/>
					    new Date(), <break/>
					    new Date()<break/>
					};<break/>
					Declared an array of size two with two dates.
					<delay>2</delay>
					You can also initialize with null values:
					<delay>2</delay>
					 Date [] dates = new Date[2];<break/>
					Or add more significant values:
					Date [] dates = {<break/>
					    getDateFromString("25/11/2009"), <break/>
					    getDateFromString("24/12/2009")<break/>
					 };<break/>
					.... <break/>
					public Date getDateFromString( String s ) {<break/>
					    Date result = ...// parse the string set the value etc. <break/>
					    return result;<break/>
					}<break/>
				</li>
				<li>
					You can use an array of java.util.Date (API docs are here)
					Date[] dates = new Date[] {<break/>
					    new Date(),<break/>
					    new Date(),<break/>
					};<break/>
					<delay>2</delay>
					You can create an array of any object type in java - all reference and primitive 
					types
				</li>
				<li>
					Or you could use the Collections API and Calendar class,
					import java.util.*;<break/>
					List&lt;Calendar&gt; dates = new ArrayList&lt;Calendar&gt;(5); // initial size<break/>
					dates.add( Calendar.getInstance() );<break/>
				</li>
				<li>
					Did you mean inputting an array of dates.
					<delay>2</delay>
					This code would help..
					import java.text.ParseException;<break/>
					import java.text.SimpleDateFormat;<break/>
					import java.util.ArrayList;<break/>
					import java.util.Date;<break/>
					import java.util.Scanner;<break/>
					public class Datinput {<break/>
					    public static void main(String args[]) {<break/>
					        int n;<break/>
					        ArrayList&lt;String&gt; al = new ArrayList&lt;String&gt;();<break/>
					        Scanner in = new Scanner(System.in);<break/>
					        n = in.nextInt();<break/>
					        String da[] = new String[n];<break/>
					        SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");<break/>
					        sdf.setLenient(false);<break/>
					        Date date[] = new Date[n];<break/>
					        in.nextLine();<break/>
					        for (int i = 0; i &lt; da.length; i++) {<break/>
					            da[i] = in.nextLine();<break/>
					        }<break/>
					        for (int i = 0; i &lt; da.length; i++) {<break/>
					            try {<break/>
					                date[i] = sdf.parse(da[i]);<break/>
					            } catch (ParseException e) {<break/>
					                e.printStackTrace();<break/>
					            }<break/>
					        }<break/>
					        in.close();<break/>
					    }<break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ array ^ dates ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ dates ^ array</pattern>
		<template><srai>^ array ^ dates ^</srai></template>
	</category>
	<category>
		<pattern>^ arrays ^ dates ^</pattern>
		<template><srai>^ array ^ dates ^</srai></template>
	</category>
	<category>
		<pattern>
			<!-- 28. how will I find odd elements from two arrays -->
			^ find odd elements ^ two arrays ^
		</pattern>
		<template>
			<random>
				<li>
					Make a loop for each array item.
					<delay>2</delay>
					Those for which item &amp; 1 == 1 are odd.
				</li>
				<li>
					You could try tis:
					int[] longArray = { 1, 3, 2 };<break/>
					int[] shortArray = { 1, 2 };<break/>
					//Check which array is longer, if b longer than a then swap<break/>
					boolean found = false;<break/>
					int odd = 0;<break/>
					for (int i : longArray) {<break/>
							for (int j : shortArray) {<break/>
									if (i == j)<break/>
											found = true;<break/>
							}<break/>
							if (!found)<break/>
									odd = i;<break/>
							found = false;<break/>
					}<break/>
					System.out.println(odd);<break/>
				</li>
				<li>
					This should do the trick:<break/>
					int[] longArray = { 1, 3, 2 };<break/>
					int[] shortArray = { 1, 2 };<break/>
					//Check which array is longer, if b longer than a then swap<break/>
					for (int x:longArray){<break/>
							set.add(x);<break/>
					}<break/>
					for (int x:shortArray){<break/>
							if (set.contains(x))<break/>
									set.remove(x);<break/>
					}<break/>
					//odd numbers<break/>
					for (Object i:set.toArray())<break/>
							System.out.println(i+",");<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ find odd elements ^ two arrays ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ find odd items ^ two arrays ^</pattern>
		<template><srai>^ find odd elements ^ two arrays ^</srai></template>
	</category>
	<category>
		<pattern>^ find odd numbers ^ two arrays ^</pattern>
		<template><srai>^ find odd elements ^ two arrays ^</srai></template>
  </category>
	<category>
		<pattern>^ search ^ odd elements ^ two arrays ^</pattern>
		<template><srai>^ find odd elements ^ two arrays ^</srai></template>
  </category>
	<category>
		<pattern>^ search ^ odd items ^ two arrays ^</pattern>
		<template><srai>^ find odd elements ^ two arrays ^</srai></template>
  </category>
	<category>
		<pattern>^ search ^ odd elements ^ 2 arrays ^</pattern>
		<template><srai>^ find odd elements ^ two arrays ^</srai></template>
  </category>
	<category>
		<pattern>^ find odd elements ^ 2 arrays ^</pattern>
		<template><srai>^ find odd elements ^ two arrays ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 29. In Java, why are arrays objects? Are there any specific reasons? -->
			^ arrays ^ objects ^
		</pattern>
		<template>
			<random>
				<li>
					So that they get all the benefits thereof:
					getHashCode() <break/>
					toString()
					<delay>2</delay>
					And arrays aren't 'primitive', so if they can't be primitive, they must be 
					objects.
				</li>
				<li>
					I'm not sure about the official reason.
					<delay>2</delay>
					However, it makes sense to me that they are objects because operations 
					can be performed on them (such as taking the length) and it made more 
					sense to support these operations as member functions rather than introduce 
					new keywords.
					<delay>2</delay>
					Other operations include clone(), the inherited operations of object, etc.
					<delay>2</delay>
					Arrays are also hashable and potentially comparable. 
					<delay>2</delay>
					This is different from C (and native arrays in C++), where your arrays are essentially pointers to a memory offset. 
				</li>
				<li>
					Having arrays be objects means that you can do operations with them (e.g., someArray.count('foo'))
					<delay>2</delay>
					instead of just doing it against them (e.g., count(someArray, 'foo')), 
					which leads to more natural syntax.
				</li>
				<li>
					The objects are mutable and are passed by reference.
					<delay>2</delay>
					In arrays there aren't any fields/methods that you can use to change "properties" 
					of the array, but you sure can mutate the element values.
					<delay>2</delay>
					And the benefits of passing arrays by reference are pretty obvious (though 
					functional programmers probably wish Java had immutable lists passed by value). 
					<delay>2</delay>
					In the period before autoboxing, it was helpful to be able to store arrays 
					in collections, write them to ObjectStreams etc.
				</li>
				<li>
					Probably because they wanted to get as close as possible to making everything 
					an object.
					<delay>2</delay>
					Native types are there for backward compatibility.
				</li>
				<li>
					Because the Java Language Specification says so :) 
					<delay>2</delay>
					In the Java programming language arrays are objects (4.3.1), are dynamically 
					created, and may be assigned to variables of type Object (4.3.2).
					<delay>2</delay>
					All methods of class Object may be invoked on an array.
					<delay>2</delay>
					So, unlike C++, Java provides true arrays as first-class objects: 
					<delay>2</delay>
					There is a length member. 
					<delay>2</delay>
					There is a clone() method which overrides the method of the same name in 
					class Object.
					<delay>2</delay>
					Plus all the members of the class Object.
					<delay>2</delay>
					An exception is thrown if you attempt to access an array out of bounds.
					<delay>2</delay>
					Arrays are instanciated in dynamic memory.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ arrays ^ objects ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ array ^ object ^</pattern>
		<template><srai>^ arrays ^ objects ^</srai></template>
  </category>
	<category>
		<pattern>^ arrays ^ object ^</pattern>
		<template><srai>^ arrays ^ objects ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 30. Java Arrays - What are they -->
			^ java arrays ^ 
		</pattern>
		<template>
			<random>
				<li>
					Arrays are "special" in Java - they don't implement any interfaces, which means they can't implement the collection interfaces.
					<delay>2</delay>
					They're collections in "natural language" terms, and you can use the enhanced 
					for loop over them - but if you want to use an array within the collection 
					API, you'll need something like Arrays.asList which wraps an array with 
					the List&lt;T&gt; interface.
					<delay>2</delay>
					(The result is only a view on the array - changes to the array are visible 
					through the list, and vice versa.)
					<delay>2</delay>
					(This is in contrast to .NET, where T[] implements IList&lt;T&gt; etc.)
				</li>
				<li>
					An array is a data structure that contains a group of elements. 
					<delay>2</delay>
					Typically these elements are all of the same data type, such as an integer or string. 
					<delay>2</delay>
					Arrays are commonly used in computer programs to organize data so that a related set of 
					values can be easily sorted or searched.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ java arrays ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ what ^ array ^</pattern>
		<template><srai>^ java arrays ^</srai></template>
  </category>
	<category>
		<pattern>^ what ^ arrays ^</pattern>
		<template><srai>^ java arrays ^</srai></template>
  </category>
	<category>
		<pattern>^ arrays ^ java ^</pattern>
		<template><srai>^ java arrays ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 31. Convert Hash Map to 2D Array -->
			^ convert hash map ^ 2d array ^
		</pattern>
		<template>
			<random>
				<li>
					This can only be done when the types of both key and value are the same.
					<delay>2</delay>
					Given:   
					HashMap&lt;String,String&gt; map;<break/>
					<delay>2</delay>
					I can create an array from this map with this simple loop:
					String[][] array = new String[map.size()][2];<break/>
					int count = 0;<break/>
					for(Map.Entry&lt;String,String&gt; entry : map.entrySet()){<break/>
					    array[count][0] = entry.getKey();<break/>
					    array[count][1] = entry.getValue();<break/>
					    count++;<break/>
					}<break/>
				</li>
				<li>
					Iterate over your Map using entrySet, and fill your array record with the 
					Entry object
				</li>
				<li>
					How about
					Object[][] array = new Object[][]{map.keySet.toArray(), map.entrySet.toArray()};<break/>
					<delay>2</delay>
					Or, to be more specific about the types, let's say they're Strings:
					<delay>2</delay>
					Set's toArray takes a hint argument, so that
					String[][] array = new String[][]{map.keySet.toArray(new String[0]), map.entrySet.toArray(new String[0])};<break/>
					Edit: I just realized a couple of days later that while this may work by chance, in general it shouldn't.
					<delay>2</delay>
					The reason is the intermediate Set; although it is "backed by the map", 
					there seems to be no explicit guarantee that it will iterate in any particular 
					order.
					<delay>2</delay>
					Thus the key- and entry-arrays might not be in the same order, which is 
					a disaster for sure!
				</li>
				<li>
					Try this way:<break/>
					HashMap map = new HashMap();<break/>
					Object[][] arr = new Object[map.size()][2];<break/>
					Set entries = map.entrySet();<break/>
					Iterator entriesIterator = entries.iterator();<break/>
					int i = 0;<break/>
					while(entriesIterator.hasNext()){<break/>
					    Map.Entry mapping = (Map.Entry) entriesIterator.next();<break/>
					    arr[i][0] = mapping.getKey();<break/>
					    arr[i][1] = mapping.getValue();<break/>
					    i++;<break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ convert hash map ^ 2d array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ hash map ^ 2d array ^</pattern>
		<template><srai>^ convert hash map ^ 2d array ^</srai></template>
  </category>
	<category>
		<pattern>^ change hash map ^ 2d array ^</pattern>
		<template><srai>^ convert hash map ^ 2d array ^</srai></template>
  </category>
	<category>
		<pattern>^ transform hash map ^ 2d array ^</pattern>
		<template><srai>^ convert hash map ^ 2d array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 32. how to generate random number from array -->
			^ generate random number ^ array ^
		</pattern>
		<template>
			<random>
				<li>
					You could try this code:<break/>
					import java.util.Random;<break/>...<break/>
					Random random = new Random();<break/>
					System.out.println(n[random.nextInt(n.length)]);<break/>
				</li>
				<li>
					In general terms, get a random integer ranging from a minimum of 0 to a 
					maximum of the array length -1, and use that as the array index.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ generate random number ^ array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ generate random number ^ list ^</pattern>
		<template><srai>^ generate random number ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ random number ^ array ^</pattern>
		<template><srai>^ generate random number ^ array ^</srai></template>
  </category>
	<category>
		<pattern></pattern>
		<template><srai>^ random number ^ list ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 33. Java ArrayList Middle -->
			^ arraylist ^ middle ^
		</pattern>
		<template>
			<random>
				<li>
					It is the element in the middle of the array:<break/>
					ArrayList.size()/2<break/>
				</li>
				<li>
					If you have N items, the middle item is usually defined as item at index 
					N/2 (0-based).
					<delay>2</delay>
					Generally, if you need to find the middle of items between index low (inclusive
					) and high (exclusive), it's mathematically int mid = (low + high) / 2.
					<delay>2</delay>
					But due to arithmetic overflow in limited-precision integer, the proper 
					formula is int mid = (low + high) &gt;&gt;&gt; 1;
				</li>
				<li>
					If the size of ArrayList is even in number, then use
					(ArrayList.size()/2)+1 or    
					(ArrayList.size()/2) as the middle.
					<delay>2</delay>
					If the size of ArrayList is odd in number, then use     
					(ArrayList.size()+1)/2 as the middle.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ arraylist ^ middle ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^  middle ^ arraylist</pattern>
		<template><srai>^ arraylist ^ middle ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 34. How to put a Scanner input into an array... for example a couple of numbers -->
			^ put ^ scanner input ^ array ^
		</pattern>
		<template>
			<random>
				<li>
					Here is some code that you can use:<break/>
					double [] avg = new double[5];<break/>
					for(int i=0; i&lt;5; i++)<break/>
					   avg[i] = scan.nextDouble();<break/>
				</li>
				<li>
					You can get all the doubles with this code:
					List&lt;Double&gt; numbers = new ArrayList&lt;Double&gt;();<break/>
					while (scan.hasNextDouble()) {<break/>
					    numbers.add(scan.nextDouble());<break/>
					}<break/>
				</li>
				<li>
					
					You could try something like this:
					public static void main (String[] args)<break/>
					{<break/>
					    Scanner input = new Scanner(System.in);<break/>
					    double[] numbers = new double[5];<break/>
					    for (int i = 0; i &lt; numbers.length; i++)<break/>
					    {<break/>
					        System.out.println("Please enter number");<break/>
					        numbers[i] = input.nextDouble();<break/>
					    }<break/>
					}<break/>
					<delay>2</delay>
					It seems pretty basic stuff unless I am misunderstanding you
				</li>
				<li>
					This code could help you:<break/>
					Scanner scan = new Scanner (System.in);<break/>
					for (int i=0; i&lt;=4, i++){<break/>
					    System.out.printf("Enter value at index"+i+" :");<break/>
					    anArray[i]=scan.nextInt();<break/>
					}<break/>
				</li>
				<li>
					Try this snippet: <break/>
					import  java.util.Scanner;<break/>
					class Array {<break/>
					public static void main(String a[]){<break/>
					    Scanner input = new Scanner(System.in);<break/>
					    System.out.println("Enter the size of an Array");<break/>
					    int num = input.nextInt();<break/>
					    System.out.println("Enter the Element "+num+" of an Array");<break/>
					    double[] numbers = new double[num];<break/>
					    for (int i = 0; i &lt; numbers.length; i++)<break/>
					    {<break/>
					        System.out.println("Please enter number");<break/>
					        numbers[i] = input.nextDouble();<break/>
					    }<break/>
					    for (int i = 0; i &lt; numbers.length; i++)<break/>
					    {<break/>
					        if ( (i%3) !=0){<break/>
					            System.out.print("");<break/>
					            System.out.print(numbers[i]+"\t");<break/>
					        } else {<break/>
					            System.out.println("");<break/>
					            System.out.print(numbers[i]+"\t");<break/>
					        }<break/>
					    }<break/>
					}<break/>
				</li>
				<li>
					This should give you a clue:<break/>
					import java.util.Scanner;<break/>public class sort {<break/>
					  public static void main(String args[])<break/>
					    {<break/>
					        int i,n,t;          <break/>
					        Scanner sc=new Scanner(System.in);<break/>
					        System.out.print("Enter the size of array");<break/>
					        n=sc.nextInt();<break/>
					        int a[] = new int[n];<break/>
					        System.out.println("Enter elements in array");<break/>
					        for(i=0;i&lt;n;i++)<break/>
					        {<break/>
					            a[i]=sc.nextInt();<break/>
					        }<break/>
					        t=a[1];<break/>
					        for(i=0;i&lt;n;i++)<break/>
					        {<break/>
					            if(a[i]&gt;t)<break/>
					                t=a[i];<break/>
					        }<break/>
					        System.out.println("Greates integer is" +t);<break/>
					    }<break/>
					}<break/>
				</li>
				<li>
					This is a program to show how to give input from system and also calculate sum at each level and average.
					<delay>2</delay>
					package NumericTest;<break/>
					import java.util.Scanner;<break/>
					public class SumAvg {<break/>
					 public static void main(String[] args) {<break/>
					 int i,n;<break/>
					 System.out.println("Enter the number of inputs");<break/>
					 Scanner sc = new Scanner(System.in);<break/>
					 n=sc.nextInt();<break/>
					 int a[] = new int [n];<break/>
					    System.out.println("Enter the inputs");<break/>
					   for(i=0;i&lt;n;i++){<break/>
					   a[i] = sc.nextInt();<break/>
					  System.out.println("Inputs are " +a[i]);<break/>
					 }<break/>
					  int sum = 0;<break/>
					  for(i=0;i&lt;n;i++){<break/>
					 sum = sum +a[i];<break/>
					  System.out.println("Sums : " +sum);<break/>
					 }<break/>
					  int avg ;<break/>
					  avg = sum/n;<break/>
					  System.out.println("avg : " +avg);<break/>
					  }<break/>
					 }<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ put ^ scanner input ^ array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ scanner input ^ array</pattern>
		<template><srai>^ put ^ scanner input ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ insert ^ scanner input ^ array ^</pattern>
		<template><srai>^ put ^ scanner input ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ copy ^ scanner input ^ array ^</pattern>
		<template><srai>^ put ^ scanner input ^ array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 35. how to get HashTable values as Arraylist? -->
			^ get hashtable values ^ arraylist ^
		</pattern>
		<template>
			<random>
				<li>
					Use the ArrayList constructor that takes a collection.
					<delay>2</delay>
					ArrayList&lt;Word&gt; arr = new ArrayList&lt;Word&gt;(hw.values());<break/>
					<delay>2</delay>
					Then every value that was in the HashTable will be in the new ArrayList.
					<delay>2</delay>
					You can find documentation about the constructor in the javadocs.
					<delay>2</delay>
				</li>
				<li>
					You could use this:<break/>
					ArrayList&lt;Word&gt; arr = new ArrayList&lt;Word&gt;( hw.values() );<break/>
					<delay>2</delay>
				</li>
				<li>
					use hw.values();<break/>
					<delay>2</delay>
					it will simply return the Collection (like a List) of Word objects. 
					from javadocs
					values
					public Collection values() Returns a Collection view of the values contained in this map.
					<delay>2</delay>
					The collection is backed by the map, so changes to the map are reflected in
					the collection, and vice-versa.
					<delay>2</delay>
					If the map is modified while an iteration over the collection is in progress (except through the iterator's own
					remove operation), the results of the iteration are undefined.
					<delay>2</delay>
					The collection supports element removal, which removes the corresponding
					mapping from the map, via the Iterator.remove, Collection.remove,
					removeAll, retainAll and clear operations.
					<delay>2</delay>
					It does not support the add or addAll operations.
				</li>
				<li>
					Also you can use
					ArrayList&lt;Word&gt; arr = Collections.list(hw.keys());<break/>
					for keys as ArrayList
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ get hashtable values ^ arraylist ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ hashtable values ^ arraylist ^</pattern>
		<template><srai>^ get hashtable values ^ arraylist ^</srai></template>
  </category>
	<category>
		<pattern>^ save hashtable values ^ arraylist ^</pattern>
		<template><srai>^ get hashtable values ^ arraylist ^</srai></template>
  </category>
	<category>
		<pattern>^ copy hashtable values ^ arraylist ^</pattern>
		<template><srai>^ get hashtable values ^ arraylist ^</srai></template>
  </category>
	<category>
		<pattern>^ get hashtable items ^ arraylist ^</pattern>
		<template><srai>^ get hashtable values ^ arraylist ^</srai></template>
  </category>
	<category>
		<pattern>^ hashtable items ^ arraylist ^</pattern>
		<template><srai>^ get hashtable values ^ arraylist ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 36. Free memory of a byte array in Java -->
			^ free memory ^ byte array ^
		</pattern>
		<template>
			<random>
				<li>
					You can simly stop referencing it.
					<delay>2</delay>
				</li>
				<li>
					Removing all the reference to that array of bytes.
					<delay>2</delay>
					The garbage collector will take care of the rest.
				</li>
				<li>
					When creating a new byte[] in Java, you do something like
					byte[] myArray = new byte[54];<break/>
					<delay>2</delay>
					To free it, you should do
					myArray = null;<break/>
					<delay>2</delay>
					If something else references your byte array, like yourArray = myArray;<break/>
					you need to also set the other references to null, like so yourArray = null;<break/>
					In Java garbage collection is automatic.  
					<delay>2</delay>
					If the JVM can detect that a piece of memory is no longer reachable by the entire program, then the JVM will free the memory for 
					you.
				</li>
				<li>
					Setting all references to it to null will make it a candidate for Java'
					s automatic garbage collection.
					<delay>2</delay>
					You can't be sure how long it will take for this to happen though.
					<delay>2</delay>
					If you really need to explicitly reclaim the memory immediately you can 
					make a call to System.gc();
					Also just to clear you may not need to set the references to null explicitly.
					<delay>2</delay>
					If the references go out of scope they are automatically nulled e.g. a 
					local variable reference will be nulled once the method it is declared 
					in finishes executing.
					<delay>2</delay>
					So local variables are usually released implicitly all the time during 
					an apps runtime.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ free memory ^ byte array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ free memory ^ array ^</pattern>
		<template><srai>^ free memory ^ byte array ^</srai></template>
  </category>
	<category>
		<pattern>^ free array ^</pattern>
		<template><srai>^ free memory ^ byte array ^</srai></template>
  </category>
	<category>
		<pattern>^ array ^ free ^</pattern>
		<template><srai>^ free memory ^ byte array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 37. Do Java arrays have a maximum size? -->
			^ arrays ^ maximum size ^
		</pattern>
		<template>
			<random>
				<li>
					There are actually two limits.  
					<delay>2</delay>
					One, the maximum element indexable for the array and, two, the amount of 
					memory available to your application.  
					<delay>2</delay>
					Depending on the amount of memory available and the amount used by other 
					data structures, you may hit the memory limit before you reach the maximum 
					addressable array element.
				</li>
				<li>
					This is (of course) totally VM-dependent.
					<delay>2</delay>
					Browsing through the source code of OpenJDK 7 and 8 java.util.ArrayList, .Hashtable, .AbstractCollection,  .PriorityQueue, and .Vector, you can see this claim being repeated:
					/**<break/>
					 * Some VMs reserve some header words in an array.<break/>
					 * Attempts to allocate larger arrays may result in<break/>
					 * OutOfMemoryError: Requested array size exceeds VM limit<break/>
					 */<break/>
					 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;<break/>
					which is added by Martin Buchholz (Google) on 2010-05-09; reviewed by Chris 
					Hegarty (Oracle).
					<delay>2</delay>
					So,  probably  we can say that the maximum "safe" number would be  2 147 
					483 639 (Integer.MAX_VALUE - 8) and "attempts to allocate larger arrays 
					may result in OutOfMemoryError".
					<delay>2</delay>
					(Yes, Buchholz's standalone claim does not include backing evidence, so 
					this is a calculated appeal to authority.
					<delay>2</delay>
					Even within OpenJDK itself, we can see code like return (minCapacity &gt; 
					MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; which shows 
					that MAX_ARRAY_SIZE does not yet have a real use.)
				</li>
				<li>
					Maximum number of elements of an array is (2^31)1 or 2 147 483 647 
				</li>
				<li>
					Arrays are non-negative integer indexed , so maximum array size you can 
					access would be Integer.MAX_VALUE.
					<delay>2</delay>
					The other thing is how big array you can create.
					<delay>2</delay>
					It depends on the maximum memory available to your JVM and the content 
					type of the array.
					<delay>2</delay>
					Each array element has it's size, example.
					<delay>2</delay>
					byte = 1 byte, int = 4 bytes, Object reference = 4 bytes (on a 32 bit system) 
					<delay>2</delay>
					So if you have 1 MB memory available on your machine, you could allocate 
					an array of byte[1024 * 1024] or Object[256 * 1024]. 
					<delay>2</delay>
					Answering your question - You can allocate an array of size (maximum available 
					memory / size of array item).   
					<delay>2</delay>
					Theoretically the maximum size of an array will be Integer.MAX_VALUE.
					<delay>2</delay>
					Practically it depends on how much memory your Integer.MAX_VALUE0 has and 
					how much of that has already been allocated to other objects.
				</li>
				<li>
					I tried to create a byte array like this
					byte[] bytes = new byte[Integer.MAX_VALUE-x];<break/>
					System.out.println(bytes.length);<break/>
					With this run configuration:
					<delay>2</delay>
					-Xms4G -Xmx4G<break/>
					And java version:
					Openjdk version "1.8.0_141" 
					OpenJDK Runtime Environment (build 1.8.0_141-b16) 
					OpenJDK 64-Bit Server VM (build 25.141-b16, mixed mode)
					<delay>2</delay>
					It only works for x >= 2 which means the maximum size of an array is Integer.
					<delay>2</delay>
					MAX_VALUE-2
					Values above that give
					Exception in thread "main" java.lang.OutOfMemoryError:
					<delay>2</delay>
					Requested array size exceeds VM limit at Main.main(Main.java:6)
				</li>
				<li>
					Yes, there limit on java array.
					<delay>2</delay>
					Java uses an integer as an index to the array and the maximum integer store 
					by JVM is 2^32. so you can store 2,147,483,647 elements in the array. 
					<delay>2</delay>
					In case you need more than max-length you can use two different arrays 
					but the recommended method is store data into a file.
					<delay>2</delay>
					because storing data in the file has no limit.
					<delay>2</delay>
					because files stored in your storage drivers but array are stored in JVM.
					<delay>2</delay>
					JVM provides limited space for program execution. 
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ arrays ^ maximum size ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ array ^ maximum size ^</pattern>
		<template><srai>^ arrays ^ maximum size ^</srai></template>
  </category>
	<category>
		<pattern>^ arrays ^ maximum dimension ^</pattern>
		<template><srai>^ arrays ^ maximum size ^</srai></template>
  </category>
	<category>
		<pattern>^ maximum size ^ array ^</pattern>
		<template><srai>^ arrays ^ maximum size ^</srai></template>
  </category>
	<category>
		<pattern>^ maximum dimension ^ array ^</pattern>
		<template><srai>^ arrays ^ maximum size ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 38. Send an Array with an HTTP Get -->
			^ send ^ array ^ http get ^
		</pattern>
		<template>
			<random>
				<li>
					That depends on what the target server accepts.
					<delay>2</delay>
					There is no definitive standard for this.
					<delay>2</delay>
					Query string:
					<delay>2</delay>
					While there is no definitive standard, most web frameworks allow multiple 
					values to be associated with a single field (e.g. 
					field1=value1&amp;field1=value2&amp;field2=value3).[4][5]
					<delay>2</delay>
					Generally, when the target server uses a strong typed programming language 
					like Java (Servlet), then you can just send them as multiple parameters 
					with the same name.
					<delay>2</delay>
					The API usually offers a dedicated method to obtain multiple parameter 
					values as an array.
					<delay>2</delay>
					foo=value1&amp;foo=value2&amp;foo=value3<break/>
					String[] foo = request.getParameterValues("foo"); // [value1, value2, value3]<break/>
					The request.getParameter("foo") will also work on it, but it'll return 
					only the first value.
					<delay>2</delay>
					String foo = request.getParameter("foo"); // value1<break/>
					<delay>2</delay>
					And, when the target server uses a weak typed language like PHP or RoR, 
					then you need to suffix the parameter name with braces [] in order to 
					trigger the language to return an array of values instead of a single value.
					<delay>2</delay>
					foo[]=value1&amp;foo[]=value2&amp;foo[]=value3<break/>
					$foo = $_GET["foo"]; // [value1, value2, value3]<break/>
					echo is_array($foo); // true<break/>
					<delay>2</delay>
					In case you still use foo=value1&amp;foo=value2&amp;foo=value3, then it
					'll return only the first value.
					<delay>2</delay>
					field1=value1&amp;field1=value2&amp;field2=value30
					Do note that when you send field1=value1&amp;field1=value2&amp;field2=value31 
					to a Java Servlet, then you can still obtain them, but you'd need to use 
					the exact parameter name including the braces.
					<delay>2</delay>
					field1=value1&amp;field1=value2&amp;field2=value32
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ send ^ array ^ http get ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^  http get ^ send array ^</pattern>
		<template><srai>^ send ^ array ^ http get ^</srai></template>
  </category>
	<category>
		<pattern>^ sending array ^ http get ^</pattern>
		<template><srai>^ send ^ array ^ http get ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 39. java array sorting -->
			^ array sorting ^
		</pattern>
		<template>
			<random>
				<li>
					Use Arrays.sort().
					<delay>2</delay>
					See the API documentation of class java.util.Arrays.
					<delay>2</delay>
					Example:
					<delay>2</delay>
					import java.util.Arrays;<break/>
					// ...<break/>
					String[] arr = new String[] { "one", "two", "three" };<break/>
					Arrays.sort(arr);<break/>
				</li>
				<li>
					To add a little bit more to their answers above - as you mentioned "sorting 
					logically", you can implement your own Comparator and use Arrays.sort(
					array, comparator).
					<delay>2</delay>
					Is there a specific reason you want to avoid Arrays.sort()?
				</li>
				<li>
					Here is a nice selection including code examples for the various ways to 
					sort arrays and/or collections: Rosetta Code
				</li>
				<li>
					Write a quicksort or mergesort algorithm.
					<delay>2</delay>
				</li>
				<li>
					Have a look at Insertion Sort.
				</li>
				<li>
					You can write bubble sort or quick sort or any sorting algorithm yourself
					<delay>2</delay>
				</li>
				<li>
					I write my own sorting algorithms in my personal projects without looking 
					at any formal sorting algorithms.
					<delay>2</delay>
					It keeps my programming edges sharpend, plus it's interesting to see what 
					you can come up with on your own, compared to the more formal sorting algorithms.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ array sorting ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ sort array ^</pattern>
		<template><srai>^ array sorting ^</srai></template>
  </category>
	<category>
		<pattern>^ arrays sorting ^</pattern>
		<template><srai>^ array sorting ^</srai></template>
  </category>
	<category>
		<pattern>^ sorting arrays ^</pattern>
		<template><srai>^ array sorting ^</srai></template>
  </category>
	<category>
		<pattern>^ sort arrays ^</pattern>
		<template><srai>^ array sorting ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 40. Finding an element in an array in Java -->
			^ finding ^ element ^ array ^
		</pattern>
		<template>
			<random>
				<li>
					Use a for loop.  
					<delay>2</delay>
					There's nothing built into array.  
					<delay>2</delay>
					Or switch to a java.util Collection class.
				</li>
				<li>
					You might want to consider using a Collection implementation instead of 
					a flat array.
					<delay>2</delay>
					The Collection interface defines a contains(Object o) method, which returns 
					true/false.
					<delay>2</delay>
					ArrayList implementation defines an indexOf(Object o), which gives an index
					, but that method is not on all collection implementations.
					<delay>2</delay>
					Both these methods require proper implementations of the equals() method
					, and you probably want a properly implemented hashCode() method just 
					in case you are using a hash based Collection0 (e.g. Collection1).
				</li>
				<li>
					You can use one of the many Arrays.binarySearch() methods.  
					<delay>2</delay>
					Keep in mind that the array must be sorted first.
				</li>
				<li>
					With Java 8, you can do this:
					int[] haystack = {1, 2, 3};<break/>
					int needle = 3;<break/>
					boolean found = Arrays.stream(haystack).anyMatch(x -&gt; x == needle);<break/>
					<delay>2</delay>
					You'd need to do 
					boolean found = Arrays.stream(haystack).anyMatch(x -&gt; needle.equals(x));<break/>
					if you're working with objects.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ finding ^ element ^ array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ find ^ element ^ array ^</pattern>
		<template><srai>^ finding ^ element ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ search ^ element ^ array ^</pattern>
		<template><srai>^ finding ^ element ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ finding ^ elements ^ array ^</pattern>
		<template><srai>^ finding ^ element ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ find ^ elements ^ array ^</pattern>
		<template><srai>^ finding ^ element ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ finding ^ item ^ array ^</pattern>
		<template><srai>^ finding ^ element ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ array ^ find ^ item ^</pattern>
		<template><srai>^ finding ^ element ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ array ^ finding ^ items ^</pattern>
		<template><srai>^ finding ^ element ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ array ^ search ^ item ^</pattern>
		<template><srai>^ finding ^ element ^ array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 41. divide array into smaller parts -->
			^ divide array ^ smaller parts ^
		</pattern>
		<template>
			<random>
				<li>
					You can use the method Arrays.copyOfRange(original, from, to)
					public static byte[][] divideArray(byte[] source, int chunksize) {<break/>
							byte[][] ret = new byte[(int)Math.ceil(source.length / (double)chunksize)][chunksize];<break/>
							int start = 0;<break/>
							for(int i = 0; i &lt; ret.length; i++) {<break/>
									ret[i] = Arrays.copyOfRange(source,start, start + chunksize);<break/>
									start += chunksize ;<break/>
							}<break/>
							return ret;<break/>
					}<break/>
					<delay>2</delay>
					Or You can use as Max suggested the System.arraycopy
					public static byte[][] divideArray(byte[] source, int chunksize) {<break/>
							byte[][] ret = new byte[(int)Math.ceil(source.length / (double)chunksize)][chunksize];<break/>
							int start = 0;<break/>
							for(int i = 0; i &lt; ret.length; i++) {<break/>
									if(start + chunksize &gt; source.length) {<break/>
											System.arraycopy(source, start, ret[i], 0, source.length - start);<break/>
									} else {<break/>
											System.arraycopy(source, start, ret[i], 0, chunksize);<break/>
									}<break/>
									start += chunksize ;<break/>
							}<break/>
							return ret;<break/>
					}<break/>
				</li>
				<li>
					See Arrays.copyOfRange for help.
					<delay>2</delay>
					You could use this in a loop to split your array into several smaller chunks.
				</li>
				<li>
					Well, System.arraycopy(src, fromPos, dest, toPos, length) is generally 
					considered faster than Arrays.copyOfRange.
					<delay>2</delay>
					byte[] source = ...read it from somewhere...;<break/>
					byte[] newArray = new byte[64];<break/>
					System.arraycopy(source, 0, newArray, 0, 64);<break/>
				</li>
				<li>
					You have two choices:
					<delay>2</delay>
					System.arraycopy(...)
					Array.copyOfRange(...)
					<delay>2</delay>
					both of them work the same way
					<delay>2</delay>
					but while first one only manages copy, second one is meant to be used to 
					allocate the new chunk at the same time.
					<delay>2</delay>
					I benchmarked them with a result that System.arraycopy is faster if you 
					manage to allocate chunks all together before splitting your array but 
					slightly slower if you allocate them whle you copy: in this case you should 
					use Array.copyOfRange.
				</li>
				<li>
					This will do...
					byte[] source = new byte[2048];<break/>
					byte[] target = new byte[1024];  <break/>
					// fill source with some data...<break/>
					Array.Copy(source, buffer, 1024);<break/>
				</li>
				<li>
					If you are looking save some memory, a slight modification to Damian Vash
					's answer would help (in this case any remaining chunk is not allocated 
					a complete 64 byte block size, as well...)
					private byte[][] splitChunks(byte[] source)<break/>
					{<break/>
					    byte[][] ret = new byte[(int)Math.ceil(source.length / (double)CHUNK_SIZE)][];<break/>
					    int start = 0;<break/>
					    for(int i = 0; i &lt; ret.length; i++) {<break/>
					        if(start + CHUNK_SIZE &gt; source.length) {<break/>
					            ret[i] = new byte[source.length-start];<break/>
					            System.arraycopy(source, start, ret[i], 0, source.length - start);<break/>
					        } <break/>
					        else {<break/>
					            ret[i] = new byte[CHUNK_SIZE];<break/>
					            System.arraycopy(source, start, ret[i], 0, CHUNK_SIZE);<break/>
					        }<break/>
					        start += CHUNK_SIZE ;<break/>
					    }<break/>
					    return ret;<break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ divide array ^ smaller parts ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ split array ^</pattern>
		<template><srai>^ divide array ^ smaller parts ^</srai></template>
  </category>
	<category>
		<pattern>^ divide array ^</pattern>
		<template><srai>^ divide array ^ smaller parts ^</srai></template>
  </category>
	<category>
		<pattern>^ array ^ split ^</pattern>
		<template><srai>^ divide array ^ smaller parts ^</srai></template>
  </category>
	<category>
		<pattern>^ array ^ division ^</pattern>
		<template><srai>^ divide array ^ smaller parts ^</srai></template>
  </category>
	<category>
		<pattern>^ break array ^ smaller parts ^</pattern>
		<template><srai>^ divide array ^ smaller parts ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 42. java vector to arraylist -->
			^ vector ^ arraylist ^
		</pattern>
		<template>
			<random>
				<li>
					Yup - just use the constructor which takes a collection as its parameter:
					<delay>2</delay>
					Vector&lt;String&gt; vector = new Vector&lt;String&gt;();<break/>
					// (... Populate vector here...)<break/>
					ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(vector);<break/>
					Note that it only does a shallow copy.
				</li>
				<li>
					I just wrote a class to do the same thing, but is more flexible as it will 
					accept Objects accordingly. 
					<delay>2</delay>
					public class ExteriorCastor {<break/>
					    public static  ArrayList vectorToArrayList(Vector vector){<break/>
					        if (vector == null){return null;}<break/>
					        return new ArrayList&lt;Object&gt;(vector);<break/>
					    }<break/>
					}<break/>
				</li>
				<li>
					im not sure if it is length() or size()....
					<delay>2</delay>
					but the idea is the next:
					ArrayList&lt;Object&gt; a;<break/>
					for(int i = 0;i &lt; Vector.length() ; i++)<break/>
					    a.add(Vector.elementAt(i); // Again... im not sure if this is elementAt() or get()<break/>
					Vector.finalize();<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ vector ^ arraylist ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ vectors ^ arraylist ^</pattern>
		<template><srai>^ vector ^ arraylist ^</srai></template>
  </category>
	<category>
		<pattern>^ arraylist ^ vector</pattern>
		<template><srai>^ vector ^ arraylist ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 43. How does ArrayList work? -->
			^ arraylist work ^
		</pattern>
		<template>
			<random>
				<li>
					Internally an ArrayList uses an Object[].
					<delay>2</delay>
					As you add items to an ArrayList, the list checks to see if the backing 
					array has room left.  
					<delay>2</delay>
					If there is room, the new item is just added at the next empty space.  
					<delay>2</delay>
					If there is not room, a new, larger, array is created, and the old array 
					is copied into the new one.
					<delay>2</delay>
					Now, there is more room left, and the new element is added in the next 
					empty space.
					<delay>2</delay>
					Since people really like the source code:
					/**<break/>
					 * The array buffer into which the elements of the ArrayList are stored.<break/>
					 * The capacity of the ArrayList is the length of this array buffer.<break/>
					 */<break/>
					private transient Object[] elementData;<break/>
					Straight out of the JDK.
				</li>
				<li>
					It uses an Object[], and makes a bigger array when the array gets full.
				</li>
				<li>
					It uses an array, and a couple of integers to indicate the first value 
					- last value index
					private transient int firstIndex;<break/>
					private transient int lastIndex;<break/>
					private transient E[] array;<break/>
				</li>
				<li>
					Typically, structures like ArrayLists are implemented by a good old fashioned 
					array defined within the class and not directly accessible outside the class. 
					<delay>2</delay>
					A certain amount of space is initially allocated for the list, and when 
					you add an element that exceeds the size of the array, the array will 
					be reinitialized with a new capacity (which is typically some multiple 
					of the current size, so the framework isn't constantly re-allocating arrays 
					with each new entry added).
				</li>
				<li>
					The Java platform source code is freely available.
					<delay>2</delay>
					Here's an extract:
					public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;<break/>  
					implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable<break/>
					{<break/>
					  /**<break/>
					   * The array buffer into which the elements of the ArrayList are stored.<break/>
					   * The capacity of the ArrayList is the length of this array buffer.<break/>
					   */<break/>
					  private transient E[] elementData;<break/>
					}<break/>
				</li>
				<li>
					ArrayLists use arrays to hold the data.
					<delay>2</delay>
					Once the number of elements exceeds the allocated array it copies the data 
					to another array, probably double the size.
					<delay>2</delay>
					A (minor) performance hit is taken when copying the array, it's therefore 
					possible to set the size of the internal array in the constructor 
					of the array list.
					<delay>2</delay>
					Furthermore it implements java.util.Collection and and java.util.list, 
					and it's is therefore possible to get the element at a specified index
					, and iterable (just like an array).
				</li>
				<li>
					ArrayList uses an Array of Object to store the data internally.
					<delay>2</delay>
					When you initialize an ArrayList, an array of size 10 (default capacity
					) is created and an element added to the ArrayList is actually added to 
					this array.
					<delay>2</delay>
					10 is the default size and it can be passed as a parameter while initializing 
					the ArrayList.
					<delay>2</delay>
					When adding a new element, if the array is full, then a new array of 50% more the initial size is created 
					and the last array is copied to this new array so that now there are empty 
					spaces for the new element to be added.
					<delay>2</delay>
					Since the underlying data-structure used is an array, it is fairly easy 
					to add a new element to the ArrayList as it is added to the end of the list.
					<delay>2</delay>
					When an element is to be added anywhere else, say the beginning, then 
					all the elements shall have to move one position to the right to create 
					an empty space at the beginning for the new element to be added.
					<delay>2</delay>
					This process is time-consuming (linear-time).
					<delay>2</delay>
					But the Advantage of ArrayList is that retrieving an element at any position 
					is very fast (constant-time), as underlying it is simply using an array 
					of objects.
				</li>
				<li>
					ArrayList has the basic data structure:
					<delay>2</delay>
					private transient Object[] elementData;<break/>

					<delay>2</delay>
					When we actually create an ArrayList the following piece of code is executed:
					this.elementData = new Object[initial capacity];<break/>
					ArrayList can be created in the two ways mentioned below:
					<delay>2</delay>
					List list = new ArrayList();
					<delay>2</delay>
					The default constructor is invoked and will internally create an array 
					of Object with default size 10.
					<delay>2</delay>
					List list = new ArrayList(5);
					<delay>2</delay>
					When we create an ArrayList in this way, constructor with an integer argument 
					is invoked and create an array of ArrayList0 with default size 5.
					<delay>2</delay>
					Inside the ArrayList1 method there is check whether the current size of 
					filled elements is greater/equal to the maximum size of the ArrayList2
					<delay>2</delay>
					then it will create new ArrayList3 with the size new ArrayList4 and copy 
					the data from old to new array list.
				</li>
				<li>
					It uses an Object[].
					<delay>2</delay>
					When the array is full it creates a new array which is 50% bigger in size 
					and copies current elements to new array.
					<delay>2</delay>
					It happens automatically. 
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ arraylist work ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ work ^ arraylist ^</pattern>
		<template><srai>^ arraylist work ^</srai></template>
  </category>
	<category>
		<pattern>^ arraylist logic ^</pattern>
		<template><srai>^ arraylist work ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 44. Does initialized java array go onto stack or heap? -->
			^ array ^ stack ^ heap ^
		</pattern>
		<template>
			<random>
				<li>
					You can think of it as always going on the heap.
					<delay>2</delay>
					I believe some smart VMs are able to stack-allocate objects if they can 
					detect it's safe - but conceptually it's on the heap.
					<delay>2</delay>
					In particular, all array types are reference types (even if the element 
					type is primitive), so the array variable (which is on the stack) is just 
					a reference to an object, and objects normally go on the heap.
					<delay>2</delay>
					In particular, imagine a small change:
					byte[] someMethod() { <break/>
					    byte[] array = { 0, 0 };<break/>
					    return array;<break/>
					}<break/>
					<delay>2</delay>
					If the array were allocated on the stack, what would the returned reference 
					have to refer to?
				</li>
				<li>
					It will be stored in the heap
					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ array ^ stack ^ heap ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ array ^ heap ^ stack ^</pattern>
		<template><srai>^ array ^ stack ^ heap ^</srai></template>
  </category>
	<category>
		<pattern>^ array ^ allocation ^</pattern>
		<template><srai>^ array ^ stack ^ heap ^</srai></template>
  </category>
	<category>
		<pattern>^ allocation ^ array ^</pattern>
		<template><srai>^ array ^ stack ^ heap ^</srai></template>
  </category>
	<category>
		<pattern>^ allocation ^ arrays ^</pattern>
		<template><srai>^ array ^ stack ^ heap ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 45. Best way to create singleton array -->
			^ create ^ singleton array ^
		</pattern>
		<template>
			<random>
				<li>
					
					The standard way is this:
					String[] arr = new String[]{"I am the one and only"};<break/>
					<delay>2</delay>
					I'm afraid it doesn't get much simpler than this.
					<delay>2</delay>
					Of course if you often create array you can create a helper method that 
					makes things a bit simpler:
					public static &lt;T&gt; T[] asArray(T... items){<break/>
					    return items;<break/>
					}<break/>
					String[] arr = asArray("I am the one and only");<break/>
					<delay>2</delay>
					(But you can't enforce at compile time that it will be an array with only 
					one element)
					<delay>2</delay>
					Next I was going to write a singleton array method, but Stephen beat me to that.
				</li>
				<li>
					This is quite simple: <break/>
					Object [] singleton = { new SomeObject() };<break/>
				</li>
				<li>
					This should do the job
					public SomeType[] makeSingletonArray(SomeType elem) {<break/>
					    return new SomeType[]{elem};<break/>
					}<break/>
					<delay>2</delay>
					A generic version of this method would be somewhat awkward to use, since 
					you would need to pass it a Class object as an additional parameter.
					<delay>2</delay>
					Inlining the SomeType[]{elem} expression is simpler, and that's how I'd 
					normally do this.
				</li>
				<li>
					You could do this:
					Object[] a = Collections.singletonList(&quot;SingleElement&quot;).toArray();<break/>
					Or<break/>
					String[] a = Collections.singletonList(&quot;SingleElement&quot;).toArray(new String[1]);
				</li>
				<li>
					enum solution(anti reflect attack):
					enum MySingleton{<break/>
						INSTANCE(new String[]{"a","b"});<break/>
						final String[] values;<break/>
						private MySingleton(String[] values) {<break/>
								this.values = values;<break/>
						}<break/>
					}<break/>
					reference it as:
					MySingleton.INSTANCE;<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ create ^ singleton array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ singleton array ^ creation ^</pattern>
		<template><srai>^ create ^ singleton array ^</srai></template>
  </category>
	<category>
		<pattern>^ creating ^ singleton array ^</pattern>
		<template><srai>^ create ^ singleton array ^</srai></template>
  </category>
	<category>
		<pattern>^ build ^ singleton array ^</pattern>
		<template><srai>^ create ^ singleton array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 46. What is the best way to remove the first element from an array? -->
			^ remove ^ first element ^ array ^
		</pattern>
		<template>
			<random>
				<li>
					Simplest way is probably as follows - you basically need to construct a 
					new array that is one element smaller, then copy the elements you want 
					to keep to the right positions.
					<delay>2</delay>
					int n=oldArray.length-1;<break/>
					String[] newArray=new String[n];<break/>
					System.arraycopy(oldArray,1,newArray,0,n);<break/>
					Note that if you find yourself doing this kind of operation frequently, 
					it could be a sign that you should actually be using a different kind 
					of data structure, e.g. a linked list.
					<delay>2</delay>
					Constructing a new array every time is an O(n) operation, which could 
					get expensive if your array is large.
					<delay>2</delay>
					A linked list would give you O(1) removal of the first element.
					<delay>2</delay>
					An alternative idea is not to remove the first item at all, but just increment 
					an integer that points to the first index that is in use.
					<delay>2</delay>
					Users of the array will need to take this offset into account, but this 
					can be an efficient approach.
					<delay>2</delay>
					The Java String class actually uses this method internally when creating 
					substrings.
				</li>
				<li>
					The size of arrays in Java cannot be changed.  
					<delay>2</delay>
					So, technically you cannot remove any elements from the array.
					<delay>2</delay>
					One way to simulate removing an element from the array is to create a new
					, smaller array, and then copy all of the elements from the original array 
					into the new, smaller array.
					<delay>2</delay>
					String[] yourArray = Arrays.copyOfRange(oldArr, 1, oldArr.length);<break/>
					<delay>2</delay>
					However, I would not suggest the above method.  
					<delay>2</delay>
					You should really be using a List&lt;String&gt;.  
					<delay>2</delay>
					Lists allow you to add and remove items from any index.  
					<delay>2</delay>
					That would look similar to the following:
					List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // or LinkedList
					&lt;String&gt;();<break/>list.add("Stuff");<break/>// add lots of stuff
					<break/>list.remove(0); // removes the first item<break/>
				</li>
				<li>
					You can't do it at all, let alone quickly.  
					<delay>2</delay>
					Arrays in Java are fixed size.  
					<delay>2</delay>
					Two things you could do are:
					Shift every element up one, then set the last element to null.
					<delay>2</delay>
					Create a new array, then copy it.
					<delay>2</delay>
					You can use System.arraycopy for either of these.  
					<delay>2</delay>
					Both of these are O(n), since they copy all but 1 element.
					<delay>2</delay>
					If you will be removing the first element often, consider using LinkedList 
					instead.  
					<delay>2</delay>
					You can use LinkedList.remove, which is from the Queue interface, for 
					convenience.  
					<delay>2</delay>
					With LinkedList, removing the first element is O(1).  
					<delay>2</delay>
					In fact, removing any element is O(1)
					<delay>2</delay>
					once you have a ListIterator to that position.  
					<delay>2</delay>
					However, accessing an arbitrary element by index is O(n).
				</li>
				<li>
					Keep an index of the first "live" element of the array.
					<delay>2</delay>
					Removing (pretending to remove) the first element then becomes an O(1) 
					time complexity operation.
				</li>
				<li>
					An alternative ugly method:
					String[] a ={"BLAH00001","DIK-11","DIK-2","MAN5"};<break/>
					String[] k=Arrays.toString(a).split(", ",2)[1].split("]")[0].split(", ");<break/>
				</li>
				<li>
					To sum up, the quick linkedlist method:
					List&lt;String&gt; llist = new LinkedList&lt;String&gt;(Arrays.asList(oldArray));<break/>llist.remove(0);<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ remove ^ first element ^ array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ delete ^ first element ^ array ^</pattern>
		<template><srai>^ remove ^ first element ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ remove ^ array ^ first element</pattern>
		<template><srai>^ remove ^ first element ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ remove ^ first item ^ array ^</pattern>
		<template><srai>^ remove ^ first element ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ delete ^ first item ^ array ^</pattern>
		<template><srai>^ remove ^ first element ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ array ^ remove ^ first item ^</pattern>
		<template><srai>^ remove ^ first element ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ array ^ delete ^ first item ^</pattern>
		<template><srai>^ remove ^ first element ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ array ^ delete ^ first element^</pattern>
		<template><srai>^ remove ^ first element ^ array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 47. How do you write a method that prints objects in a array in java? -->
			^ method ^ prints ^ array ^ 
		</pattern>
		<template>
			<random>
				<li>
					There are several useful toString() and deepToString() methods in java.
					util.Arrays class.
					<delay>2</delay>
					String[] strings = { "foo", "bar", "waa" };<break/>
					System.out.println(Arrays.toString(strings)); // [foo, bar, waa]<break/>
					An alternative is to just loop over them yourself and print each item separately.
				</li>
				<li>
					You can do it using for loop. 
					<delay>2</delay>
					Here's example :
					<delay>2</delay>
					String[] colors = {"red","blue","black","green","yellow"};<break/>
					for (String color : colors) {<break/>
						System.out.println(color);<break/>
					}<break/>
					Also check :
					<delay>2</delay>
					In Java 5 Arrays.toString(arr) or Arrays.deepToString(arr) for arrays within arrays.
					<delay>2</delay>
					Note that Object[] version calls .toString() of each object in array.
					<delay>2</delay>
					If my memory serves me correct, the output is even decorated in the exact way you're asking.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ method ^ prints ^ array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ array ^ method ^ print ^</pattern>
		<template><srai>^ method ^ prints ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ method ^ print ^ array ^</pattern>
		<template><srai>^ method ^ prints ^ array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 48. Assigning an array to an ArrayList in Java -->
			^ assigning ^ array ^ arraylist ^
		</pattern>
		<template>
			<random>
				<li>
					The Arrays class contains an asList method which you can use as follows:
					String[] words = ...;<break/>
					List&lt;String&gt; wordList = Arrays.asList(words);<break/>
				</li>
				<li>
					You can use Arrays.asList():
					Type[] anArray = ...<break/>
					ArrayList&lt;Type&gt; aList = new ArrayList&lt;Type&gt;(Arrays.asList(anArray));<break/>
					or alternatively, Collections.addAll():
					ArrayList&lt;Type&gt; aList = new ArrayList&lt;Type&gt;();<break/>
					Collections.addAll(theList, anArray); <break/>
					Note that you aren't technically assigning an array to a List (well, you 
					can't do that), but I think this is the end result you are looking for.
				</li>
				<li>
					If you are importing or you have an array (of type string) in your code 
					and you have to convert it into arraylist (offcourse string) then use 
					of collections is better.
					<delay>2</delay>
					like this:
					String array1[] = getIntent().getExtras().getStringArray("key1"); or<break/>
					String array1[] = ...<break/>
					then<break/>
					List&lt;String&gt; allEds = new ArrayList&lt;String&gt;();<break/>
					Collections.addAll(allEds, array1);<break/>
				</li>
				<li>
					This is working
					int[] ar = {10, 20, 20, 10, 10, 30, 50, 10, 20};<break/>
					ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();<break/>
					for(int i:ar){<break/>
							list.add(new Integer(i));<break/>
					}<break/>
					System.out.println(list.toString());<break/>
					// prints : [10, 20, 20, 10, 10, 30, 50, 10, 20]<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ assigning ^ array ^ arraylist ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ assign ^ array ^ arraylist ^</pattern>
		<template><srai>^ assigning ^ array ^ arraylist ^</srai></template>
  </category>
	<category>
		<pattern>^ transform ^ array ^ arraylist ^</pattern>
		<template><srai>^ assigning ^ array ^ arraylist ^</srai></template>
  </category>
	<category>
		<pattern>^ array ^ arraylist ^</pattern>
		<template><srai>^ assigning ^ array ^ arraylist ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 49. How much data can a List can hold at the maximum? -->
			^ list ^ maximum ^ data ^
		</pattern>
		<template>
			<random>
				<li>
					As much as your available memory will allow.  
					<delay>2</delay>
					There's no size limit except for the heap.
				</li>
				<li>
					It would depend on the implementation, but the limit is not defined by 
					the List interface.
					<delay>2</delay>
					The interface however defines the size() method, which returns an int. 
					Returns the number of elements in this list.  
					<delay>2</delay>
					If this list contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
					<delay>2</delay>
					So, no limit,
					<delay>2</delay>
					but after you reach Integer.MAX_VALUE, the behaviour of the list changes a bit
					ArrayList (which is tagged) is backed by an array, and is limited to the 
					size of the array - i.e. Integer.MAX_VALUE
				</li>
				<li>
					java.util.List is an interface.
					<delay>2</delay>
					How much data a list can hold is dependant on the specific implementation 
					of List you choose to use. 
					<delay>2</delay>
					Generally, a List implementation can hold any number of items (If you use 
					an indexed List, it may be limited to Integer.MAX_VALUE or Long.MAX_VALUE).
					<delay>2</delay>
					As long as you don't run out of memory, the List doesn't become "full" 
					or anything.
				</li>
				<li>
					See the code below of arraylist default it is 10 when u create 
					List l = new ArrayList();
					public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;,<break/>
					Cloneable, Serializable, RandomAccess {<break/>
						private static final long serialVersionUID = 8683452581122892189L;<break/>
						private transient int firstIndex;<break/>
						private transient int lastIndex;<break/>
						private transient E[] array;<break/>
						/**<break/>
							* Constructs a new instance of {@code ArrayList} with ten capacity.<break/>
							*/<break/>
						public ArrayList() {<break/>
								this(10);<break/>
						}<break/>
				</li>
				<li>
					The interface defines the size() method, which returns an int.
					<delay>2</delay>
					Returns the number of elements in this list. If this list contains more than Integer.
					MAX_VALUE elements, returns Integer.MAX_VALUE.<break/>
					<delay>2</delay>
					So, no limit, but after you reach Integer.
					<delay>2</delay>
					MAX_VALUE, the behaviour of the list changes a bit
					ArrayList (which is tagged) is backed by an array, and is limited to the 
					size of the array - i.e. Integer.MAX_VALUE
				</li>
				<li>
					Numbering an items in the java array should start from zero.
					<delay>2</delay>
					This was i think we can have access to Integer.MAX_VALUE+1 an items.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ list ^ maximum ^ data ^</postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ list ^ maximum ^ elements ^</pattern>
		<template><srai>^ list ^ maximum ^ data ^</srai></template>
  </category>
	<category>
		<pattern>^ list ^ maximum ^ items ^</pattern>
		<template><srai>^ list ^ maximum ^ data ^</srai></template>
  </category>
	<category>
		<pattern>^ list ^ maximum ^</pattern>
		<template><srai>^ list ^ maximum ^ data ^</srai></template>
  </category>
	<category>
		
		<pattern>
			<!-- 50. 2D Array Question Java -->
			^ 2d array ^ length ^ 
		</pattern>
		<template>
			<random>
				<li>
					arr.length will be the number of rows
					arr[x].length will be the number of columns in row x.
				</li>
				<li>
					You can find the number of rows as:
					arr.length<break/>
					<delay>2</delay>
					In Java all the rows need not have same number of elements.
					<delay>2</delay>
					You can find the number of elements in the row i as:
					arr[i].length<break/>
				</li>
				<li>
					Rows - arr.length<break/>Columns -arr[rowNumber].length //Each row can 
					have different number of elements<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ 2d array ^ length ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ bidimensional array ^ length ^</pattern>
		<template><srai>^ 2d array ^ length ^</srai></template>
  </category>
	<category>
		<pattern>^ 2d array ^ size ^</pattern>
		<template><srai>^ 2d array ^ length ^</srai></template>
  </category>
	<category>
		<pattern>^ length ^ 2d array ^</pattern>
		<template><srai>^ 2d array ^ length ^</srai></template>
  </category>
	<category>
		<pattern>^ length ^ bidimensional array ^</pattern>
		<template><srai>^ 2d array ^ length ^</srai></template>
  </category>
	<category>
		<pattern>^ length ^ matrix ^</pattern>
		<template><srai>^ 2d array ^ length ^</srai></template>
  </category>
	<category>
		<pattern>^ matrix ^ length ^</pattern>
		<template><srai>^ 2d array ^ length ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 51. Possible to return a String array -->
			^ return ^ string array ^
		</pattern>
		<template>
			<random>
				<li>
					Yes of course
					<delay>2</delay>
					For example a method could look something like this:
					<delay>2</delay>
					public String[] foo() {<break/>    // ...<break/>}<break/>
					Here is a complete example:
					<delay>2</delay>
					public class Program<break/>
					{<break/>
					    public static void main(String[] args) {<break/>
					        Program program = new Program();<break/>
					        String[] greeting = program.getGreeting();<break/>
					        for (String word: greeting) {<break/>
					            System.out.println(word);<break/>
					        }<break/>
					    }<break/>
					    public String[] getGreeting() {<break/>
					        return new String[] { "hello", "world" };<break/>
					    }<break/>
					}<break/>
				</li>
				<li>
					Yes.
					/** Returns a String array of length 5 */<break/>
					public String[] createStringArray() {<break/>
					    return new String[5];<break/>
					}<break/>
				</li>
				<li>
					Yes:
					String[] dummyMethod()<break/>
					{<break/>
					    String[] s = new String[2];<break/>
					    s[0] = "hello";<break/>
					    s[1] = "world";<break/>
					    return s;<break/>
					}<break/>
				</li>
				<li>
					Yes.
					<delay>2</delay>
					public String[] returnStringArray()<break/>
					{<break/>
					    return new String[] { "a", "b", "c" };<break/>
					}<break/>
				</li>
				<li>
					Sure
					public String [] getSomeStrings() {<break/>
					    return new String [] { "Hello", "World" };<break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ return ^ string array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ return ^ array ^ strings ^</pattern>
		<template><srai>^ return ^ string array ^</srai></template>
  </category>
	<category>
		<pattern>^ returns ^ string array ^</pattern>
		<template><srai>^ return ^ string array ^</srai></template>
  </category>
	<category>
		<pattern>^ returns ^ array ^ strings</pattern>
		<template><srai>^ return ^ string array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 52. Java Scanner() to read from Array -->
			^ scanner input ^ array ^
		</pattern>
		<template>
			<random>
				<li>
					There is nothing built in, but you could certainly join all of the elements 
					in your array and pass the resulting string into the Scanner constructor.
					<delay>2</delay>
					A solution with better performance but a greater time investment is to 
					implement Readable by wrapping your array, and keeping track of the current 
					element in the array and the current position in that element's string 
					representation.
					<delay>2</delay>
					You can then fill the buffer with data from the backing array as the Scanner 
					reads from your Readable object.
					<delay>2</delay>
					This approach lets you lazily stream data from your array into the Scanner
					, but at the cost of requiring you to write some code.
				</li>
				<li>
					Use the Arrays.toString() method on the array.
					<delay>2</delay>
					For example:
					int[] arrayOfInts = {1, 2, 3};<break/>
					Scanner s = new Scanner(Arrays.toString(arrayOfInts));<break/>
					while (s.hasNext()) {<break/>
					    System.out.println(s.next());<break/>
					}<break/>
					Will print out: [1, 2, 3]<break/>
				</li>
				<li>
					This is an idea on how it can be done:<break/>
					public class Totalsum {<break/>  public static void main(String[] args){<break/>
					  int[] y={6,1,5,9,5};<break/>
					  int[] z={2,13,6,15,2};<break/>
					  int Total= sumLargeNumber(y,z,5);<break/>
					  System.out.println("The Total sum is "+Total); //call method<break/>
					}<break/>
					public static int sumLargeNumber(int a[], int b[], int size) {<break/>
					  int total=0;<break/>
					  for(int i=0; i&lt; size; i++) {<break/>
					    if(a[i] &gt; b[i]){<break/>
					      total=total+a[i];<break/>
					    }<break/>
					    else {<break/>
					      total=total+b[i];<break/>
					    }<break/>
					  }<break/>
					  return total;<break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ scanner input ^ array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ input scanner ^ array ^</pattern>
		<template><srai>^ scanner input ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ array ^ scanner input ^</pattern>
		<template><srai>^ scanner input ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ array ^ input scanner ^</pattern>
		<template><srai>^ scanner input ^ array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 53. Efficient array elements un-ordering in Java -->
			^ shuffle ^ array ^ 
		</pattern>
		<template>
			<random>
				<li>
					I think you want Collections.shuffle(List)?
					<delay>2</delay>
					If not that, you will need to give us more details about what you're trying 
					to do.
				</li>
				<li>
					I don't know much Java, so there may be better way, but this'll do the 
					trick nicely. 
					<delay>2</delay>
					Fisher-Yates shuffle from Wikipedia:
					static Random rng = new Random();<break/>
					public static void shuffle(int[] array) {<break/>
					    // i is the number of items remaining to be shuffled.<break/>
					    for (int i = array.length; i &gt; 1; i--) {<break/>
					        // Pick a random element to swap with the i-th element.<break/>
					        int j = rng.nextInt(i);  // 0 &lt;= j &lt;= i-1 (0-based array)<break/>
					        // Swap array elements.<break/>
					        int tmp = array[j];<break/>
					        array[j] = array[i-1];<break/>
					        array[i-1] = tmp;<break/>
					    }<break/>
					}<break/>
				</li>
				<li>
					You want to shuffle that array using a good algorithm.
					<delay>2</delay>
					I would trust Collections#shuffle to implement this properly.
					<delay>2</delay>
					If you need it to work on the array directly, implement the algorithm in 
					your own helper method.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ shuffle ^ array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ array ^ shuffle ^</pattern>
		<template><srai>^ shuffle ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ un-order ^ array ^</pattern>
		<template><srai>^ shuffle ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ array ^ un-ordering ^</pattern>
		<template><srai>^ shuffle ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ mix ^ array elements ^</pattern>
		<template><srai>^ shuffle ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ mix ^ array items ^</pattern>
		<template><srai>^ shuffle ^ array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 54. Java array to multi dimensional -->
			^ 1d array ^ multi dimensional ^
		</pattern>
		<template>
			<random>
				<li>
					Iterate throughout your list of 100 chars and divide it amongst the 10*10,
					Modulus (%) will probably be very useful.
					<delay>2</delay>
					You could use 2 nested for loops to assign the chars of the array to the 
					appropriate element.
				</li>
				<li>
					Here you go
					char[] chars = ("01234567890123456789012345678901234567890123456789" + <break/>
					                "01234567890123456789012345678901234567890123456789")<break/>
					                .toCharArray();<break/>
					char[][] char2D = new char[10][10];<break/>
					for (int i = 0; i &lt; 100; i++)<break/>
					    char2D[i / 10][i % 10] = chars[i];<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ 1d array ^ multi dimensional ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ 1d array ^ 2d ^</pattern>
		<template><srai>^ 1d array ^ multi dimensional ^</srai></template>
  </category>
	<category>
		<pattern>^ 1d array ^ 2 ^ dimensional ^</pattern>
		<template><srai>^ 1d array ^ multi dimensional ^</srai></template>
  </category>
	<category>
		<pattern>^ one dimension array ^ multi dimensional ^</pattern>
		<template><srai>^ 1d array ^ multi dimensional ^</srai></template>
  </category>
	<category>
		<pattern>^ one dimensional array ^ two dimensional ^</pattern>
		<template><srai>^ 1d array ^ multi dimensional ^</srai></template>
  </category>
	<category>
		<pattern>^ array ^ two dimensional ^</pattern>
		<template><srai>^ 1d array ^ multi dimensional ^</srai></template>
  </category>
	<category>
		<pattern>^ array ^ 2d ^</pattern>
		<template><srai>^ 1d array ^ multi dimensional ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 55. Creating an Arraylist of Objects -->
			^ creating ^ arraylist ^ objects ^
		</pattern>
		<template>
			<random>
				<li>
					This should work:<break/>
					ArrayList&lt;Matrices&gt; list = new ArrayList&lt;Matrices&gt;();<break/>
					list.add( new Matrices(1,1,10) );<break/>
					list.add( new Matrices(1,2,20) );<break/>
				</li>
				<li>
					Create an array to store the objects:
					ArrayList&lt;MyObject&gt; list = new ArrayList&lt;MyObject&gt;();<break/>
					<delay>2</delay>
					In a single step:
					<delay>2</delay>
					list.add(new MyObject (1, 2, 3)); //Create a new object and adding it to list. <break/>
					or<break/>
					MyObject myObject = new MyObject (1, 2, 3); //Create a new object.<break/>
					list.add(myObject); // Adding it to the list.<break/>
				</li>
				<li>
					If you want to allow a user to add a bunch of new MyObjects to the list
					, you can do it with a for loop:
					<delay>2</delay>
					Let's say I'm creating an ArrayList of Rectangle objects, and each Rectangle 
					has two parameters- length and width.
					<delay>2</delay>
					//here I will create my ArrayList:<break/>
					ArrayList &lt;Rectangle&gt; rectangles= new ArrayList &lt;&gt;(3); <break/>
					int length;<break/>
					int width;<break/>
					for(int index =0; index &lt;3;index++){<break/>
						JOptionPane.showMessageDialog(null, "Rectangle " + (index + 1));<break/>
						length = JOptionPane.showInputDialog("Enter length");<break/>
						width = JOptionPane.showInputDialog("Enter width");<break/>
						//Now I will create my Rectangle and add it to my rectangles ArrayList:<break/>
						rectangles.add(new Rectangle(length,width));<break/>
						//This passes the length and width values to the rectangle constructor,<break/>
						which will create a new Rectangle and add it to the ArrayList.<break/>
					}
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ creating ^ arraylist ^ objects ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ create ^ arraylist ^ objects ^</pattern>
		<template><srai>^ creating ^ arraylist ^ objects ^</srai></template>
  </category>
	<category>
		<pattern>^ build ^ arraylist ^ objects ^</pattern>
		<template><srai>^ creating ^ arraylist ^ objects ^</srai></template>
  </category>
	<category>
		<pattern>^ construct ^ arraylist ^ objects ^</pattern>
		<template><srai>^ creating ^ arraylist ^ objects ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 56. Converting 'ArrayList to 'String[]' in Java -->
			^ converting ^ arraylist ^ array ^
		</pattern>
		<template>
			<random>
				<li>
					Try this approach: <break/>
					List&lt;String&gt; list = ..;<break/>
					String[] array = list.toArray(new String[0]);<break/>
					<delay>2</delay>
					For example:
					<delay>2</delay>
					List&lt;String&gt; list = new ArrayList&lt;String&gt;();<break/>
					//add some stuff<break/>
					list.add("android");<break/>
					list.add("apple");<break/>
					String[] stringArray = list.toArray(new String[0]);<break/>
					<delay>2</delay>
					The toArray() method without passing any argument returns Object[].
					<delay>2</delay>
					So you have to pass an array as an argument, which will be filled with 
					the data from the list, and returned.
					<delay>2</delay>
					You can pass an empty array as well, but you can also pass an array with 
					the desired size.
					<delay>2</delay>
					Important update: Originally the code above used new String[list.size()].
					<delay>2</delay>
					However, this blogpost reveals that due to JVM optimizations, using new 
					String[0] is better now.
				</li>
				<li>
					This snippen should work:<break/>
					List &lt;String&gt; list = ...<break/>String[] array = new String[list.size()];<break/>
					int i=0;<break/>
					for(String s: list){<break/>
					  array[i++] = s;<break/>
					}<break/>
				</li>
				<li>
					This is what I would do:<break/>
					ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();<break/>
					Object[] objectList = arrayList.toArray();<break/>
					String[] stringArray =  Arrays.copyOf(objectList,objectList.length,String[].class);<break/>
					<delay>2</delay>
					Using copyOf, ArrayList to arrays might be done also.
					<delay>2</delay>
				</li>
				<li>
					An alternative in Java 8:
					String[] strings = list.stream().toArray(String[]::new);<break/>
					Java 11+:<break/>
					String[] strings = list.toArray(String[]::new);<break/>
				</li>
				<li>
					You can use the toArray() method for List:
					ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();<break/>
					list.add("apple");<break/>
					list.add("banana");<break/>
					String[] array = list.toArray(new String[list.size()]);<break/>
					<delay>2</delay>
					Or you can manually add the elements to an array:
					ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();<break/>
					list.add("apple");<break/>
					list.add("banana");<break/>
					String[] array = new String[list.size()];<break/>
					for (int i = 0; i &lt; list.size(); i++) {<break/>
					    array[i] = list.get(i);<break/>
					}<break/>
					Hope this helps!
				</li>
				<li>
					In Java 8:
					String[] strings = list.parallelStream().toArray(String[]::new);<break/>
				</li>
				<li>
					In case some extra manipulation of the data is desired, for which the user wants a function, this approach is not perfect (as it requires passing the class of the element as second parameter), but works:
					import java.util.ArrayList;
					import java.lang.reflect.Array;
					public class Test {<break/>
					  public static void main(String[] args) {<break/>
					    ArrayList&lt;Integer&gt; al = new ArrayList&lt;&gt;();<break/>
					    al.add(1);<break/>
					    al.add(2);<break/>
					    Integer[] arr = convert(al, Integer.class);<break/>
					    for (int i=0; i&lt;arr.length; i++)<break/>
					      System.out.println(arr[i]);<break/>
					  }<break/>
					  public static &lt;T&gt; T[] convert(ArrayList&lt;T&gt; al, Class clazz) {<break/>
					    return (T[]) al.toArray((T[])Array.newInstance(clazz, al.size()));<break/>
					  }<break/>
					}<break/>
				</li>
				<li>
					You can use Iterator&lt;String&gt; to iterate the elements of the ArrayList&lt;String&gt;:
					ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();<break/>
					String[] array = new String[list.size()];<break/>
					int i = 0;<break/>
					for (Iterator&lt;String&gt; iterator = list.iterator(); iterator.hasNext(); i++) {<break/>
					    array[i] = iterator.next();<break/>
					}<break/>
					<delay>2</delay>
					Now you can retrive elements from String[] using any Loop.
				</li>
				<li>
					You can convert List to String array by using this method:
					Object[] stringlist=list.toArray();<break/>

					<delay>2</delay>
					The complete example:
					ArrayList&lt;String&gt; list=new ArrayList&lt;&gt;();<break/>
					list.add("Abc");<break/>
					list.add("xyz");<break/>
					Object[] stringlist=list.toArray();<break/>
					for(int i = 0; i &lt; stringlist.length ; i++)<break/>
					{<break/>
						Log.wtf("list data:",(String)stringlist[i]);<break/>
					}<break/>
				</li>
				<li>
					
					Starting from Java-11, one can alternatively use the API Collection.toArray(IntFunction&lt;T[]&gt; generator) to achieve the same as:
					List&lt;String&gt; list = List.of("x","y","z");<break/>
					String[] arrayBeforeJDK11 = list.toArray(new String[0]);<break/>
					String[] arrayAfterJDK11 = list.toArray(String[]::new); // similar to Stream.toArray<break/>
				</li>
				<li>
					In Java 8, it can be done using
					String[] arrayFromList = fromlist.stream().toArray(String[]::new);<break/>
				</li>
				<li>
					In Java 11, we can use the Collection.toArray(generator) method.
					<delay>2</delay>
					The following code will create a new array of strings:
					<delay>2</delay>
					List&lt;String&gt; list = List.of("one", "two", "three");<break/>
					String[] array = list.toArray(String[]::new)<break/>
					from java.base's  java.util.Collection.toArray().
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ converting ^ arraylist ^ array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ convert ^ arraylist ^ array ^</pattern>
		<template><srai>^ converting ^ arraylist ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ transform ^ arraylist ^ array ^</pattern>
		<template><srai>^ converting ^ arraylist ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ arraylist ^ array ^</pattern>
		<template><srai>^ converting ^ arraylist ^ array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 57. Can I add a group of ArrayList into a single ArrayList? -->
			^ add ^ group ^ arraylist ^ single arraylist ^
		</pattern>
		<template>
			<random>
				<li>
					I hope I understand your question correctly.
					<delay>2</delay>
					An ArrayList is a list of Object types.
					<delay>2</delay>
					If you wish to add an ArrayList as the item in your ArrayList, then you 
					can do this.
					<delay>2</delay>
					An example
					ArrayList list = new ArrayList();<break/>
					ArrayList list2 = new ArrayList();<break/>
					ArrayList list3 = new ArrayList();<break/>
					list.add(list2);<break/>list.add(list3);<break/>
					<delay>2</delay>
					This will result in your first ArrayList (list) containing two arraylists 
					in position 0 and 1.
					<delay>2</delay>
					If however you are looking to add the contents of several ArrayLists to 
					a single list of elements, then you use addAll on the  ArrayList.
					<delay>2</delay>
					Such as
					ArrayList consolidatedList = new ArrayList();<break/>
					list.addAll(list2);<break/>list.addAll(list3);<break/>
					<delay>2</delay>
				</li>
				<li>
					Yes you can add a "group of ArrayLists" into a single array list.
					<delay>2</delay>
					If you want to "recognize" your ArrayLists, I would recommend using a Map
					, a HashMap for example.
					<delay>2</delay>
					Please also think about accepting answers to your other questions, and 
					post code in your questions, you will get better help and people will 
					hate you less.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ add ^ group ^ arraylist ^ single arraylist ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ add ^ arraylists ^ single arraylist ^</pattern>
		<template><srai>^ add ^ group ^ arraylist ^ single arraylist ^</srai></template>
  </category>
	<category>
		<pattern>^ add ^ group ^ arraylist ^ arraylist ^</pattern>
		<template><srai>^ add ^ group ^ arraylist ^ single arraylist ^</srai></template>
  </category>
	<category>
		<pattern>^ add ^ arraylists ^ arraylist ^</pattern>
		<template><srai>^ add ^ group ^ arraylist ^ single arraylist ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 58. Maximum number of dimensions in a Java array -->
			^ maximum number ^ dimensions ^ array ^
		</pattern>
		<template>
			<random>
				<li>
					Strictly speaking about Maximum number of dimensions in a Java array<break/>
					is only one dimensional array is possible in java.
					<delay>2</delay>
					because under the hood java treat multidimensional arrays as array of arrays.

					<delay>2</delay>
					that's why its possible to have ragged arrays in Java as well!
				</li>
				<li>
					Small experiment shows, that 255 dimensions is maximum.
					<delay>2</delay>
					256 causes compilation error;
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ maximum number ^ dimensions ^ array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ maximum number ^ dimensions ^ array ^</pattern>
		<template><srai>^ maximum number ^ dimensions ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ maximum ^ dimensions ^ array ^</pattern>
		<template><srai>^ maximum number ^ dimensions ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ array ^ maximum ^ dimensions ^</pattern>
		<template>^ maximum number ^ dimensions ^ array ^<srai></srai></template>
  </category>
	<category>
		<pattern>
			<!-- 59. How to read a file into a Java Bitmap? -->
			^ read ^ file ^ bitmap 
		</pattern>
		<template>
			<random>
				<li>
					Use BitmapFactory if you already have your byte array:
					Bitmap bitmap = BitmapFactory.decodeByteArray(yourByteArray, offset, length);<break/>
				</li>
				<li>
					Skip the byte array if you want:
					Bitmap bitmap = BitmapFactory.decodeFile(filename);
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ read ^ file ^ bitmap ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ load ^ file ^ bitmap ^</pattern>
		<template><srai>^ read ^ file ^ bitmap </srai></template>
  </category>
	<category>
		<pattern>^ store ^ file ^ bitmap </pattern>
		<template><srai>^ read ^ file ^ bitmap </srai></template>
  </category>
	<category>
		<pattern>
			<!-- 60. can I copy an array to a hash table? -->
			^ copy ^ array ^ hash table ^
		</pattern>
		<template>
			<random>
				<li>
					You can easily put them into a Hashtable of int -> float.  
					<delay>2</delay>
					The following method will use their index in the array as the key.
					float[] arr;<break/>
					Hashtable&lt;Integer, Float&gt; table = new Hashtable&lt;Integer, Float&gt;(arr.length);<break/>
					for (int i = 0; i &lt; arr.length; i++) {<break/>
					    table.put(i, arr[i]);<break/>
					}<break/>
				</li>
				<li>
					Hashtable implements Map, so you would need to pair every float with some key. 
				</li>
				<li>
					An array cannot directly correspond to a Map.
					<delay>2</delay>
					It can correspond to a set.
					<delay>2</delay>
					new HashSet(Arrays.asList(array))<break/>
				</li>
				<li>
					Given the OP's clarification of his/her requirements in jjnguy's answer, here's an O(n) (amortized) way to count occurrences of unique values in a float array:
					float[] values;<break/>
					Map&lt;Float, Integer&gt; occurrences = new HashMap&lt;Float, Integer&gt;();<break/>
					for ( float f : values ) {<break/>
					    int count = occurrences.containsKey(f) ? occurrences.get(f) : 0;<break/>
					    occurrences.put(f, count+1);<break/>
					}<break/>
					//then find multiple occurrences by finding entries with a value &gt; 0<break/>
					for ( Entry&lt;Float, Integer&gt; entry : occurrences.values() ) {<break/>
					    if ( entry.getValue() &gt; 1 ) {<break/>
					       System.out.println("Duplicate: " + entry.getKey());<break/>
					    }<break/>
					}<break/>
					<delay>2</delay>
					In practice it's usually smelly to use a float as a key to anything, or 
					to use a float in a way that pretends it's a discrete value.  
					<delay>2</delay>
					Floating point types are typically used to simulate "continuous" values
					, where for all intents and purposes 7.000000000012 should be considered 
					the same as 7.000000000013.
				</li>
				<li>
					If you want to know how many there are of different float values in your 
					array, the best solution would be a multiset (which is typically built 
					on top of a Map&lt;T, Integer&gt;).
					<delay>2</delay>
					With Guava, you could do this:
					float[] floats = ...<break/>
					Multiset&lt;Float&gt; multiset = HashMultiset.create(Floats.asList(floats));<break/>
					for (Multiset.Entry&lt;Float&gt; entry : multiset.entrySet()) {<break/>
					  Float value = entry.getElement();<break/>
					  int count = entry.getCount();<break/>
					  ...<break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ copy ^ array ^ hash table ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ array ^ copied ^ hash table ^</pattern>
		<template><srai>^ copy ^ array ^ hash table ^</srai></template>
  </category>
	<category>
		<pattern>^ store ^ array ^ hash table ^</pattern>
		<template><srai>^ copy ^ array ^ hash table ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 61. Copy 2 array in a new one -->
			^ copy 2 array ^ one ^
		</pattern>
		<template>
			<random>
				<li>
					Using System.arraycopy takes advantage of the underlying hardware to perform the 
					array copy as efficiently as possible.
					<delay>2</delay>
					In the context of the question you would need to call System.arraycopy twice; e.g.
					int[] dest = new int[10];<break/>
					int[] src1 = new int[5];<break/>
					int[] src2 = new int[5];<break/>
					// Populate source arrays with test data.<break/>
					for (int i=0; i&lt;5; ++i) {<break/>
					  src1[i] = i;<break/>
					  src2[i] = i + 100;<break/>
					}<break/>
					System.arraycopy(src1, 0, dest, 0, src1.length);<break/>
					System.arraycopy(src2, 0, dest, src1.length, src2.length);<break/>
				</li>
				<li>
					You can use [System.arraycopy][1]
					<delay>2</delay>
					Here is an example
					<delay>2</delay>
					<button>
						<text>Array copy</text>
					  <url>http://download.oracle.com/javase/1.4.2/docs/api/java/lang/System.html#arraycopy(java.lang.Object, int, java.lang.Object, int, int)</url>
					</button>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ copy 2 array ^ new ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ save 2 array ^ new ^</pattern>
		<template><srai>^ copy 2 array ^ new ^</srai></template>
  </category>
	<category>
	  <pattern>^ copy two array ^ new ^</pattern>
		<template><srai>^ copy 2 array ^ new ^</srai></template>
  </category>
	<category>
	  <pattern>^ copy 2 arrays ^ new ^</pattern>
		<template><srai>^ copy 2 array ^ new ^</srai></template>
  </category>
	<category>
	  <pattern>^ save 2 arrays ^ new ^</pattern>
		<template><srai>^ copy 2 array ^ new ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 62. How to convert a byte array to a string? -->
			^ convert ^ byte array ^ string ^
		</pattern>
		<template>
			<random>
				<li>
					The Best way to convert bytearray to String is 
					public void convertByteArrayToString(Charset encoding) {<break/>
						byte[] byteArray = new byte[] {87, 79, 87, 46, 46, 46};<break/>
						String value = new String(byteArray, encoding);<break/>
						System.out.println(value);<break/>
					}<break/>
				</li>
				<li>
					You need to supply an encoding, otherwise you get the system default encoding, 
					essentially a random value.
					<delay>2</delay>
					String value = new String(byteArray, encoding);<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ convert ^ byte array ^ string ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ transform ^ byte array ^ string ^</pattern>
		<template><srai>^ convert ^ byte array ^ string ^</srai></template>
  </category>
	<category>
	  <pattern>^ save ^ byte array ^ string ^</pattern>
		<template><srai>^ convert ^ byte array ^ string ^</srai></template>
  </category>
	<category>
	  <pattern>^ byte array ^ string ^</pattern>
		<template><srai>^ convert ^ byte array ^ string ^</srai></template>
  </category>
	<category>
	  <pattern>^ string ^ byte array ^</pattern>
		<template><srai>^ convert ^ byte array ^ string ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 63. best way to convert an array of strings to a vector? -->
			^ convert ^ array ^ strings ^ vector ^
		</pattern>
		<template>
			<random>
				<li>
					Call the constructor of Vector that uses an existing collection (your array, in 
					this case) to initialize itself:
					String[] strings = { "Here", "Are", "Some", "Strings" };<break/>
					Vector&lt;String&gt; vector = new Vector&lt;String&gt;(Arrays.asList(strings));<break/>
				</li>
				<li>
					Vector&lt;String&gt; strVector = new Vector&lt;String&gt;(Arrays.asList(strArray));<break/>
					Breaking this down:
					Arrays.asList(array) converts the array to a List (which implements Collection)
					<delay>2</delay>
					The Vector(Collection) constructor takes a Collection and instantiates a new Vector 
					based off of it. 
					<delay>2</delay>
					We pass the new List to the Vector constructor to get a new Vector&lt;String&gt; strVector = new Vector&lt;String&gt;(Arrays.asList(strArray));<break/>
					0 from the array of Vector&lt;String&gt; strVector = new Vector&lt;String&gt;(Arrays.asList(strArray));<break/>
					1s, then save the reference to this object in Vector&lt;String&gt; strVector = new Vector&lt;String&gt;(Arrays.asList(strArray));<break/>
				</li>
				<li>
					This could be a solution:<break/>
					new Vector(Arrays.asList(array))<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ convert ^ array ^ strings ^ vector ^</postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ transform ^ array ^ strings ^ vector ^</pattern>
		<template><srai>^ convert ^ array ^ strings ^ vector ^</srai></template>
  </category>
	<category>
	  <pattern>^ array ^ strings ^ vector ^</pattern>
		<template><srai>^ convert ^ array ^ strings ^ vector ^</srai></template>
  </category>
	<category>
	  <pattern>^ save ^ array ^ strings ^ vector ^</pattern>
		<template><srai>^ convert ^ array ^ strings ^ vector ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 64. What is the different between a stackoverflow and arrayindexoutofbounds? -->
			^ difference ^ stackoverflow ^ arrayindexoutofbounds ^
		</pattern>
		<template>
			<random>
				<li>
					StackOverflowError occurs during endless recursive calls.
					<delay>2</delay>
					It has nothing to do with arrays.
					<delay>2</delay>
					ArrayIndexOutOfBoundsException occurs when when you try to use an index beyond 
					the size of the array.
				</li>
				<li>
					arrayindexoutofbounds : The exception that is thrown when an attempt is made to 
					read beyond the bounds of an array.
					<delay>2</delay>
					stackoverflow : An error that is issued when a stack overflow occurs.
				</li>
				<li>
					StackOverFlowError:
					Occurs when the JVM (Java Virtual Memory) is running out of allocated heap space.
					<delay>2</delay>
					ArrayIndexOutOfBoundsException: 
					<delay>2</delay>
					Occurs when an application tries to access the array index which does not fall 
					in declared range.
				</li>
				<li>
					Arrayindexoutofbounds:
					<delay>2</delay>
					You limit your variable for example defining an array with size of 50 and if you 
					want to use the 51 element of that array you get this exception.
					<delay>2</delay>
					Stackoverflow: Think about that you didn't limit your variable for example; 
					List myList = new List();<break/>
					<delay>2</delay>
					And you are adding elements to this list.
					<delay>2</delay>
					myList.add(something);<break/>
					<delay>2</delay>
					If you add too much element that your heap memory can't allocate any more space 
					to keep your variable it throws that exception.
					<delay>2</delay>
					At first your limit is 50, at 51 you get an exception, at second you don't get an exception at 51.
					<delay>2</delay>
					element if your heap is free enough but you can get an exception when your heap not enough for you.
				</li>
				<li>
					These two are actually very different things.
					<delay>2</delay>
					As the other guys have already mentioned, ArrayIndexOutOfBoundsException is an 
					Exception that occurs when you are trying to access an array using an incorrect index.
					<delay>2</delay>
					This could be caused by a very simple bug in programming logic.
					<delay>2</delay>
					StackOverflowError is something more low-level.
					<delay>2</delay>
					It has nothing to do with arrays and, contrary to what the other guys said, has 
					nothing to do with the heap either.
					<delay>2</delay>
					Try doing that trick with a List and you'll get an OutOfMemoryError instead.
					<delay>2</delay>
					Now it's an Error that is much more similar to StackOverflowError than ArrayIndexOutOfBoundsException.
					<delay>2</delay>
					Both OutOfMemoryError and StackOverflowError indicate that you're running out 
					of memory, only in different segments.
					<delay>2</delay>
					Running out of stack memory almost always occurs due to infinite recursion (unless 
					you have a ridiculously long chain of methods calling each other with lots of 
					local variables in them), and running out of heap memory happens when you allocate 
					too much and keep all those references so even the garbage collector can't free 
					some memory for you.
					<delay>2</delay>
					So when ArrayIndexOutOfBoundsException is indeed "sticking data where it shouldn
					't go", StackOverflowError and OutOfMemoryError are better described as "running 
					out of memory to stick your data into".
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ difference ^ stackoverflow ^ arrayindexoutofbounds ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ differences ^ stackoverflow ^ arrayindexoutofbounds ^</pattern>
		<template><srai>^ difference ^ stackoverflow ^ arrayindexoutofbounds ^</srai></template>
  </category>
	<category>
	  <pattern>^ difference ^ arrayindexoutofbounds ^ stackoverflow ^</pattern>
		<template><srai>^ difference ^ stackoverflow ^ arrayindexoutofbounds ^</srai></template>
  </category>
	<category>
	  <pattern>^ differs ^ stackoverflow ^ arrayindexoutofbounds ^</pattern>
		<template><srai>^ difference ^ stackoverflow ^ arrayindexoutofbounds ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 65. Java Array Destroy -->
			^ array ^ destroy ^
		</pattern>
		<template>
			<random>
				<li>
					Only if Array_Name had actually been referencing an array to begin with.
					<delay>2</delay>
					And only if there are no other references to the array.
					<delay>2</delay>
					And it will reclaim only those elements of the array which aren't referenced by 
					anything outside of the array.
					<delay>2</delay>
					And it will only do so when it feels like getting around to it :-)
					<delay>2</delay>
					(The syntax Array_Name[] = NULL isn't really meaningful.
					<delay>2</delay>
					But I'm assuming you'd done something like:
					<delay>2</delay>
					Foo[] Array_Name = new Foo[n];<break/>
					 //...<break/>
					 Array_Name = null; // Note the lowercase "null"<break/>
					This might make the array a proper target for garbage collection, given the conditions 
					I described above.)
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ array ^ destroy ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ destroy ^ array ^</pattern>
		<template><srai>^ array ^ destroy ^</srai></template>
  </category>
	<category>
	  <pattern>^ array ^ delete ^</pattern>
		<template><srai>^ array ^ destroy ^</srai></template>
  </category>
	<category>
	  <pattern>^ delete ^ array ^</pattern>
		<template><srai>^ array ^ destroy ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 66. Why does Java allow arrays of size 0? -->
			^ arrays ^ size 0 ^
		</pattern>
		<template>
			<random>
				<li>
					Sometimes it's much more friendly to return a zero size array than null.
				</li>
				<li>
					It signifies that it is empty.
					<delay>2</delay>
					I.e. you can loop over it as if it had items and have no result occur:
					for(int k = 0; k &lt; strings.length; k++){<break/>
					   // something<break/>
					}<break/>
					<delay>2</delay>
					Thereby avoiding the need to check.
					<delay>2</delay>
					If the array in question were null, an exception would occur, but in this case 
					it just does nothing, which may be appropriate.
				</li>
				<li>
					Same as C++, it allows for cleaner handling when there is no data.
				</li>
				<li>
					Why does Java allow arrays of size 1?
					<delay>2</delay>
					Isn't it pretty useless to wrap a single value in an array?
					<delay>2</delay>
					Wouldn't it be sufficient if Java only allowed arrays of size 2 or greater?
					<delay>2</delay>
					Yes, we can pass null instead of an empty array and a single object or primitive 
					instead of a size-one-matrix.
					<delay>2</delay>
					But there are some good arguments against such an restriction.
					<delay>2</delay>
					My personal top arguments:
					<delay>2</delay>
					Restriction is too complicated and not really necessary
					To limit arrays to sizes [1..
					<delay>2</delay>
					INTEGER.MAX_INT] we'd have to add a lot of additional boudary checks,(agree to 
					Konrads comment) conversion logic and method overloads to our code.
					<delay>2</delay>
					Excluding 0 (and maybe 1) from the allowed array sizes does not save costs, it 
					requires additional effort and has an negative impact on performance.
					<delay>2</delay>
					Array models vector
					<delay>2</delay>
					An array is a good data model for a vector (mathematics, not the Vector class!).
					<delay>2</delay>
					And of course, a vector in mathematics may be zero dimensional.
					<delay>2</delay>
					Which is conceptually different from being non-existant.
					<delay>2</delay>
					Sidenote - a prominent wrapper for an (char-)array is the String class.
					<delay>2</delay>
					The immutable String materializes the concept of an empty array: it is the empty 
					String ("").
				</li>
				<li>
					One case I can think of where an empty array is extremely useful is to use it 
					instead of null in a situation where null isn't allowed.
					<delay>2</delay>
					One possible example of that is a BlockingQueue of arrays.
					<delay>2</delay>
					When you want to signal the end of input to the reading side, what would you do?
					<delay>2</delay>
					To send null seems like an obvious choice, but the thing is that BlockingQueue 
					doesn't accept nulls.
					<delay>2</delay>
					You could wrap your array inside a class with "boolean last;" kind of field, but 
					that's kind of overkill.
					<delay>2</delay>
					Sending an empty (zero-sized) array seems like the most reasonable choice.
				</li>
				<li>
					Another case where a zero length array can be useful:
					To return an array containing all of the elements in a list : 
					&lt;T&gt; T[ ] toArray(T[ ] a)<break/>
					<delay>2</delay>
					A zero length array can be used to pass the type of the array into this method.
					<delay>2</delay>
					For example:
					ClassA[ ] result = list.toArray(new ClassA[0]);<break/>
					<delay>2</delay>
					A zero length array is still an instance of Object which holds zero elements.
				</li>
				<li>
					Another case when a zero length array is useful is when copying a two dimensional array.
					<delay>2</delay>
					I can write:
					public int[][] copyArray(int[][] array){<break/>
						int[][] newArray = new int[array.length][0];<break/>
						for(int i=0;i&lt;array.length;i++){<break/>
								newArray[i] = array[i];<break/>
						}<break/>
						return newArray;<break/>
					Being that every array reference in array is being overwritten, initializing them 
					as refernces to zero length arrays is most efficient.
				</li>
				<li>
					0-length byte[], or char[] can represent an empty String, which is distinct from null.
					<delay>2</delay>
					Getting the bytes, or characters, as arrays from strings (using getBytes(), getChars() of String class etc.)
					<delay>2</delay>
					and the vice-versa of forming Strings from byte[], byte[]0 is quite common.
					<delay>2</delay>
					For example, for custom encoding, decoding of strings. 
					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ arrays ^ size 0 ^</postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ arrays ^ size zero ^</pattern>
		<template><srai>^ arrays ^ size 0 ^</srai></template>
  </category>
	<category>
	  <pattern>^ size 0 ^ arrays ^</pattern>
		<template><srai>^ arrays ^ size 0 ^</srai></template>
  </category>
	<category>
	  <pattern>^ size zero ^ arrays</pattern>
		<template><srai>arrays ^ size 0 ^</srai></template>
  </category>
	<category>
	  <pattern>^ array ^ size 0 ^</pattern>
		<template><srai>^ arrays ^ size 0 ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 67. Memory Address of Array - Java -->
			^ memory address ^ array ^
		</pattern>
		<template>
			<random>
				<li>
					You can't.
					<delay>2</delay>
					Java doesn't have direct memory access.
					<delay>2</delay>
				</li>
				<li>
					There is no programmer-realizable notion of an "address" in Java.  
					<delay>2</delay>
					In a language like C or C++, objects' identities are equated with
					<delay>2</delay>
					their address - two objects are the same object if they live in the same memory 
					location.  
					<delay>2</delay>
					In Java, this notion of identity is decoupled from the object's address.  
					<delay>2</delay>
					This allows some optimizations that are not possible in C++.  
					<delay>2</delay>
					For example, the garbage collector could, in theory, move objects around in memory 
					to avoid fragmentation, so long as it modifies references so they point to the 
					right location.  
					<delay>2</delay>
					Because memory addresses can't be accessed directly by the programmer, this operation 
					is permissible.  
					<delay>2</delay>
					In C++, it wouldn't work, because the compiler couldn't tell if a particular bit 
					pattern in memory was some sort of encoded pointer.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ memory address ^ array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ array ^ memory address ^</pattern>
		<template><srai>^ memory address ^ array ^</srai></template>
  </category>
	<category>
	  <pattern>^ memory address ^ arrays ^</pattern>
		<template><srai>^ memory address ^ array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 68. In Java, do primitive types and arrays have a containing package? -->
			^ primitive types ^ arrays ^ containing package ^
		</pattern>
		<template>
			<random>
				<li>
					No they don't have,as they aren't class.
					<delay>2</delay>
					Primitive: A primitive type is predefined by the language and is named by a reserved keyword. 
					<delay>2</delay>
					array: An array is a container object that holds a fixed number of values of a single type.
				</li>
				<li>
					Simple Answer
					Let's test:
					public static void main(final String[] args){<break/>
					    System.out.println(long.class.getPackage());<break/>
					    System.out.println(Object[].class.getPackage());<break/>
					}<break/>
					Output: null, null  
					<delay>2</delay>
					No they don't :-)
					<delay>2</delay>
					Primitive Types
					Primitive classes are special constructs that don't have a package.
					<delay>2</delay>
					For reference, see the source of Long.TYPE, the alias for long.class:
					/**<break/>
					 * The &lt;code&gt;Class&lt;/code&gt; instance representing the primitive type<break/>
					 * &lt;code&gt;long&lt;/code&gt;.<break/>
					 *<break/>
					 * @since   JDK1.1<break/>
					 */<break/>
					public static final Class&lt;Long&gt; TYPE = (Class&lt;Long&gt;) Class.getPrimitiveClass("long");<break/>
					As you can see, a primitive class is loaded through a package-private and native 
					mechanism:
					<delay>2</delay>
					static native Class getPrimitiveClass(String name);<break/>
					and casted to Class&lt;Long&gt; (in order to enable auto-boxing, I guess)
					Wrapper Types and their Primitive Types
					<delay>2</delay>
					BTW: every wrapper class has a static final field called TYPE that maps to the corresponding primitive class, as the following code shows:
					private static Class&lt;?&gt; getPrimitiveClass(final Class&lt;?&gt; wrapperClass){<break/>
					    try{<break/>
					        final Field field = wrapperClass.getDeclaredField("TYPE");<break/>
					        final int modifiers = field.getModifiers();<break/>
					        if(Modifier.isPublic(modifiers) &amp;&amp; Modifier.isStatic(modifiers)<break/>
					            &amp;&amp; Modifier.isFinal(modifiers)<break/>
					            &amp;&amp; Class.class.equals(field.getType())){<break/>
					            return (Class&lt;?&gt;) field.get(null);<break/>
					        } else{<break/>
					            throw new IllegalArgumentException("This is not a wrapper class: "<break/>
					                + wrapperClass);<break/>
					        }<break/>
					    } catch(final NoSuchFieldException e){<break/>
					        throw new IllegalArgumentException("This is not a wrapper class:"<break/>
					            + wrapperClass + ", field TYPE doesn't exists.", e);<break/>
					    } catch(final IllegalAccessException e){<break/>
					        throw new IllegalArgumentException("This is not a wrapper class:"<break/>
					            + wrapperClass + ", field TYPE can't be accessed.", e);<break/>
					    }<break/>
					}<break/>
					public static void main(final String[] args){<break/>
					    final List&lt;Class&lt;?&gt;&gt; wrappers =<break/>
					        Arrays.&lt;Class&lt;?&gt;&gt; asList(<break/>
					            Byte.class, Long.class, Integer.class,<break/>
					            Short.class, Boolean.class, Double.class<break/>
					            // etc.<break/>
					        );<break/>
					    for(final Class&lt;?&gt; clazz : wrappers){<break/>
					        System.out.println("Wrapper type: " + clazz.getName()<break/>
					            + ", primitive type: "<break/>
					            + getPrimitiveClass(clazz).getCanonicalName());<break/>
					    }<break/>
					}<break/>
					Output: Wrapper type: java.lang.Byte, primitive type: byte<break/>
					Wrapper type: java.lang.Long, primitive type: long<break/>
					Wrapper type: java.lang.Integer, primitive type: int<break/>
					Wrapper type: java.lang.Short, primitive type: short<break/>
					Wrapper type: java.lang.Boolean, primitive type: boolean<break/>
					Wrapper type: java.lang.Double, primitive type: double 
					<delay>2</delay>
					Array Types<break/>
					Arrays can be created through Array.newInstance(type, length), which internally calls this method:
					public static void main(final String[] args){<break/>
					    System.out.println(long.class.getPackage());<break/>
					    System.out.println(Object[].class.getPackage());<break/>
					}<break/>
					so again, the classes are special constructs created by native code (and they 
					don't have a package, or else you could find them somewhere)
					<delay>2</delay>
				</li>
				<li>
					No, but there are objects to wrap primitive data types in the java.lang package. 
					<delay>2</delay>
					<button>
					  <text>Java wrapper</text>
						<url>http://download.oracle.com/javase/6/docs/api/java/lang/package-summary.html</url>
				  </button>
				</li>
				<li>
					No since they are language constructs and not classes per-se. 
					<delay>2</delay>
					You can however have a class representing a primitive type in the wrapper for instance: Integer.
					<delay>2</delay>
					TYPE et al. useful for reflection. 
					<delay>2</delay>
					But you'll see that still those don't have a package ie.
					<delay>2</delay>
					Integer.TYPE.getPackage()<break/>
					Returns null
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ primitive types ^ arrays ^ containing package ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ primitive types ^ arrays ^ package ^</pattern>
		<template><srai>^ primitive types ^ arrays ^ containing package ^</srai></template>
  </category>
	<category>
	  <pattern>^ primitive types ^ array ^ containing package ^</pattern>
		<template><srai>^ primitive types ^ arrays ^ containing package ^</srai></template>
  </category>
	<category>
	  <pattern>^ primitive type ^ arrays ^ containing package ^</pattern>
		<template><srai>^ primitive types ^ arrays ^ containing package ^</srai></template>
  </category>
	<category>
	  <pattern>^ arrays ^ primitive types ^ containing package ^</pattern>
		<template><srai>^ primitive types ^ arrays ^ containing package ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 69. Can you extend ArrayList in Java? -->
			^ extend arraylist ^
		</pattern>
		<template>
			<random>
				<li>
					You can extend any class that is not final in Java.
					<delay>2</delay>
					Having said that, you should avoid inheritance if there is no true is-a relationship.
					<delay>2</delay>
					Consider composition for reuse.
					<delay>2</delay>
					Read about Liskov substitution principle
					<delay>2</delay>
				</li>
				<li>
					Just try it out.
					<delay>2</delay>
					The class is not final, it's constructor is public, so you can.
					<delay>2</delay>
					However, it's probably no good idea for a beginner.
					<delay>2</delay>
					Most of the time, it's no good idea for anyone.
					<delay>2</delay>
					Imagine you add some functionality and get ExtList1 extends ArrayList.
					<delay>2</delay>
					A college of yours adds a different independent functionality, so you have ExtList2 
					extends ArrayList.
					<delay>2</delay>
					Now you want them both at once and you're out of luck.
					<delay>2</delay>
					Or you need the same feature with a different base list implementation (maybe 
					LinkedList, though it's virtually always wrong to use it).
					<delay>2</delay>
					Again, out of luck.
					<delay>2</delay>
					These are all cases when delegation wins.
					<delay>2</delay>
					It needn't be more verbose when someone has created the base already.
					<delay>2</delay>
					I'd only inherit from ArrayList, if there was a very good reason for doing exactly 
					this.
					<delay>2</delay>
					Maybe some really extreme performance requirements based on proper JMH benchmarks.
				</li>
				<li>
					Yes you can.
					<delay>2</delay>
					public class MyArrayList&lt;E&gt; extends ArrayList&lt;E&gt;{}<break/>
					<delay>2</delay>
					However, I'm not sure why you would want to do this.
				</li>
				<li>
					ArrayList is not final class and it provides public constructor, so technically 
					it can be extended.
					<delay>2</delay>
					But best practice is delegate rather than extend.
					<delay>2</delay>
					See: Decorator pattern
				</li>
				<li>
					Extending java lang data structures is a very bad idea.
					<delay>2</delay>
					However, if you have some logic you want to isolate in a collection class, I would suggest bellow solution:
					public class ProductCollection{<break/>
					    ArrayList&lt;Product&gt; products;<break/>
					    public Product getByCode(String code) {<break/>
					       // ... your logic goes here.<break/>
					    }<break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ extend arraylist ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ arraylist ^ extension ^</pattern>
		<template><srai>^ extend arraylist ^</srai></template>
  </category>
	<category>
	  <pattern>^ extend arraylists ^</pattern>
		<template><srai>^ extend arraylist ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 70. Java getting array keys -->
			^ getting array keys ^
		</pattern>
		<template>
			<random>
				<li>
					The Map collection has a keySet() method, and I think that's the closest thing 
					to PHP's associative arrays in Java. 
				</li>
				<li>
					Well, in Java I think the only way to have non integer keys is to use the Map 
					class:
					<button>
					  <text>Map class</text>
						<url>http://download.oracle.com/javase/6/docs/api/java/util/Map.html</url>
				  </button>
					<delay>2</delay>
					And as you can see it has a keySet function.
				</li>
				<li>
					Try to see this resource:<break/>
					
					<button>
					  <text>Key set</text>
						<url>http://download.oracle.com/javase/1.4.2/docs/api/java/util/HashMap.html#keySet()</url>
				  </button>
					This returns you a Java Set of the keys :)
					Another way is to iterate the Map and store the keys in Array/ArrayList
				</li>
				<li>
					Let me see if got this right, i know that php arrays have keys and values, nevertheless 
					in java thins does not work like that arrays and list
					<delay>2</delay>
					are index base, this means that your keys are just index in natural order.
					<delay>2</delay>
					if you can shared some code to look what do you exactly need that would be perfect
					, but in the mean time you might use Map
					Map&lt;String,String&gt; hashMap = new HashMap&lt;String,String&gt;();<break/>
					 hashMap.put("Key1","Value1");<break/>
					 hashMap.put("Key2","Value2");<break/>
					 hashMap.put("Key3","Value3");<break/>
					 hashMap.put("Key4","Value4");<break/>
					then you can use keySet() method to get the keys.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ getting array keys ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ get array keys ^</pattern>
		<template><srai>^ getting array keys ^</srai></template>
  </category>
	<category>
	  <pattern>^ retrieve array keys ^</pattern>
		<template><srai>^ getting array keys ^</srai></template>
  </category>
	<category>
	  <pattern>^ getting arrays keys ^</pattern>
		<template><srai>^ getting array keys ^</srai></template>
  </category>
	<category>
	  <pattern>^ find array keys ^</pattern>
		<template><srai>^ getting array keys ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 71. Where is Java's Array indexOf? -->
			^ array indexof ^
		</pattern>
		<template>
			<random>
				<li>
					Java ArrayList has an indexOf method.  
					<delay>2</delay>
					Java arrays have no such method.
					<delay>2</delay>
				</li>
				<li>
					You're probably thinking of the java.util.ArrayList, not the array.
				</li>
				<li>
					Arrays themselves do not have that method.  
					<delay>2</delay>
					A List, however, does: indexOf
				</li>
				<li>
					I don't recall of a "indexOf" on arrays other than coding it for yourself...
					<delay>2</delay>
					though you could probably use one of the many java.util.Arrays#binarySearch(...) 
					methods (see the Arrays javadoc) if your array contains primitive types
				</li>
				<li>
					The List interface has an indexOf() method, and you can obtain a List from your 
					array with Array's asList() method.
					<delay>2</delay>
					Other than that, Array itself has no such method.
					<delay>2</delay>
					It does have a binarySearch() method for sorted arrays.
				</li>
				<li>
					There are a couple of ways to accomplish this using the Arrays utility class.
					<delay>2</delay>
					If the array is not sorted and is not an array of primitives:
					java.util.Arrays.asList(theArray).indexOf(o)<break/>
					<delay>2</delay>
					If the array is primitives and not sorted, one should use a solution offered by 
					one of the other answers such as Kerem Baydoan's, Andrew McKinlay's or Mishax's.  
					<delay>2</delay>
					The above code will compile even if theArray is primitive (possibly emitting a 
					warning) but you'll get totally incorrect results nonetheless.
					<delay>2</delay>
					If the array is sorted, you can make use of a binary search for performance:
					java.util.Arrays.binarySearch(theArray, o)<break/>
				</li>
				<li>
					There is none.
					<delay>2</delay>
					Either use a java.util.List*, or you can write your own indexOf():
					<delay>2</delay>
					public static &lt;T&gt; int indexOf(T needle, T[] haystack)<break/>
					{<break/>
					    for (int i=0; i&lt;haystack.length; i++)<break/>
					    {<break/>
					        if (haystack[i] != null &amp;&amp; haystack[i].equals(needle)<break/>
					            || needle == null &amp;&amp; haystack[i] == null) return i;<break/>
					    }<break/>
					    return -1;<break/>
					}<break/>
					<delay>2</delay>
					*you can make one from your array using Arrays#asList()
				</li>
				<li>
					Array has no indexOf() method.
					<delay>2</delay>
					Maybe this Apache Commons Lang ArrayUtils method is what you are looking for
					import org.apache.commons.lang3.ArrayUtils;<break/>
					String[] colours = { "Red", "Orange", "Yellow", "Green" };<break/>
					int indexOfYellow = ArrayUtils.indexOf(colours, "Yellow");<break/>
				</li>
				<li>
					For primitives, if you want to avoid boxing, Guava has helpers for primitive arrays
					<delay>2</delay>
					e.g. Ints.indexOf(int[] array, int target)
				</li>
				<li>
					There is no direct indexOf function in java arrays.
				</li>
				<li>
					int findIndex(int myElement, int[] someArray){<break/>
					 int index = 0;<break/>
					 for(int n: someArray){<break/>
					   if(myElement == n) return index;<break/>
					   else index++;<break/>
					 }<break/>
					}<break/>
					Note: you can use this method for arrays of type int
					<delay>2</delay>
					, you can also use this algorithm for other types with minor changes
				</li>
				<li>
					Jeffrey Hantin's answer is good but it has some constraints, if its this do this 
					or else to that...
					<delay>2</delay>
					You can write your own extension method and it always works the way you want.
					<delay>2</delay>
					Lists.indexOf(array, x -&gt; item == x); // compare in the way you want<break/>
					<delay>2</delay>
					And here is your extension
					public final class Lists {<break/>
					    private Lists() {<break/>
					    }<break/>
					    public static &lt;T&gt; int indexOf(T[] array, Predicate&lt;T&gt; predicate) {<break/>
					        for (int i = 0; i &lt; array.length; i++) {<break/>
					            if (predicate.test(array[i])) return i;<break/>
					        }<break/>
					        return -1;<break/>
					    }<break/>
					    public static &lt;T&gt; int indexOf(List&lt;T&gt; list, Predicate&lt;T&gt; predicate) {<break/>
					        for (int i = 0; i &lt; list.size(); i++) {<break/>
					            if (predicate.test(list.get(i))) return i;<break/>
					        }<break/>
					        return -1;<break/>
					    }<break/>
					    public interface Predicate&lt;T&gt; {<break/>
					        boolean test(T t);<break/>
					    }<break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ array indexof ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ array ^ indexof ^</pattern>
		<template><srai>^ array indexof ^</srai></template>
  </category>
	<category>
	  <pattern>^ indexof ^ array ^</pattern>
		<template><srai>^ array indexof ^</srai></template>
  </category>
	<category>
	  <pattern>^ indexof ^ arrays ^</pattern>
		<template><srai>^ array indexof ^</srai></template>
  </category>
	<category>
	  <pattern>^ arrays ^ indexof ^</pattern>
		<template><srai>^ array indexof ^</srai></template>
  </category>
	<category>
	  <pattern>^ indexof ^ arrays ^</pattern>
		<template><srai>^ array indexof ^</srai></template>
  </category>
	<category>
		
		<pattern>
			<!-- 72. Java: How to convert a String of Binary values to a Float and vice-versa? -->
			^ convert ^ string ^ binary ^ float ^ vice ^ versa ^
		</pattern>
		<template>
			<random>
				<li>
					You can get the bit representation of a Java Float value using
					Float.floatToIntBits(float f);<break/>
					<delay>2</delay>
					Once you have done that you can test each bit of the resulting int in turn, starting 
					with the highest, and find out if it set, writing a '1' if it is set and a '0' if not.
				</li>
				<li>
					I'm not sure it is what you want, but here's a solution to have the binary representation 
					of the IEEE 754 floating-point "double format" bit layout for a float
					<delay>2</delay>
					(it is basically the memory representation of a float) :
					<delay>2</delay>
					int intBits = Float.floatToIntBits(yourFloat); <break/>
					String binary = Integer.toBinaryString(intBits);<break/>
					<delay>2</delay>
					For the reverse procedure :
					int intBits = Integer.parseInt(myString, 2);<break/>
					float myFloat = Float.intBitsToFloat(intBits);<break/>
				</li>
				<li>
					Working sample:
					class F { <break/>
					  public static void main( String ... args ) { <break/>
					    System.out.println(<break/>
					          Integer.toBinaryString( <break/>
					             Float.floatToIntBits(12345.12346f)<break/>
					          ) <break/>
					     );<break/>
					  }<break/>
					}<break/>
					Output:
					1000110010000001110010001111110<break/>
				</li>
				<li>
					For signed Floats, use Long or BigInteger to parse the string.
					<delay>2</delay>
					Casting by int causes the digit at first of 32 bits be intepreted as sign digit.
					<delay>2</delay>
					procedure :
					int intBits = Float.floatToIntBits(yourFloat); <break/>
					String binary = Integer.toBinaryString(intBits);<break/>
					reverse procedure :
					int intBits = new BigInteger(myString, 2).intValue();<break/>
					// int intBits = (int) Long.parseLong(myString, 2);<break/>
					float myFloat = Float.intBitsToFloat(intBits);<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ convert ^ string ^ binary ^ float ^ vice ^ versa ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ binary string ^ float ^ vice ^ versa ^</pattern>
		<template><srai>^ convert ^ string ^ binary ^ float ^ vice ^ versa ^</srai></template>
  </category>
	<category>
	  <pattern>^ float ^ binary string ^ vice ^ versa ^</pattern>
		<template><srai>^ convert ^ string ^ binary ^ float ^ vice ^ versa ^</srai></template>
  </category>
	<category>
	  <pattern>^ string ^ binary ^ float ^ vice ^ versa ^</pattern>
		<template><srai>^ convert ^ string ^ binary ^ float ^ vice ^ versa ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 73. How to store arrayList into an array in java? -->
			^ store arraylist ^ array ^
		</pattern>
		<template>
			<random>
				<li>
					You could use this:<break/>
					List list = getList();<break/>Object[] array = new Object[list.size()];<break/>
					for (int i = 0; i &lt; list.size(); i++)<break/>
					{<break/>
					  array[i] = list.get(i);<break/>
					}<break/>
					<delay>2</delay>
					Or just use List#toArray()
					<delay>2</delay>
				</li>
				<li>
					That depends on what you want:
					List&lt;String&gt; list = new ArrayList&lt;String&gt;();<break/>
					// add items to the list<break/>
					<delay>2</delay>
					Now if you want to store the list in an array, you can do one of these:
					Object[] arrOfObjects = new Object[]{list};<break/>
					List&lt;?&gt;[] arrOfLists = new List&lt;?&gt;[]{list};<break/>
					<delay>2</delay>
					But if you want the list items in an array, do one of these:
					Object[] arrayOfObjects = list.toArray();<break/>
					String[] arrayOfStrings = list.toArray(new String[list.size()]);<break/>
					Reference:<break/>
					Collection.toArray()<break/>
					Collection.toArray(T[])
				</li>
				<li>
					This should work:<break/>
					List&lt;Foo&gt; fooList = new ArrayList&lt;Foo&gt;();<break/>
					Foo[] fooArray = fooList.toArray(new Foo[0]);<break/>
				</li>
				<li>
					Try this:<break/>
					List list = new ArrayList();<break/>
					list.add("Blobbo");<break/>
					list.add("Cracked");<break/>
					list.add("Dumbo");<break/>
					// Convert a collection to Object[], which can store objects    <break/>
					Object[] ol = list.toArray();<break/>
				</li>
				<li>
					You mean you want to convert an ArrayList to an array?
					<delay>2</delay>
					Object[] array = new Object[list.size()];<break/>
					array = list.toArray(array);<break/>
					Choose the appropriate class.
				</li>
				<li>
					Try the generic method List.toArray():
					List&lt;String&gt; list = Arrays.asList("Foo", "Bar", "Gah");<break/>
					String array[] = list.toArray(new String[list.size()]);<break/>
					// array = ["Foo", "Bar", "Gah"]<break/>
				</li>
				<li>
					If Type is known (aka not a generics parameter) and you want an Array of Type:
					ArrayList&lt;Type&gt; list = ...;<break/>
					Type[] arr = list.toArray(new Type[list.size()]);<break/>
					Otherwise<break/>
					Object[] arr = list.toArray();<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ store arraylist ^ array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ save ^ arraylist ^ array ^</pattern>
		<template><srai>^ store arraylist ^ array ^</srai></template>
  </category>
	<category>
	  <pattern>^ put ^ arraylist ^ array ^</pattern>
		<template><srai>^ store arraylist ^ array ^</srai></template>
  </category>
	<category>
	  <pattern>^ convert ^ arraylist ^ array ^</pattern>
		<template><srai>^ store arraylist ^ array ^</srai></template>
  </category>
	<category>
		
		<pattern>
			<!-- 74. Convert array of strings into a string in Java -->
			^ convert array ^ strings ^ string ^
		</pattern>
		<template>
			<random>
				<li>
					Try the Arrays.toString overloaded methods.
					<delay>2</delay>
					Or else, try this below generic implementation:
					public static void main(String... args) throws Exception {<break/>
					    String[] array = {"ABC", "XYZ", "PQR"};<break/>
					    System.out.println(new Test().join(array, ", "));<break/>
					}<break/>
					public &lt;T&gt; String join(T[] array, String cement) {<break/>
					    StringBuilder builder = new StringBuilder();<break/>
					    if(array == null || array.length == 0) {<break/>
					        return null;<break/>
					    }<break/>
					    for (T t : array) {<break/>
					        builder.append(t).append(cement);<break/>
					    }<break/>
					    builder.delete(builder.length() - cement.length(), builder.length());<break/>
					    return builder.toString();<break/>
					}<break/>
				</li>
				<li>
					Use Apache commons StringUtils.join().  
					<delay>2</delay>
					It takes an array, as a parameter (and also has overloads for Iterable and Iterator 
					parameters) and calls toString() on each element (if it is not null) to get each 
					elements string representation.  
					<delay>2</delay>
					Each elements string representation is then joined into one string with a separator 
					in between if one is specified:
					<delay>2</delay>
				</li>
				<li>
					You could do this, given an array a of primitive type:
					StringBuffer result = new StringBuffer();<break/>
					for (int i = 0; i &lt; a.length; i++) {<break/>
					   result.append( a[i] );<break/>
					   //result.append( optional separator );<break/>
					}<break/>
					String mynewstring = result.toString();<break/>
				</li>
				<li>
					
					You want code which produce string from arrayList, 
					Iterate through all elements in list and add it to your String result<break/>
					you can do this in 2 ways: using String as result or StringBuffer/StringBuilder. 
					<delay>2</delay>
					Example:
					String result = "";<break/>
					for (String s : list) {<break/>
					    result += s;<break/>
					}<break/>
					...
					<delay>2</delay>
					but this isn't good practice because of performance reason.
					<delay>2</delay>
					Better is using StringBuffer (threads safe) or StringBuilder which are more appropriate 
					to adding Strings
				</li>
				<li>
					I like using Google's Guava Joiner for this, e.g.:
					Joiner.on(", ").skipNulls().join("Harry", null, "Ron", "Hermione");<break/>
					would produce the same String as: new String("Harry, Ron, Hermione");<break/>
					Java 8 has similar support now:
					<delay>2</delay>
					String.join(", ", "Harry", "Ron", "Hermione");<break/>
					Can't see support for skipping null values, but that's easily worked around.
				</li>
				<li>
					Try the Arrays.deepToString method.
					<delay>2</delay>
					Returns a string representation of the "deep contents" of the specified array.  
					<delay>2</delay>
					If the array contains other arrays as elements, the string representation contains their contents and so on.  
					<delay>2</delay>
					This method is designed for converting multidimensional arrays to strings
				</li>
				<li>
					If you know how much elements the array has, a simple way is doing this:
					String appendedString = "" + array[0] + "" + array[1] + "" + array[2] + "" + array[3]; <break/>
				</li>
				<li>
					What about this code:<break/>
					String[] strings = new String[25000];<break/>
					for (int i = 0; i &lt; 25000; i++) strings[i] = '1234567';<break/>
					String result;<break/>
					result = "";<break/>
					for (String s : strings) result += s;<break/>
					//linear +: 5s<break/>
					result = "";<break/>
					for (String s : strings) result = result.concat(s);<break/>
					//linear .concat: 2.5s<break/>
					result = String.join("", strings);<break/>
					//Java 8 .join: 3ms<break/>
					Public String join(String delimiter, String[] s)<break/>
					{<break/>
					    int ls = s.length;<break/>
					    switch (ls)<break/>
					    {<break/>
					        case 0: return "";<break/>
					        case 1: return s[0];<break/>
					        case 2: return s[0].concat(delimiter).concat(s[1]);<break/>
					        default:<break/>
					            int l1 = ls / 2;<break/>
					            String[] s1 = Arrays.copyOfRange(s, 0, l1); <break/>
					            String[] s2 = Arrays.copyOfRange(s, l1, ls); <break/>
					            return join(delimiter, s1).concat(delimiter).concat(join(delimiter, s2));<break/>
					    }<break/>
					}<break/>
					result = join("", strings);<break/>
					// Divide&amp;Conquer join: 7ms<break/>
					<delay>2</delay>
					If you don't have the choise but to use Java 6 or 7 then you should use Divide&amp;Conquer join.
				</li>
				<li>
					From Java 8, the simplest way I think is:
					String[] array = { "cat", "mouse" };<break/>
					String delimiter = "";<break/>
					String result = String.join(delimiter, array);<break/>
					<delay>2</delay>
					This way you can choose an arbitrary delimiter.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ convert array ^ strings ^ string ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ transform array ^ strings ^ string ^</pattern>
		<template><srai>^ convert array ^ strings ^ string ^</srai></template>
  </category>
	<category>
	  <pattern>^ convert ^ array ^ strings ^ string ^</pattern>
		<template><srai>^ convert array ^ strings ^ string ^</srai></template>
  </category>
	<category>
	  <pattern>^ convert ^ strings ^ array ^ string ^</pattern>
		<template><srai>^ convert array ^ strings ^ string ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 75. Converting from HashSet to String[] -->
			^ converting ^ hashset ^ string array ^
		</pattern>
		<template>
			<random>
				<li>
					This should work:<break/>
					set.toArray(new String[set.size()]);<break/>
					<delay>2</delay>
				</li>
				<li>
					Java 8 you can now do:
					Set&lt;String&gt; mySet = new HashSet&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;));<break/>
					System.out.println(String.join(&quot;, &quot;, mySet));<break/>
					Output is: a, b, c<break/>
					<delay>2</delay>
					This allows to bypass array notation (the []).
				</li>
				<li>
					In Java 15, you can do:
					set.toArray(new String[0]); <break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ converting ^ hashset ^ string array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ transform ^ hashset ^ string array ^</pattern>
		<template><srai>^ converting ^ hashset ^ string array ^</srai></template>
  </category>
	<category>
	  <pattern>^ hashset ^ string array ^</pattern>
		<template><srai>^ converting ^ hashset ^ string array ^</srai></template>
  </category>
	<category>
	  <pattern>^ string array ^ hashset ^</pattern>
		<template><srai>^ converting ^ hashset ^ string array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 76. How does one convert a HashMap to a List in Java? -->
			^ convert ^ hashmap ^ list ^
		</pattern>
		<template>
			<random>
				<li>
					This should give you a hint: <break/>
					HashMap&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;();<break/>
					map.put (1, "Mark");<break/>
					map.put (2, "Tarryn");<break/>
					List&lt;String&gt; list = new ArrayList&lt;String&gt;(map.values());<break/>
					for (String s : list) {<break/>
					    System.out.println(s);<break/>
					}<break/>
				</li>
				<li>
					Basically you should not mess the question with answer, because it is confusing. 
					<delay>2</delay>
					Then you could specify what convert mean and pick one of this solution
					List&lt;Integer&gt; keyList = Collections.list(Collections.enumeration(map.keySet()));<break/>
					List&lt;String&gt; valueList = Collections.list(Collections.enumeration(map.values()));<break/>
				</li>
				<li>
					Assuming you have:
					HashMap&lt;Key, Value&gt; map; // Assigned or populated somehow.<break/>
					For a list of values:
					List&lt;Value&gt; values = new ArrayList&lt;Value&gt;(map.values());<break/>
					For a list of keys:
					<delay>2</delay>
					List&lt;Key&gt; keys = new ArrayList&lt;Key&gt;(map.keySet());<break/>
					Note that the order of the keys and values will be unreliable with a HashMap; 
					use a LinkedHashMap if you need to preserve one-to-one correspondence of key and 
					value positions in their respective lists.
				</li>
				<li>
					If you only want it to iterate over your HashMap, no need for a list:
					HashMap&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;();<break/>
					map.put (1, "Mark");<break/>
					map.put (2, "Tarryn");<break/>
					for (String s : map.values()) {<break/>
					    System.out.println(s);<break/>
					}<break/>
					<delay>2</delay>
					Of course, if you want to modify your map structurally (i.e. more than only changing the value for an existing key) while iterating, then you better use the "copy to ArrayList" method, since otherwise you'll get a ConcurrentModificationException.
					<delay>2</delay>
					Or export as an array:
					HashMap&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;();<break/>
					map.put (1, "Mark");<break/>
					map.put (2, "Tarryn");<break/>
					for (String s : map.values().toArray(new String[]{})) {<break/>
					    System.out.println(s);<break/>
					}<break/>
				</li>
				<li>
					If you wanna maintain the same order in your list, say your Map looks like:
					map.put(1, "msg1")<break/>
					map.put(2, "msg2")<break/>
					map.put(3, "msg3")<break/>
					and you want your list looks like
					<delay>2</delay>
					["msg1", "msg2", "msg3"]   // same order as the map<break/>
					<delay>2</delay>
					you will have to iterate through the Map:
					// sort your map based on key, otherwise you will get IndexOutofBoundException<break/>
					Map&lt;String, String&gt; treeMap = new TreeMap&lt;String, String&gt;(map)<break/>
					List&lt;String&gt; list = new List&lt;String&gt;();<break/>
					for (treeMap.Entry&lt;Integer, String&gt; entry : treeMap.entrySet()) {<break/>
					    list.add(entry.getKey(), entry.getValue());<break/>
					}  <break/>
				</li>
				<li>
					Solution using Java 8 and Stream Api:
					private static &lt;K, V&gt;  List&lt;V&gt; createListFromMapEntries (Map&lt;K, V&gt; map){<break/>
							return map.values().stream().collect(Collectors.toList());<break/>
					}<break/>
					<delay>2</delay>
					Usage: 
					public static void main (String[] args)<break/>
					{<break/>
						Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();<break/>
						map.put(1, "one");<break/>
						map.put(2, "two");<break/>
						map.put(3, "three");<break/>
						List&lt;String&gt; result = createListFromMapEntries(map);<break/>
						result.forEach(System.out :: println);<break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ convert ^ hashmap ^ list ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ transform ^ hashmap ^ list ^</pattern>
		<template><srai>^ convert ^ hashmap ^ list ^</srai></template>
  </category>
	<category>
	  <pattern>^ map ^ hashmap ^ list ^</pattern>
		<template><srai>^ convert ^ hashmap ^ list ^</srai></template>
  </category>
	<category>
	  <pattern>^ hashmap ^ list ^</pattern>
		<template><srai>^ convert ^ hashmap ^ list ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 77. Converting char[] to byte[] -->
			^ convert ^ char array ^ byte array ^
		</pattern>
		<template>
			<random>
				<li>
					char[] ch = ?<break/>new String(ch).getBytes();<break/>
					or<break/>
					new String(ch).getBytes("UTF-8");<break/>
					to get non-default charset.
					<delay>2</delay>
					Since Java 7: new String(ch).getBytes(StandardCharsets.UTF_8);
				</li>
				<li>
					
					Convert without creating String object:
					import java.nio.CharBuffer;<break/>
					import java.nio.ByteBuffer;<break/>
					import java.util.Arrays;<break/>
					byte[] toBytes(char[] chars) {<break/>
					  CharBuffer charBuffer = CharBuffer.wrap(chars);<break/>
					  ByteBuffer byteBuffer = Charset.forName("UTF-8").encode(charBuffer);<break/>
					  byte[] bytes = Arrays.copyOfRange(byteBuffer.array(),<break/>
					            byteBuffer.position(), byteBuffer.limit());<break/>
					  Arrays.fill(byteBuffer.array(), (byte) 0); // clear sensitive data<break/>
					  return bytes;<break/>
					}<break/>
					Usage:
					<delay>2</delay>
					char[] chars = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};<break/>
					byte[] bytes = toBytes(chars);<break/>
					/* do something with chars/bytes */<break/>
					Arrays.fill(chars, '\u0000'); // clear sensitive data<break/>
					Arrays.fill(bytes, (byte) 0); // clear sensitive data<break/>
					Solution is inspired from Swing recommendation to store passwords in char[].
					<delay>2</delay>
					(See Why is char[] preferred over String for passwords?)
					Remember not to write sensitive data to logs and ensure that JVM won't hold any 
					references to it.
					<delay>2</delay>
					The code above is correct but not effective.
					<delay>2</delay>
					If you don't need performance but want security you can use it.
					<delay>2</delay>
					If security also not a goal then do simply String.getBytes.
					<delay>2</delay>
					Code above is not effective if you look down of implementation of encode in JDK.
					<delay>2</delay>
					Besides you need to copy arrays and create buffers.
					<delay>2</delay>
				</li>
				<li>
					You could make a method:
					public byte[] toBytes(char[] data) {<break/>
						byte[] toRet = new byte[data.length];<break/>
						for(int i = 0; i &lt; toRet.length; i++) {<break/>
							toRet[i] = (byte) data[i];<break/>
						}<break/>
						return toRet;<break/>
					}<break/>
					Hope this helps
				</li>
				<li>
					Try this approach:<break/>
					private static byte[] charArrayToByteArray(char[] c_array) {<break/>
						byte[] b_array = new byte[c_array.length];<break/>
						for(int i= 0; i &lt; c_array.length; i++) {<break/>
								b_array[i] = (byte)(0xFF &amp; (int)c_array[i]);<break/>
						}<break/>
						return b_array;<break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ convert ^ char array ^ byte array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ transform ^ char array ^ byte array ^</pattern>
		<template><srai>^ convert ^ char array ^ byte array ^</srai></template>
  </category>
	<category>
	  <pattern>^  array ^ chars ^ byte array ^</pattern>
		<template><srai>^ convert ^ char array ^ byte array ^</srai></template>
  </category>
	<category>
	  <pattern>^  array ^ chars ^ array ^ bytes ^</pattern>
		<template><srai>^ convert ^ char array ^ byte array ^</srai></template>
  </category>
	<category>
	  <pattern>^ chars array ^ byte array ^</pattern>
		<template><srai>^ convert ^ char array ^ byte array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 78. ArrayList replace element if exists at a given index? -->
			^ arraylist replace element ^ exists ^ given index ^
		</pattern>
		<template>
			<random>
				<li>
					If you're going to be requiring different set functionaltiy, I'd advise extending 
					ArrayList with your own class.
					<delay>2</delay>
					This way, you won't have to define your behavior in more than one place.
					<delay>2</delay>
					// You can come up with a more appropriate name<break/>
					public class SizeGenerousArrayList&lt;E&gt; extends java.util.ArrayList&lt;E&gt; {<break/>
					    @Override<break/>
					    public E set(int index, E element) {<break/>
					        this.ensureCapacity(index+1); // make sure we have room to set at index<break/>
					        return super.set(index,element); // now go as normal<break/>
					    }<break/>
					    // all other methods aren't defined, so they use ArrayList's version by default<break/>
					}<break/>
				</li>
				<li>
					An element is over-written if it already exists at an index, that is the default 
					behaviour: Javadoc.
					<delay>2</delay>
				</li>
				<li>
						You could use this:<break/>
					  arrayList.set(index i,String replaceElement);<break/>
					<delay>2</delay>
				</li>
				<li>
					just use this method inside arraylist<break/>
					list.set(/*index*/,/*value*/)<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ arraylist replace element ^ exists ^ given index ^</postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ arraylist replace item ^ exists ^ given index ^</pattern>
		<template><srai>^ arraylist replace element ^ exists ^ given index ^</srai></template>
  </category>
	<category>
	  <pattern>^ arraylist replace element ^ given index ^</pattern>
		<template><srai>^ arraylist replace element ^ exists ^ given index ^</srai></template>
  </category>
	<category>
	  <pattern>^ replace element ^ arraylist ^ given index ^</pattern>
		<template><srai>^ arraylist replace element ^ exists ^ given index ^</srai></template>
  </category>
	<category>
	  <pattern>^ replace item ^ arraylist ^ given index ^</pattern>
		<template><srai>^ arraylist replace element ^ exists ^ given index ^</srai></template>
  </category>
	<category>
	  <pattern>^ change item ^ arraylist ^ given index ^</pattern>
		<template><srai>^ arraylist replace element ^ exists ^ given index ^</srai></template>
  </category>
	<category>
	  <pattern>^ arraylist replace element ^ exists ^ given ^</pattern>
		<template><srai>^ arraylist replace element ^ exists ^ given index ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 79. How to create an array of 20 random bytes? -->
			^ create ^ array ^ random bytes ^
		</pattern>
		<template>
			<random>
				<li>
					Try the Random.nextBytes method:
					byte[] b = new byte[20];<break/>new Random().nextBytes(b);<break/>
				</li>
				<li>
					If you are already using Apache Commons Lang, the  RandomUtils  makes this a one-liner:
					<delay>2</delay>
					byte[] randomBytes = RandomUtils.nextBytes(20);<break/>
					<delay>2</delay>
					this does not produce cryptographically-secure bytes.
				</li>
				<li>
					Create a Random object with a seed and get the array random by doing:
					public static final int ARRAY_LENGTH = 20;<break/>
					byte[] byteArray = new byte[ARRAY_LENGTH];<break/>
					new Random(System.currentTimeMillis()).nextBytes(byteArray);<break/>
					// get fisrt element<break/>
					System.out.println("Random byte: " + byteArray[0]);<break/>
				</li>
				<li>
					Java 7 introduced ThreadLocalRandom which is isolated to the current thread.
					<delay>2</delay>
					This is an another rendition of maerics's solution.
					<delay>2</delay>
					final byte[] bytes = new byte[20];<break/>
					ThreadLocalRandom.current().nextBytes(bytes);<break/>
				</li>
				<li>
					If you want a cryptographically strong random number generator (also thread safe
					) without using a third party API, you can use SecureRandom.
					<delay>2</delay>
					Java 6 &amp; 7:<break/>
					SecureRandom random = new SecureRandom();<break/>
					byte[] bytes = new byte[20];<break/>
					random.nextBytes(bytes);<break/>
					Java 8 (even more secure):
					byte[] bytes = new byte[20];<break/>
					SecureRandom.getInstanceStrong().nextBytes(bytes);<break/>
				</li>
				<li>
					For those wanting a more secure way to create a random byte array, yes the most 
					secure way is:
					byte[] bytes = new byte[20];<break/>
					SecureRandom.getInstanceStrong().nextBytes(bytes);<break/>
					<delay>2</delay>
					BUT your threads might block if there is not enough randomness available on the 
					machine, depending on your OS.
					<delay>2</delay>
					The following solution will not block:
					<delay>2</delay>
					SecureRandom random = new SecureRandom();<break/>
					byte[] bytes = new byte[20];<break/>
					random.nextBytes(bytes);<break/>
					<delay>2</delay>
					This is because the first example uses /dev/random and will block while waiting 
					for more randomness (generated by a mouse/keyboard and other sources).
					<delay>2</delay>
					The second example uses /dev/urandom which will not block.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ create ^ array ^ random bytes ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ build ^ array ^ random bytes ^</pattern>
		<template><srai>^ create ^ array ^ random bytes ^</srai></template>
  </category>
	<category>
	  <pattern>^ create ^ arrays ^ random bytes ^</pattern>
		<template><srai>^ create ^ array ^ random bytes ^</srai></template>
  </category>
	<category>
	  <pattern>^ build ^ arrays ^ random bytes ^</pattern>
		<template><srai>^ create ^ array ^ random bytes ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 80. How to convert a Java String to an ASCII byte array? -->
			^ convert ^ string ^ ascii byte array ^
		</pattern>
		<template>
			<random>
				<li>
					Using the getBytes method, giving it the appropriate Charset (or Charset name).
					<delay>2</delay>
					Example:
					String s = "Hello, there.";<break/>
					byte[] b = s.getBytes(StandardCharsets.US_ASCII);<break/>
					(Before Java 7: byte[] b = s.getBytes("US-ASCII");)
				</li>
				<li>
					This should work fine:<break/>
					String s = "ASCII Text";<break/>
					byte[] bytes = s.getBytes("US-ASCII");<break/>
				</li>
				<li>
					There is only one character wrong in the code you tried:
					Charset characterSet = Charset.forName("US-ASCII");<break/>
					String string = "Wazzup";<break/>
					byte[] bytes = String.getBytes(characterSet);<break/>
					Notice the upper case "String".
					<delay>2</delay>
					This tries to invoke a static method on the string class, which does not exist.
					<delay>2</delay>
					Instead you need to invoke the method on your string instance:
					byte[] bytes = string.getBytes(characterSet);<break/>
				</li>
				<li>
					Convert string to ascii values.
					<delay>2</delay>
					String test = "ABCD";<break/>
					for ( int i = 0; i &lt; test.length(); ++i ) {<break/>
						char c = test.charAt( i );<break/>
						int j = (int) c;<break/>
						System.out.println(j);<break/>
					}<break/>
				</li>
				<li>
					If you happen to need this in Android and want to make it work with anything older 
					than FroYo, you can also use EncodingUtils.getAsciiBytes():
					byte[] bytes = EncodingUtils.getAsciiBytes("ASCII Text");<break/>
				</li>
				<li>
					If you are a guava user there is a handy Charsets class:
					String s = "Hello, world!";<break/>
					byte[] b = s.getBytes(Charsets.US_ASCII);<break/>
					<delay>2</delay>
					Apart from not hard-coding arbitrary charset name in your source code it has a 
					much bigger advantage:
					<delay>2</delay>
					Charsets.US_ASCII is of Charset type (not String)
					<delay>2</delay>
					so you avoid checked UnsupportedEncodingException thrown only from String.getBytes(String), but not from String.getBytes(Charset).
					<delay>2</delay>
					In Java 7 there is equivalent StandardCharsets class.
				</li>
				<li>
					Try this:
					/**<break/>
					 * @(#)demo1.java<break/>
					 *<break/>
					 *<break/>
					 * @author <break/>
					 * @version 1.00 2012/8/30<break/>
					 */<break/>
					import java.util.*;<break/>
					public class demo1 <break/>
					{<break/>
					    Scanner s=new Scanner(System.in);<break/>
					    String str;<break/>
					    int key;<break/>
					    void getdata()<break/>
					    {<break/>
					        System.out.println ("plase enter a string");<break/>
					        str=s.next();<break/>
					        System.out.println ("plase enter a key");<break/>
					        key=s.nextInt();<break/>
					    }<break/>
					    void display()<break/>
					    {<break/>
					        char a;<break/>
					        int j;<break/>
					        for ( int i = 0; i &lt; str.length(); ++i )<break/>
					        {<break/>
					            char c = str.charAt( i );<break/>
					            j = (int) c + key;<break/>
					            a= (char) j;<break/>
					            System.out.print(a);  <break/>
					        }<break/>
					        public static void main(String[] args)<break/>
					        {<break/>
					            demo1 obj=new demo1();<break/>
					            obj.getdata();<break/>
					            obj.display();<break/>
					        }<break/>
					    }<break/>
					}<break/>
				</li>
				<li>
					In my string I have Thai characters (TIS620 encoded) and German umlauts.
					<delay>2</delay>
					The answer from agiles put me on the right path.
					<delay>2</delay>
					Instead of .getBytes() I use now
					int len = mString.length(); // Length of the string<break/>
					byte[] dataset = new byte[len];<break/>
					for (int i = 0; i &lt; len; ++i) {<break/>
							char c = mString.charAt(i);<break/>
							dataset[i]= (byte) c;<break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ convert ^ string ^ ascii byte array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ transform ^ string ^ ascii byte array ^</pattern>
		<template><srai>^ convert ^ string ^ ascii byte array ^</srai></template>
  </category>
	<category>
	  <pattern>^ convert ^ string ^ ascii array ^</pattern>
		<template><srai>^ convert ^ string ^ ascii byte array ^</srai></template>
  </category>
	<category>
	  <pattern>^ string ^ converrsion ^ ascii byte array ^</pattern>
		<template><srai>^ convert ^ string ^ ascii byte array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 81. How can I convert a String to a char array? -->
			^ convert ^ string ^ char array ^
		</pattern>
		<template>
			<random>
				<li>
					Use String#toCharArray().
					<delay>2</delay>
					char[] chars = "some string".toCharArray();<break/>
				</li>
				<li>
					"read java docs".toCharArray();<break/>
				</li>
				<li>
					Use the String.getChars() method.
				</li>
				<li>
					Use the String.toCharArray() method.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ convert ^ string ^ char array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ transform ^ string ^ char array ^</pattern>
		<template><srai>^ convert ^ string ^ char array ^</srai></template>
  </category>
	<category>
	  <pattern>^ string ^ conversion ^ char array ^</pattern>
		<template><srai>^ convert ^ string ^ char array ^</srai></template>
  </category>
	<category>
	  <pattern>^ char array ^ string ^</pattern>
		<template><srai>^ convert ^ string ^ char array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 82. Checking a column in 2-Dimensional Array -->
			^ checking ^ column ^ 2d array ^
		</pattern>
		<template>
			<random>
				<li>
					If you want to check one column you need one loop, if you want to check N columns 
					you need two nested loops.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ checking ^ column ^ 2d array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ 2d array ^ column ^</pattern>
		<template><srai>^ checking ^ column ^ 2d array ^</srai></template>
  </category>
	<category>
	  <pattern>^ loop ^ column ^ 2d array ^</pattern>
		<template><srai>^ checking ^ column ^ 2d array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 83. Converting String array to java.util.List -->
			^ converting string array ^ list ^
		</pattern>
		<template>
			<random>
				<li>
					Use the static List list = Arrays.asList(stringArray) or you could just iterate 
					over the array and add the strings to the list.
					<delay>2</delay>
				</li>
				<li>
					Try this:<break/>
					List&lt;String&gt; strings = Arrays.asList(new String[]{"one", "two", "three"});<break/>
					<delay>2</delay>
					This is a list view of the array, the list is partly unmodifiable, you can't add or 
					delete elements.
					<delay>2</delay>
					But the time complexity is O(1).
					<delay>2</delay>
					If you want a modifiable a List:
					List&lt;String&gt; strings = <break/>
					new ArrayList&lt;String&gt;(Arrays.asList(new String[]{"one", "two", "three"}));<break/>
					<delay>2</delay>
					This will copy all elements from the source array into a new list (complexity: O(n))
				</li>
				<li>
					This shoul work:<break/>
					import java.util.Collections;<break/>
					List myList = new ArrayList();<break/>
					String[] myArray = new String[] {"Java", "Util", "List"};<break/>
					Collections.addAll(myList, myArray);<break/>
				</li>
				<li>
					First Step you need to create a list instance through Arrays.asList();
					String[] args = new String[]{"one","two","three"};<break/>
					List&lt;String&gt; list = Arrays.asList(args);//it converts to immutable list<break/>
					<delay>2</delay>
					Then you need to pass 'list' instance to new ArrayList();
					List&lt;String&gt; newList=new ArrayList&lt;&gt;(list);<break/>
				</li>
				<li>
					The Simplest approach: 
					String[] stringArray = {"Hey", "Hi", "Hello"};<break/>
					List&lt;String&gt; list = Arrays.asList(stringArray);<break/>
				</li>
				<li>
					On Java 14 you can do this
					List&lt;String&gt; strings = Arrays.asList(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ converting string array ^ list ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ string array ^ list ^ conversion ^</pattern>
		<template><srai>^ converting string array ^ list ^</srai></template>
  </category>
	<category>
	<category>
	  <pattern>^ convert ^ string array ^ list ^</pattern>
		<template><srai>^ converting string array ^ list ^</srai></template>
  </category>
		<pattern>
			<!-- 84. How can I get the unique elements of an unordered character array in Java? -->
			^ get ^ unique elements ^ character ^ array ^
		</pattern>
		<template>
			<random>
				<li>
					One-liner:
					Set&lt;Character&gt; uniqueChars = new HashSet&lt;Character&gt;(Arrays.asList(array));<break/>
					(the array will need to be Character[] not char[]. Otherwise you'd have to convert it to the wrapper array)
					<delay>2</delay>
					Note that, if this is homework, you would need a more algorithmic approach in 
					order to show that you understand what you are doing.
					<delay>2</delay>
					The above solution may not be applicable.
					<delay>2</delay>
					But here's how it works: the array is turned into a List.
					<delay>2</delay>
					This is O(1), as the array just backs the new, unmodifiable list.
					<delay>2</delay>
					This is done so that the array can conform the the List interface, which is required 
					by the HashSet constructor a HashSet
					<delay>2</delay>
					is a collection backed by a Set&lt;Character&gt; uniqueChars = new HashSet&lt;Character&gt;(Arrays.asList(array));<break/>0 (hashtable).
					<delay>2</delay>
					It computes the hashes of keys and stores them in an internal array, under an 
					index = hash.
					<delay>2</delay>
					Thus lookup is O(1).
					<delay>2</delay>
					the Set&lt;Character&gt; uniqueChars = new HashSet&lt;Character&gt;(Arrays.asList(array));<break/>1 constructor simply iterates the passed Set&lt;Character&gt; uniqueChars = new HashSet&lt;Character&gt;(Arrays.asList(array));<break/>2 and calls Set&lt;Character&gt; uniqueChars = new HashSet&lt;Character&gt;(Arrays.asList(array));<break/>3 for each item.
					<delay>2</delay>
					Items that are the same are not allowed twice in the set (sets by definition do 
					not allow duplicates).
					<delay>2</delay>
					This is so, because the hash of the item will be the same as an existing one, 
					so the new one will replace the old one.
					<delay>2</delay>
					Note that items with the same hash are allowed, but not those that are also equal 
					(Set&lt;Character&gt; uniqueChars = new HashSet&lt;Character&gt;(Arrays.asList(array));<break/>4)
					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ get ^ unique elements ^ character array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ get ^ unique items ^ character array ^</pattern>
		<template><srai>^ get ^ unique elements ^ character array ^</srai></template>
  </category>
	<category>
	  <pattern>^ retrieve ^ unique elements ^ character array ^</pattern>
		<template><srai>^ get ^ unique elements ^ character array ^</srai></template>
  </category>
	<category>
	  <pattern>^ retrieve ^ unique items ^ character array ^</pattern>
		<template><srai>^ get ^ unique elements ^ character array ^</srai></template>
  </category>
	<category>
	  <pattern>^ character array ^ unique items ^</pattern>
		<template><srai>^ get ^ unique elements ^ character array ^</srai></template>
  </category>
	<category>
	  <pattern>^ character array ^ unique elements ^</pattern>
		<template><srai>^ get ^ unique elements ^ character array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 85. Is there any use of making an array final (immutable) in Java? -->
			^ reason ^ array final ^
		</pattern>
		<template>
			<random>
				<li>
					There may be several.
					<delay>2</delay>
					At least, it ensures that later code cannot point the variable 'array' to another array 
					<delay>2</delay>
					the variable 'array' can be seen by anonymous inner classes (e.g. listeners).
					<delay>2</delay>
					Importantly, it does not ensure that the contents of 'array' are immutable.
				</li>
				<li>
					It provides an invariant that the assignment of 'array' can't be changed.  
					<delay>2</delay>
					(When looking at code I can assume 'array' won't get reassigned).  
					<delay>2</delay>
					However nothing stops an element from being changed.  
					<delay>2</delay>
					Ex. array[2] can be changed from 33 to 25.
				</li>
				<li>
					The reasons are the same as with any other mutable type: the reference stays the 
					same throughout the lifecycle of the declaring object, so you can distribute it 
					freely for example.
					<delay>2</delay>
					final is always about the reference being fixed and not the contents, which might 
					change.
					<delay>2</delay>
					With arrays, you even get a guarantee that the array size isn't going to change
					, although how useful that guarantee is depends on the specific use case.
				</li>
				<li>
					You can't.
					<delay>2</delay>
					You can only declare the array reference final, which has nothing to do with making 
					the array immutable.
					<delay>2</delay>
					Arrays are never immutable in Java.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ reason ^ array final ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ why ^ array final ^</pattern>
		<template><srai>^ reason ^ array final ^</srai></template>
  </category>
	<category>
	  <pattern>^ use ^ array final ^</pattern>
		<template><srai>^ reason ^ array final ^</srai></template>
  </category>
	<category>
	  <pattern>^ array final ^ use ^</pattern>
		<template><srai>^ reason ^ array final ^</srai></template>
  </category>
	<category>
	  <pattern>^ array final ^ reason ^</pattern>
		<template><srai>^ reason ^ array final ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 86. How to use a char array in java if the size is unknown? -->
			^ use ^ char array ^ unknown size ^
		</pattern>
		<template>
			<random>
				<li>
					In general, you can use a java.util.List when you don't know the size up front.
					<delay>2</delay>
					List&lt;Character&gt; chars = new ArrayList&lt;Character&gt;();<break/>
					chars.add('f');<break/>chars.add('o');<break/>chars.add('o');<break/>
					<delay>2</delay>
					Depending on your needs, a StringBuilder might make more sense than a List&lt;Character&gt;.
					<delay>2</delay>
					StringBuilder sb = new StringBuilder();<break/>
					sb.append('f')<break/>
					  .append('o')<break/>
					  .append('o');<break/>
				</li>
				<li>
					Can you use a String or a StringBuilder and then convert it to a char array later
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ use ^ char array ^ unknown size ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ char array ^ unknown size ^</pattern>
		<template><srai>^ use ^ char array ^ unknown size ^</srai></template>
  </category>
	<category>
	  <pattern>^ char array ^ size unknown ^</pattern>
		<template><srai>^ use ^ char array ^ unknown size ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 87. Write byte[] to File in Java -->
			^ write byte array ^ file ^ 
		</pattern>
		<template>
			<random>
				<li>
					A File object doesn't contain the content of the file.
					<delay>2</delay>
					It is only a pointer to the file on your hard drive (or other storage medium, 
					like an SSD, USB drive, network share).
					<delay>2</delay>
					So I think what you want is writing it to the hard drive.
					<delay>2</delay>
					You have to write the file using some classes in the Java API
					BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(yourFile));<break/>
					bos.write(fileBytes);<break/>
					bos.flush();<break/>
					bos.close();<break/>
					<delay>2</delay>
					You can also use a Writer instead of an OutputStream.
					<delay>2</delay>
					Using a writer will allow you to write text
					<delay>2</delay>
					BufferedWriter bw = new BufferedWriter(new FileWriter(yourFile));<break/>
					<delay>2</delay>
					Since you said you wanted to keep everything in memory and don't want to write 
					anything, you might try to use ByteArrayInputStream.
					<delay>2</delay>
					This simulates an InputStream, which you can pass to the most of the classes.
					<delay>2</delay>
					ByteArrayInputStream bais = new ByteArrayInputStream(yourBytes);<break/>
					<delay>2</delay>
				</li>
				<li>
					Use a FileOutputStream.
					<delay>2</delay>
					FileOutputStream fos = new FileOutputStream(objFile);<break/>
					fos.write(objFileBytes);<break/>
					fos.close();<break/>
				</li>
				<li>
					This whould work:<break/>
					<delay>2</delay>
					public void writeToFile(byte[] data, String fileName) throws IOException{<break/>
					  FileOutputStream out = new FileOutputStream(fileName);<break/>
					  out.write(data);<break/>
					  out.close();<break/>
					}<break/>
				</li>
				<li>
					Ok, you asked for it:
					File file = new File("myfile.txt");<break/>
					// convert File to byte[]<break/>
					ByteArrayOutputStream bos = new ByteArrayOutputStream();<break/>
					ObjectOutputStream oos = new ObjectOutputStream(bos);<break/>
					oos.writeObject(file);<break/>
					bos.close();<break/>
					oos.close();<break/>
					byte[] bytes = bos.toByteArray();<break/>
					// convert byte[] to File<break/>
					ByteArrayInputStream bis = new ByteArrayInputStream(bytes);<break/>
					ObjectInputStream ois = new ObjectInputStream(bis);<break/>
					File fileFromBytes = (File) ois.readObject();<break/>
					bis.close();<break/>
					ois.close();<break/>
					System.out.println(fileFromBytes);<break/>
					<delay>2</delay>
					But this is pointless.
					<delay>2</delay>
					Please specify what you are trying to achieve.
				</li>
				<li>
					See How to render PDF in Android.
					<delay>2</delay>
					It looks like you may not have any option except saving the content to a (temporary
					) on the SD file in order to be able to display it in the pdf viewer.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ write byte array ^ file ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ save ^ byte array ^ file ^</pattern>
		<template><srai>^ write byte array ^ file ^</srai></template>
  </category>
	<category>
	  <pattern>^ write ^ byte array ^ file ^</pattern>
		<template><srai>^ write byte array ^ file ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 88. What is a List vs. an ArrayList? -->
			^ difference ^ list ^ arraylist ^
		</pattern>
		<template>
			<random>
				<li>
					List is in interface while ArrayList is a class.
					<delay>2</delay>
					See ArrayList, and List.
					<delay>2</delay>
					E.g, you can't use this setup:
					List&lt;String&gt; list = new List&lt;String&gt;();...
					<delay>2</delay>
					Because it's an interface.
					<delay>2</delay>
					However, this works:
					ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();
					Also...
					<delay>2</delay>
					You can do as duffymo says below, which is more or less the same as implementing 
					the List interface (making your own list implementation).
				</li>
				<li>
					A List defines the interface that ArrayList uses, that allows it to implement 
					methods that will allow all other classes that implement List to be used together 
					or in a similar way.
					<delay>2</delay>
					An ArrayList is always also a List, but an List isn't necessarily an ArrayList.
					<delay>2</delay>
					That is, ArrayList implements List (among a few other interfaces).
				</li>
				<li>
					List is an interface; ArrayList is a class that implements the List interface. 
					<delay>2</delay>
					Interfaces define the method signatures that are required, but say nothing about 
					how they are implemented.  
					<delay>2</delay>
					Classes that implement an interface promise to provide public implementations 
					of methods with the identical signatures declared by the interface.
				</li>
				<li>
					According to the java docs, List is just an interface, and ArrayList is one of 
					the classes that implement it.
					<delay>2</delay>
					There is no inherent efficiency advantage to using ArralyList specifically instead 
					of List-typed references to an ArrayList object.
					<delay>2</delay>
					However, when it comes to "efficiency", there can be a difference between different 
					implementations of the List interface.
					<delay>2</delay>
					For instance there can be  a small efficiency difference between a LinkedList 
					and an ArrayList, depending on how you're using them.
					<delay>2</delay>
					To quote the java docs on the ArrayList page, 
					The add operation runs in amortized constant time, that is, adding n elements 
					requires O(n) time.
					<delay>2</delay>
					All of the other operations run in linear time (roughly speaking).
					<delay>2</delay>
					The constant factor is low compared to that for the LinkedList implementation.
					<delay>2</delay>
					In other words, the performance difference will probably be negligible, but you 
					may see some advantage from using an ArrayList (as opposed to a LinkedList).
					<delay>2</delay>
					In case you're interested, ArrayList is implemented with an array that is resized 
					from time to time (most likely whenever your collection doubles in size), which 
					is quite different from the implementation of a LinkedList (see wikipedia for 
					details).
				</li>
				<li>
					How to use List and ArrayList, or other implementation of List, is Polymorphism 
					and Inheritance, and also the reason why for using languages such as Java. 
					<delay>2</delay>
					In simplicity, Polymorphism is many forms while Inheritance is reuse.
					<delay>2</delay>
					There can be many kinds of concrete and ready to us List that is available to 
					you, such as ArrayList, Vector, LinkedList and Stack.
					<delay>2</delay>
					The decision to use which comes from you, and if you look at the List API, you 
					would notice that all of these List implementations extend in one way or another 
					from List.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ difference ^ list ^ arraylist ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ list ^ arraylist ^ difference</pattern>
		<template><srai>^ difference ^ list ^ arraylist ^</srai></template>
  </category>
	<category>
	  <pattern>^ differences ^ list ^ arraylist ^</pattern>
		<template><srai>^ difference ^ list ^ arraylist ^</srai></template>
  </category>
	<category>
	  <pattern>^ list ^ arraylist ^ differences ^</pattern>
		<template><srai>^ difference ^ list ^ arraylist ^</srai></template>
  </category>
	<category>
	  <pattern>^ difference ^ arraylist ^ list ^</pattern>
		<template><srai>^ difference ^ list ^ arraylist ^</srai></template>
  </category>
	<category>
	  <pattern>^ differences ^ arraylist ^ list ^</pattern>
		<template><srai>^ difference ^ list ^ arraylist ^</srai></template>
  </category>
	<category>
	  <pattern>^ arraylist ^ list ^ difference ^</pattern>
		<template><srai>^ difference ^ list ^ arraylist ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 89. Java XML to Array -->
			^ convert ^ xml ^ array ^
		</pattern>
		<template>
			<random>
				<li>
					There is no function in java to transform an XML to an array
					<delay>2</delay>
					An XML is a tree datastructure that has no trivial translation to a flat array.
					<delay>2</delay>
					Of course you can write this function yourself, if you know what you want.
					<delay>2</delay>
					Also there are many 3rd party libraries that allow conversion from XML to Java 
					objects, but it's hard to recommend one without knowing what your problem exactly is.
					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ convert ^ xml ^ array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ transfomr ^ xml ^ array ^</pattern>
		<template><srai>^ convert ^ xml ^ array ^</srai></template>
  </category>
	<category>
	  <pattern>^ save ^ xml ^ array ^</pattern>
		<template><srai>^ convert ^ xml ^ array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 90. Can Java use String as an index array key? (ex: array["a"]=1;) -->
			^ use string ^ index array key ^
		</pattern>
		<template>
			<random>
				<li>
					No.
					<delay>2</delay>
					To do something like this, you have to use a Map.
					<delay>2</delay>
					Map&lt;String, Integer&gt; aMap = new HashMap&lt;String, Integer&gt;();<break/>
					aMap.put("a" , Integer.valueOf(1));<break/>
				</li>
				<li>
					No, that would be a Map in Java.
					<delay>2</delay>
					(The type would be Map&lt;String,Integer&gt;.)
				</li>
				<li>
					No - you want a map to do that:
					Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();<break/>map.put("a", 2);<break/>
					<delay>2</delay>
					Then to get it:
					<delay>2</delay>
					int val = map.get("a"); //2<break/>
					<delay>2</delay>
					You can only use the square bracket syntax for arrays, not for any of the collections.
					<delay>2</delay>
					So something like:
					int val = map["a"]; //Compile error<break/>
					Will always be illegal.
					<delay>2</delay>
					You have to use the get() method.
				</li>
				<li>
					No they can't.
					<delay>2</delay>
					But they can use chars the ASCII value of the alphabet will be used as the key index
					Consider<break/>
					String[] a = new String['a' + 1];<break/>
					a['a'] = "Hello";<break/>
					int[] b = new int['a' + 3];<break/>
					b['c'] = 5;<break/>
					System.out.println(a[97]);<break/>
					System.out.print(b[99]);<break/>
					<delay>2</delay>
					This will output
					Hello 5<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ use string ^ index array key ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ use string ^ index ^ array key ^</pattern>
		<template><srai>^ use string ^ index array key ^</srai></template>
  </category>
	<category>
	  <pattern>^ string ^ index ^ array key ^</pattern>
		<template><srai>^ use string ^ index array key ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 91. convert byte[] to Object File in Java -->
			^ byte array ^ object file ^ 
		</pattern>
		<template>
			<random>
				<li>
					The File object is just a wrapper around the name for a real file on the disk.
					<delay>2</delay>
					It does not contain any data.
					<delay>2</delay>
					You will have to write your byte array into a file first.
					<delay>2</delay>
					After the API you then call is done, you can maybe delete that file again.
					<delay>2</delay>
					Search for how to manage temporary files in Java.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ byte array ^ object file ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ array of bytes ^ object file ^</pattern>
		<template><srai>^ byte array ^ object file ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 92. How to read file bytes in Java? -->
			^ read ^ file ^
		</pattern>
		<template>
			<random>
				<li>
					You could try this:<break/>
					FileInputStream fis = new FileInputStream("your file name");<break/>
					byte[] bytes = new byte[100]; // replace 100 with the desired size, of course<break/>
					int offset = 0;               // which element to stuff the byte into  <break/>
					fis.read(bytes, offset, 1);   // the 1 is how many bytes to read<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ read ^ file ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ file read ^</pattern>
		<template><srai>^ read file ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 93. Can you create a Java Iterator over a 2d array? -->
		^ create ^ iterator ^ 2d array ^
		</pattern>
		<template>
			<random>
				<li>
					Yes, wrap the array in an object and make the object implement the iterator interface.
					<delay>2</delay>
					So it can be done.
					<delay>2</delay>
					I am not aware of any such iterator that ships with the Jdk.
				</li>
				<li>
					Yes, it can be done
					<delay>2</delay>
					In fact, the solution is probably pretty simple: no more than 10 lines of executable code ...
					<delay>2</delay>
					if I correctly understand the problem.
					<delay>2</delay>
					No, there isn't a convenience method in the JDK to do this.  
					<delay>2</delay>
					And I'm not aware of one in any of the "commons" libraries.  
					<delay>2</delay>
					(Reason: this particular problem is too specialized to be useful to more than 
					a handful of programmers.)
					<delay>2</delay>
					This should be a sufficient answer for you to go and implement the solution yourself.
				</li>
				<li>
					If you implement the Iterable interface, you can use a for-each loop.
					<delay>2</delay>
					Related examples may be found here. 
					<delay>2</delay>
				</li>
				<li>
					I dont see the need to make a single iterator when invoking the two from the arrays works just fine as per example:
					int 2dArray[][];<break/>
					for(int 1dArray[]: 2dArray){<break/>
					    for(int i: 1dArray){<break/>
					        //do stuff<break/>
					    }<break/>
					}<break/>
				</li>
				<li>
					What you say about this code:<break/>
					import java.util.LinkedList;<break/>import java.util.Queue;<break/>
					public class TwoDIterator {<break/>
						int[][] array;<break/>
						int outerCursor;<break/>
						int lastArrayLen;<break/>
						int totalElems;<break/>
						int tracker = 1;<break/>
						Queue&lt;Integer&gt; myQueue = new LinkedList&lt;&gt;();<break/>
						public TwoDIterator(int[][] arr) {<break/>
								this.array = arr;<break/>
								this.outerCursor = 0;<break/>
								for (int i = 0; i &lt; arr.length; i++) {<break/>
										for (int j = 0; j &lt; arr[i].length; j++) {<break/>
												totalElems += 1;<break/>
										}<break/>
								}<break/>
								for (int i = 0; i &lt; array[0].length; i++) {<break/>
										myQueue.add(array[0][i]);<break/>
								}<break/>
						}<break/>
						public boolean hasNext() {<break/>
								return array.length &gt; outerCursor &amp;&amp; totalElems &gt;= tracker;<break/>
						}<break/>
						public Integer next() {<break/>
								if (myQueue.isEmpty()) {<break/>
										outerCursor++;<break/>
										for (int i = 0; i &lt; array[outerCursor].length; i++) {<break/>
												myQueue.add(array[outerCursor][i]);<break/>
										}<break/>
										if (!myQueue.isEmpty()) {<break/>
												tracker++;<break/>
												return myQueue.remove();<break/>
										}<break/>
								} else {<break/>
										tracker++;<break/>
										return myQueue.remove();<break/>
								}<break/>
								return -1;<break/>
						}<break/>
						public static void main(String[] args) {<break/>
								int[][] arr = { { 1, 2, 3 }, { 1, 3 }, { 1, 2, 5 } };<break/>
								TwoDIterator iter = new TwoDIterator(arr);<break/>
								while (iter.hasNext()) {<break/>
										System.out.println(iter.next());<break/>
								}<break/>
						}<break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ create ^ iterator ^ 2d array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ create ^ iterator ^ 2d array ^</pattern>
		<template><srai>^ create ^ iterator ^ 2d array ^</srai></template>
  </category>
	<category>
	  <pattern>^ 2d array ^ iterator ^</pattern>
		<template><srai>^ create ^ iterator ^ 2d array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 94. How to assign a value to byte array -->
			^ assign ^ value ^ byte array ^
		</pattern>
		<template>
			<random>
				<li>
					Either use char[] or String.  Make sure and get the includes for String.
				</li>
				<li>
					That's a string literal.
					<delay>2</delay>
					If you're looking to get the binary representation of the string, use one of the 
					String.getBytes methods.
				</li>
				<li>
					If you're trying to assign hard-coded values, you can use:
					byte[] bytes = { (byte) 204, 29, (byte) 207, (byte) 217 };<break/>
					Note the cast because Java bytes are signed - the cast here will basically force 
					the overflow to a negative value, which is probably what you want.
					<delay>2</delay>
					If you're actually trying to parse a string, you need to do that - split the string 
					into parts and parse each one.
					<delay>2</delay>
					If you're trying to convert a string into its binary representation under some 
					particular encoding, you should use String.getBytes, e.g.
					byte[] abc = "204.29.207.217".getBytes("UTF-8");<break/>
					(Note that conventionally the [] is put as part of the type of the variable, not 
					after the variable name.
					<delay>2</delay>
					While the latter is allowed, it's discouraged as a matter of style.)
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ assign ^ value ^ byte array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ insert ^ value ^ byte array ^</pattern>
		<template><srai>^ assign ^ value ^ byte array ^</srai></template>
  </category>
	<category>
	  <pattern>^ put ^ value ^ byte array ^</pattern>
		<template><srai>^ assign ^ value ^ byte array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 95. Java array declaration without hard coding the size -->
			^ array declaration ^ hard coding ^ size ^
		</pattern>
		<template>
			<random>
				<li>
					Use a List.
					<delay>2</delay>
					The size does not need to be declared on creation of the List.
					<delay>2</delay>
					The toArray() method will return an array representation of the list.
					<delay>2</delay>
					There are multiple implementations you can use but the most popular tends to be 
					ArrayList (though it is best to map the implementation to your particular situation).
				</li>
				<li>
					Arrays have a fixed size after creation.
					<delay>2</delay>
					The size doesn't need to be known at compile-time, but it does need to be known 
					at creation time.
					<delay>2</delay>
					For example:
					public String[] createArray(int size) {<break/>
					    // Not hard-coded, but array is not expandable<break/>
					    return new String[size];<break/>
					}<break/>
					<delay>2</delay>
					If you want a collection which can grow an shrink over time, look at the various 
					List&lt;E&gt; implementations, such as ArrayList&lt;E&gt;.
				</li>
				<li>
					Object[] will always be fixed size.  
					<delay>2</delay>
					If you need a variable length collection, try ArrayList, LinkedList, or one of 
					the many others.
					<delay>2</delay>
					Pick the collection carefully, since they all have different performance aspects.
				</li>
				<li>
					You can create a new array and initialize it like this.
					<delay>2</delay>
					String[] strArray = {"Initialize","Array","Like","This"};<break/>
					<delay>2</delay>
					If you want an array with a dynamic size I would recommend using an ArrayList.
				</li>
				<li>
					For mutable arrays other container objects are used.
					<delay>2</delay>
					When using a set of objects, an ArrayList or Vector object is used.
					<delay>2</delay>
					You can also store objects with an object key e.g. "Name" = "Ben" instead of [0] = "Ben".
					<delay>2</delay>
					Vector v = new Vector();<break/>
					for(int i = 0; i &lt; 100; i++){<break/>
					 Object o = new Object();<break/>
					 // init object<break/>
					 v.addElement(o);<break/>
					}<break/>
					for(int i = 0; i &lt; 100; i++){<break/>
					 Object o = v.elementAt(i);<break/>
					 // manipulate object<break/>
					}<break/>
					<delay>2</delay>
					Now you have an arbritairy list of object of undefined length.
					<delay>2</delay>
					Size found by using vector.size() method.
					<delay>2</delay>
					java.util package is required and part of J2SE 1.3 and higher.
				</li>
				<li>
					Arrays are fixed in length.
					<delay>2</delay>
					I would recommend using a Collection.
					<delay>2</delay>
					The ArrayList or List are collections.
				</li>
				<li>
					If you want an array of primitive instead of objects, you can use Trove4j.
					<delay>2</delay>
					Otherwise use an ArrayList, or CopyOnWriteArrayList to wrap an array.
					<delay>2</delay>
					There are other List implementations but these do not act like arrays for access time.
				</li>
				<li>
					Sometimes it is useful, in case you know an upper bound of the objects your application needs,
					to declare the size of an array as static final int ARRAY_SIZE = 1000;<break/>
					<delay>2</delay>
					This goes near the beginning of the class so it can be easily changed.
					<delay>2</delay>
					In the main code instantiate the array with
					Object[] objects = new Object[ARRAY_SIZE];<break/>
					Also in case the array you want to use has the same size as another array consider using
					Object[] objects = new Object[other_objects.length];<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ array declaration ^ hard coding ^ size ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ array declaration ^ without ^ size ^</pattern>
		<template><srai>^ array declaration ^ hard coding ^ size ^</srai></template>
  </category>
	<category>
	  <pattern>^ declaring array ^ size ^</pattern>
		<template><srai>^ array declaration ^ hard coding ^ size ^</srai></template>
  </category>
	<category>
	  <pattern>^ declare ^ array ^ size ^</pattern>
		<template><srai>^ array declaration ^ hard coding ^ size ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 96. How to convert int [] to Big Integer? -->
			^ convert ^ int array ^ big integer ^ 
		</pattern>
		<template>
			<random>
				<li>
					Well, what about new BigInteger(byte[] val)?
					<delay>2</delay>
					To quote the API docs I linked to:
					<delay>2</delay>
					Translates a byte array containing the two's-complement binary representation 
					of a BigInteger into a BigInteger.
					<delay>2</delay>
					The input array is assumed to be in big-endian byte-order: the most significant 
					byte is in the zeroth element.
				</li>
				<li>
					First, make sure you know in which format your int[] is meant to be interpreted.
					<delay>2</delay>
					Each int can be seen as consisting of four bytes, and these bytes together can 
					be converted to an BigInteger.
					<delay>2</delay>
					The details are the byte order - which byte is the most and which one the least 
					significant?
					<delay>2</delay>
					Also, do you have a signed or unsigned number?
					<delay>2</delay>
					A simple way to convert your ints to bytes (for latter use in a BigInteger constructor
					) would be to use ByteBuffer and wrap an IntBuffer around it.
					<delay>2</delay>
					public BigInteger toBigInteger(int[] data) {<break/>
					    byte[] array = new byte[data.length * 4];<break/>
					    ByteBuffer bbuf = ByteBuffer.wrap(array);<break/>
					    IntBuffer ibuf = bbuf.asIntBuffer();<break/>
					    ibuf.put(data);<break/>
					    return new BigInteger(array);<break/>
					}<break/>
					Obvious adaptions would be to set the byte order of bbuf, or use another BigInteger 
					constructor (for unsigned).
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ convert ^ int array ^ big integer ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ transform ^ int array ^ big integer ^</pattern>
		<template><srai>^ convert ^ int array ^ big integer ^</srai></template>
  </category>
	<category>
	  <pattern>^ change ^ int array ^ big integer ^</pattern>
		<template><srai>^ convert ^ int array ^ big integer ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 97. How do you avoid an ArrayList object from being modified, i.e. avoid adding and deleting its content? -->
			^ immutable ^ arraylist object ^
		</pattern>
		<template>
			<random>
				<li>
					By creating an unmodifiable list out of it:
					List&lt;Object&gt; dontModify = Collections.unmodifiableList(originalList);<break/>
				</li>
				<li>
					It depends on the exact requirements:
					<delay>2</delay>
					Collections.unmodifiableList(arrayList) gives you an unmodifiable view of the 
					original list - that's probably what you need
					<delay>2</delay>
					guava's ImmutableList makes a list that is immutable (and not a view)
					<delay>2</delay>
					(you'd have to copy the ArrayList elements to the immutable list)
				</li>
				<li>
					You don't give the ArrayList to anything you don't trust - instead, you use Collections
					.unmodifiableList to create an immutable wrapper around the existing list, and 
					give untrusted code that instead.
					<delay>2</delay>
					Note that this only gives a wrapper around the existing list - anything with access 
					to the original list can still modify it.
					<delay>2</delay>
					If you want to create a completely immutable list, you can either use a dedicated 
					class (e.g. ImmutableList in Guava) or create a copy of the original list, wrap 
					that copy using Collections.unmodifiableList, and throw away the reference to 
					the mutable list (so only the immutable wrapper knows about it).
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ immutable ^ arraylist object ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ immutable ^ arraylist ^</pattern>
		<template><srai>^ immutable ^ arraylist object ^</srai></template>
  </category>
	<category>
	  <pattern>^ arraylist ^ immutable ^</pattern>
		<template><srai>^ immutable ^ arraylist object ^</srai></template>
  </category>
	<category>
		
		<pattern>
			<!-- 98. Java - It's possible add an int and an String in the array? -->
			^ array ^ different types ^ 
		</pattern>
		<template>
			<random>
				<li>
					No, Java is a strongly-typed language.
					<delay>2</delay>
					So you cannot add a String and an int to the same array if the array is typed 
					as either String or int.
					<delay>2</delay>
					However if your array is typed as Object, you can add a String and an Integer 
					(an integer literal will be autoboxed) to that same array.
					<delay>2</delay>
					This is not recommended and is probably a sign that you should think more about 
					your design.
					<delay>2</delay>
					The first question you need to ask yourself is why you need to do this.
					<delay>2</delay>
					If you do have a valid reason, then it would be better to convert from one to 
					the other instead of having an array typed as Object.
					<delay>2</delay>
					Having a catch-call array where you can shove in any object in a bad idea for 
					many reasons:
					You are enforcing no separation between the objects.
					<delay>2</delay>
					Are the objects actually related to each other?
					<delay>2</delay>
					If so you type then using an interface or create an abstract class that each of 
					the types extend.
					<delay>2</delay>
					Since you have no separation between the objects, anything you pull out of the 
					array is an Object.
					<delay>2</delay>
					How would you know what it is?
					<delay>2</delay>
					You need to inspect its type explicitly.
					<delay>2</delay>
					This is an extremely cumbersome and unmaintainable design. 
					<delay>2</delay>
					You essentially end up losing type-safety and will not be able to benefit from 
					type-mismatch errors that will show up during compilation.
					<delay>2</delay>
					This will hide possible errors in your code where you may have forgotten to inspect 
					the type, or where you are casting an object to the wrong type.
					<delay>2</delay>
					This can lead to all kinds of nightmarish bugs.
					<delay>2</delay>
					Your code is going to be littered with explicit checks and casts and will be unmaintainable 
					(by you or anyone else).
					<delay>2</delay>
					Your code leaks abstraction everywhere.
					<delay>2</delay>
					No one can look at the array and realize what the array contains.
					<delay>2</delay>
					Anyone who uses your code needs to remember an overwhelming amount of detail as 
					to what types of objects the array can contain. 
					<delay>2</delay>
					Obfuscation is never a valid reason.
					<delay>2</delay>
					Code should be clear, easy to read, easy to maintain, and easy to understand (
					for you and for anyone else who will read your code).
					<delay>2</delay>
					Any code that looks obfuscated or is "clever" either needs to be rewritten or 
					documented extensively to explain the reason for its "cleverness".
					<delay>2</delay>
					As far as obfuscating the source, it is a non-issue since you're going to be distributing 
					the String0 files anyway.
					<delay>2</delay>
					You can run that through a decompiler to look at the source code.
					<delay>2</delay>
					There is nothing you can do at the source level to satisfactorily obfuscate your 
					code; you're only going to make it difficult for you or anyone else to maintain.
					<delay>2</delay>
					Obfuscation can be done at the byte-code level and so that doesn't really apply 
					to this situation.
				</li>
				<li>
					Yes it is possible, but it is not good practice.
					<delay>2</delay>
					Object[] myObjects = new Object[] {array1[i], array2[i], "name1", value1, value2, "name2",  value1, value....};<break/>
					<delay>2</delay>
					It must be array of objects
				</li>
				<li>
					In your string array you could have "123" and then convert it to an int later 
					when you need it.
				</li>
				<li>
					You can't add a primitive types (including int) to an array with Objects such 
					as String.  
					<delay>2</delay>
					However, autoboxing of int to Integer will make this possible if you declare an 
					Object[] array.
					<delay>2</delay>
					Object[] array = new Object[2];<break/>
					array[0] = "Hello";<break/>
					array[1] = 42;<break/>
					<delay>2</delay>
					Though I wouldn't recommend doing this if modeling this String and int as attributes 
					of a class would work.
				</li>
				<li>
					Yes it definitely is possible, just have an array of raw objects.
					<delay>2</delay>
					For example:
					Object[] arr = new Object[10];<break/>
					arr[0] = 10; // boxed to Integer class<break/>
					arr[1] = "foo"; // String class<break/>
					Then you can use instanceof to determine the type of object stored at a particular 
					index.
					<delay>2</delay>
					For example:
					<delay>2</delay>
					if (arr[0] instanceof Integer) ((Integer) arr[0]) += 10;<break/>
					Note that this is not necessarily a good practise to get used to, but it does 
					have applications.
				</li>
				<li>
					Strictly speaking:
					<delay>2</delay>
					No.
					<delay>2</delay>
					Otherwise:
					<delay>2</delay>
					Yes for most practical purposes:
					Object[] array = { 42, "foo" };<break/>
					Please note, that the 42 is not an int but an `Integer.
					<delay>2</delay>
					But due to autoboxing and unboxing you wont notice the difference.
					<delay>2</delay>
					The tradeoff is of course performance and garbage collector overhead.
					<delay>2</delay>
					Also the array must be of type Object[], not of type String[] nor of type int[].
				</li>
				<li>
					You can use java.util.ArrayList to do this.
					<delay>2</delay>
					You will need to make sure that you check carefully what you are getting when 
					you pull items out though.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ array ^ different types ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ different types ^ same arrray ^</pattern>
		<template><srai>^ array ^ different types ^</srai></template>
  </category>
	<category>
	  <pattern>^ array ^ different type ^ elements ^</pattern>
		<template><srai>^ array ^ different types ^</srai></template>
  </category>
	<category>
	  <pattern>^ array ^ different type ^ items ^</pattern>
		<template><srai>^ array ^ different types ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 99. Get mimetype from byte array without external lib -->
			^ get mimetype ^ byte array ^
		</pattern>
		<template>
			<random>
				<li>
					There is a way to do that using Java 7, but it is kind of clumsy (um tanto "desajeitado"):  
					<delay>2</delay>
					write the bytes to a (temporary) file,  
					use Files.probeContentType(Path) to check the contents of that file
					if the bytes came from a file you could use probeContentType directly on it.  
					<delay>2</delay>
					This is not very useful, at least on Windows: probeContentType seams to primarily use 
					the file extension to determine the file type [:-|
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ get mimetype ^ byte array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ retrieve mimetype ^ byte array ^</pattern>
		<template><srai>^ get mimetype ^ byte array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 100. How to escape ArrayIndexOutOfBoundsException? -->
			^ escape arrayindexoutofbounds exception ^
		</pattern>
		<template>
			<random>
				<li>
					Use iterators or enhanced for-loops to abstract away the explicit use of array 
					indexes:
					Iterator&lt;Object&gt; myIterator = Arrays.asList(arrayOfObjects).iterator();<break/>
					while(myIterator.hasNext()) {<break/>
					    doSomething(myIterator.next());<break/>
					}<break/>
					or
					for(Object o : arrayOfObjects) {<break/>
					    doSomething(o);<break/>
					}<break/>
					<delay>2</delay>
					Iterators and enhanced for-loops work with ArrayLists (and many other collections), too:
					for(Question myQuestion : q) {<break/>
					    doSomethingWithAQuestion(myQuestion);<break/>
					}<break/>
				</li>
				<li>
					Try this code: <break/>
					int i = 0;<break/>List&lt;Object&gt; list = getListOfUnknownSize();<break/>
					while(list != null &amp;&amp; i &lt; list.size()) {<break/>
					    process(list.get(i));<break/>
					    i++;<break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ escape arrayindexoutofbounds exception ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ escape arrayindexoutofboundsexception ^</pattern>
		<template><srai>^ escape arrayindexoutofbounds exception ^</srai></template>
  </category>
	<category>
	  <pattern>^ escape indexoutofboundsexception ^</pattern>
		<template><srai>^ escape arrayindexoutofbounds exception ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 101. How to create a list with specific size of elements -->
			^ create ^ list ^ specific size ^
		</pattern>
		<template>
			<random>
				<li>
					You can use Collections.nCopies.
					<delay>2</delay>
					Note however that the list returned is immutable.
					<delay>2</delay>
					In fact, the docs says "it the newly allocated data object is tiny (it contains 
					a single reference to the data object)".
					<delay>2</delay>
					If you need a mutable list, you would do something like
					List&lt;String&gt; hellos = new ArrayList&lt;String&gt;(Collections.nCopies(1000, "Hello"));<break/>
					<delay>2</delay>
					If you want 1000 distinct objects, you can use
					List&lt;YourObject&gt; objects = Stream.generate(YourObject::new)<break/>                                 .limit(1000)<break/>                                 .collect(Collectors.toList());<break/>
					Again, there is not guarantees about the capabilities of the resulting list implementation.
					<delay>2</delay>
					If you need, say an ArrayList, you would do
					...<break/>
					.collect(ArrayList::new);<break/>
				</li>
				<li>
					Fastest : int[] myList = new int[1000] will contain 1000 elements equal to zero.
					<delay>2</delay>
					But I'm sure it doesn't suit your needs.
					<delay>2</delay>
					Tell us more of what you need and I might be able to help :)
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ create ^ list ^ specific size ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ build ^ list ^ specific size ^</pattern>
		<template><srai>^ create ^ list ^ specific size ^</srai></template>
  </category>
	<category>
	  <pattern>^ declare ^ list ^ specific size ^</pattern>
		<template>^ create ^ list ^ specific size ^<srai></srai></template>
  </category>
	<category>
	  <pattern>^ create ^ list ^ specific size ^</pattern>
		<template><srai>^ create ^ list ^ specific size ^</srai></template>
  </category>
	<category>
	  <pattern>^ specific size ^ list ^</pattern>
		<template><srai>^ create ^ list ^ specific size ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 102. Merge 3 arraylist to one -->
			^ merge ^ arraylist ^ one ^
		</pattern>
		<template>
			<random>
				<li>
					Use ArrayList.addAll().
					<delay>2</delay>
					Something like this should work (assuming lists contain String objects; you should change 
					accordingly).
					<delay>2</delay>
					List&lt;String&gt; combined = new ArrayList&lt;String&gt;();<break/>
					combined.addAll(firstArrayList);<break/>
					combined.addAll(secondArrayList);<break/>
					combined.addAll(thirdArrayList);<break/>
				</li>
				<li>
					What about using java.util.Arrays.asList to simplify merging?
					<delay>2</delay>
					List&lt;String&gt; one = Arrays.asList("one","two","three");<break/>
					List&lt;String&gt; two = Arrays.asList("four","five","six");<break/>
					List&lt;String&gt; three = Arrays.asList("seven","eight","nine");<break/>
					List&lt;List&lt;String&gt;&gt; merged = Arrays.asList(one, two, three);<break/>
					<delay>2</delay>
				</li>
				<li>
					Using Java 8 Streams:
					List of List
					List&lt;List&lt;String&gt;&gt; listOfList = Stream.of(list1, list2, list3).collect(Collectors.toList());<break/>
					List of Strings
					<delay>2</delay>
					List&lt;String&gt; list = Stream.of(list1, list2, list3).flatMap(Collection::stream).collect(Collectors.toList());<break/>
					<delay>2</delay>
					Using Java 9 List.of static factory method
					<delay>2</delay>
					(Warning: this list is immutable and disallows null)
					<delay>2</delay>
					List&lt;List&lt;String&gt;&gt; = List.of(list1, list2, list3);<break/>
					Where list1, list2, list3 are of type List&lt;String&gt;
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ merge ^ arraylist ^ one ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
	  <pattern>^ combine ^ arraylist ^ one ^</pattern>
		<template><srai>^ merge ^ arraylist ^ one ^</srai></template>
  </category>
	<category>
	  <pattern>^ merge ^ arraylists ^ one ^</pattern>
		<template><srai>^ merge ^ arraylist ^ one ^</srai></template>
  </category>
	<category>
	  <pattern>^ combinw ^ arraylists ^ one ^</pattern>
		<template><srai>^ merge ^ arraylist ^ one ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 103. Avoiding duplicate integers in an integer array -->
			^ avoiding ^ duplicate ^ elements ^ 
		</pattern>
		<template>
			<random>
				<li>
					without using any of the collections i.e. Arraylist or Set etc.?
					<delay>2</delay>
					Just check through array before inserting, you could use insertion sort and do the binarysearch it would be little faster
				</li>
				<li>
					Write a method that adds the value to the array.
					<delay>2</delay>
					Before adding, scan the array if the value exists.
					<delay>2</delay>
					Skip the adding if it does exist.
					<delay>2</delay>
					Use only that method to add values to the array.
					<delay>2</delay>
					Ideally bundle the array and the method in a class.
				</li>
				<li>
					You can create another array, let's call it exists, of type boolean.
					<delay>2</delay>
					Then each time you add an integer to your main list check if exists[newNumber].
					<delay>2</delay>
					If the value is true it already exists, otherwise add the number to the integer 
					array and set the boolean value to true. 
					<delay>2</delay>
					This solution works well if the number range has a small bound.
					<delay>2</delay>
					Note, my example also assumes the integer is positive.
					<delay>2</delay>
					Some optimization is to use a long[] array and use each bit as a flag.
				</li>
				<li>
					First Assuming the Array is a buffer and has extra Space. 
					<delay>2</delay>
					Simply loop through it checking each value.
					<delay>2</delay>
					Such As
					for(int i=0;  i&lt;endpointer  &amp;&amp;i &lt; buffer.length  ; i++){<break/>        if(buffer[i]==valueToPutInArray){<break/>            valueExists=true;<break/>            break;<break/>        }<break/>    }<break/>    if(!valueExists)    {<break/>        buffer[endpointer++]=valueToPutInArray;<break/>    }<break/>
					If the Array is must be reallocated then you have to do something like this:
					int i=0;<break/>
					Integer[] outputArray = new Integer[buffer.length+1];<break/>
					for(Integer value : buffer) {<break/>
							if(value==valueToPutInArray){<break/>
									valueExists=true;<break/>
									break;<break/>
							}<break/>
							outputArray[i++]=value;<break/>
					}<break/>
					if(!valueExists)    {<break/>
							outputArray[i]=valueToPutInArray;<break/>
					}<break/>
				</li>
				<li>
					The solution depends on your requirement.
					<delay>2</delay>
					If you have a small array size (n&lt;10^6), scanning through the array on 
					every insertion would suffice, but if you have a large array and frequent 
					insertions, I would propose a different solution.
					<delay>2</delay>
					Scanning through an array on every insertion would require a complexity of O(n).
					<delay>2</delay>
					For small numbers, the overhead is ignorable, but as the size of array increases
					, traversal on every insertion is inefficient.
					<delay>2</delay>
					If you need performance and if memory is not your constraint, you can take 
					a boolean array and initialize all elements to false.
					<delay>2</delay>
					Then whenever you get a number, make its index value in the boolean array 
					to true, And while inserting, check whether the boolean value at the index 
					number of the element being inserted.
					<delay>2</delay>
					Here is the code to initialize the boolean array
					<delay>2</delay>
					(initializing it would make all elements false):
					<delay>2</delay>
					boolean [] duplicateValuesArray = new boolean[Integer.MAX_VALUE];<break/>
					Here is the function which inserts an element in the array:
					public void insertElement(int elementToBeInserted) {<break/>
						if(!duplicateValuesArray[elementToBeInserted])  //check if element already in array<break/>
							duplicateValuesArray[elementToBeInserted] = true;<break/>
							mainArray[index++] = elementToBeInserted;<break/>
					}<break/>
					<delay>2</delay>
					In this way, whenever you get a number, value for that index in the boolean 
					array is set to true, and while insertion, everytime the index is checked
					, if value is true, that element exists in the array, do not insert it.
					<delay>2</delay>
					The complexity for this is much lower if you have a large mainArray (n>10^6)
					<delay>2</delay>
					and you have frequent insertions.
					<delay>2</delay>
					This is because, initializing a boolean array is one time O(n) complexity
					, and after that, checking for the element in the boolean array and insertion 
					of element is just O(1) operation, happens in constant time. 
					<delay>2</delay>
					Thus effective complexity is reduced to just initializing the boolean array.
					<delay>2</delay>
					And even in terms of memory footprint, I wouldn't mind because a boolean 
					primitive just occupies one bit in the memory.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ avoiding ^ duplicate ^ elements ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ avoid ^ duplicate ^ elements ^</pattern>
		<template><srai>^ avoiding ^ duplicate ^ elements ^</srai></template>
  </category>
	<category>
		<pattern>^ no ^ duplicate ^ elements ^</pattern>
		<template><srai>^ avoiding ^ duplicate ^ elements ^</srai></template>
  </category>
	<category>
		<pattern>^ avoiding ^ duplicate ^ items ^</pattern>
		<template><srai>^ avoiding ^ duplicate ^ elements ^</srai></template>
  </category>
	<category>
		<pattern>^ avoid ^ duplicate ^ items ^</pattern>
		<template><srai>^ avoiding ^ duplicate ^ elements ^</srai></template>
  </category>
	<category>
		<pattern>^ no ^ duplicate ^ items ^</pattern>
		<template><srai>^ avoiding ^ duplicate ^ elements ^</srai></template>
  </category>
	<category>
		<pattern>^ without ^ duplicate ^ elements ^</pattern>
		<template><srai>^ avoiding ^ duplicate ^ elements ^</srai></template>
  </category>
	<category>
		<pattern>^ without ^ duplicate ^ items ^</pattern>
		<template><srai>^ avoiding ^ duplicate ^ elements ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 104. How can I create an array of classes in Java? -->
			^ create ^ array ^ classes ^
		</pattern>
		<template>
			<random>
				<li>
					Something like:
					Class[] classes = new Class[] {Class1.class, Class2.class};<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ create ^ array ^ classes ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ build ^ array ^ classes ^</pattern>
		<template><srai>^ create ^ array ^ classes ^</srai></template>
  </category>
	<category>
		<pattern>^ declare ^ array ^ classes ^</pattern>
		<template><srai>^ create ^ array ^ classes ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 105. Converting a double[] array into string[] array -->
			^ converting ^ double array ^ string array ^
		</pattern>
		<template>
			<random>
				<li>
					You'll need to create a target array of equal size to the original array, 
					and iterate over it, converting element by element.
					<delay>2</delay>
					Example:
					double[] d = { 2.0, 3.1 };<break/>
					String[] s = new String[d.length];<break/>
					for (int i = 0; i &lt; s.length; i++)<break/>
					    s[i] = String.valueOf(d[i]);<break/>
				</li>
				<li>
					As already mentioned you have to iterate and convert every item from double 
					to String.
					<delay>2</delay>
					Alternatively it's also possible to avoid an explicit iteration and do the 
					following:
					// source array<break/>
					Double[] d_array = new Double[] { 1, 2, 3, 4 };<break/>
					// create a string representation like [1.0, 2.0, 3.0, 4.0]<break/>
					String s = Arrays.toString(d_array);<break/>
					// cut off the square brackets at the beginning and at the end<break/>
					s = s.substring(1, s.length - 1);<break/>
					// split the string with delimiter ", " to produce an array holding strings<break/>
					String[] s_array = s.split(", ");<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ converting ^ double array ^ string array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ transform ^ double array ^ string array ^</pattern>
		<template><srai>^ converting ^ double array ^ string array ^</srai></template>
  </category>
	<category>
		<pattern>^ converting ^ double[] ^ string[] ^</pattern>
		<template><srai>^ converting ^ double array ^ string array ^</srai></template>
  </category>
	<category>
		
		<pattern>
			<!-- 106. Java - adding elements to list while iterating over it -->
			^ adding elements ^ list ^ iterating ^
		</pattern>
		<template>
			<random>
				<li>
					Create a new list, and populate that one.
					<delay>2</delay>
					List&lt;MyType&gt; originalList = ...<break/>
					List&lt;MyType&gt; newList = new ArrayList&lt;&gt;(originalList);<break/>
					for(MyType type : originalList)<break/>
					{<break/>
					  // Some decisions<break/>
					  newList.add(new MyType());<break/>
					}<break/>
				</li>
				<li>
					There are three approaches to avoid above exception
					You can convert the list to an array and then iterate on the array.
					<delay>2</delay>
					This approach works well for small or medium size list but if the list is 
					large then it will affect the performance a lot.
					<delay>2</delay>
					You can lock the list while iterating by putting it in a synchronized block.
					<delay>2</delay>
					This approach is not recommended because it will cease the benefits of multithreading.
					<delay>2</delay>
					If you are using JDK1.5 or higher then you can use ConcurrentHashMap and 
					CopyOnWriteArrayList classes.
					<delay>2</delay>
					It is the recommended approach.
				</li>
				<li>
					Instead of using an iterator, you can use a for loop with an index.  
					<delay>2</delay>
					For example:
					int originalLength = list.length();<break/>
					for (int i = 0; i &lt; originalLength; i++) {<break/>
					  MyType mt = list.get(i);<break/>
					  //... processing<break/>
					  //... insertions<break/>
					}<break/>
				</li>
				<li>
					You want to use a ListIterator.  
					<delay>2</delay>
					You can get one of these from any kind of list, though for efficiency you 
					probably want to get one from a LinkedList.
					<delay>2</delay>
					import java.util.*;<break/>
					class TestListIterator {<break/>
					  public static void main(String[]args) {<break/>
					    List&lt;Integer&gt; L = new LinkedList&lt;Integer&gt;();<break/>
					    L.add(0);<break/>
					    L.add(1);<break/>
					    L.add(2);<break/>
					    for (ListIterator&lt;Integer&gt; i = L.listIterator(); i.hasNext(); ) {<break/>
					      int x = i.next();<break/>
					      i.add(x + 10);<break/>
					    }<break/>
					    System.out.println(L);<break/>
					  }<break/>
					}<break/>
					Prints [0, 10, 1, 11, 2, 12].
				</li>
				<li>
					You may use a ListIterator which has support for a remove/add method during 
					the iteration itself.
					<delay>2</delay>
					ListIterator&lt;Book&gt; iter = books.listIterator();<break/>
					while(iter.hasNext()){<break/>
					    if(iter.next().getIsbn().equals(isbn)){<break/>
					        iter.add(new Book(...));<break/>
					    }<break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ adding elements ^ list ^ iterating ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ add elements ^ list ^ iterating ^</pattern>
		<template><srai>^ adding elements ^ list ^ iterating ^</srai></template>
  </category>
	<category>
		<pattern>^ adding items ^ list ^ iterating ^</pattern>
		<template><srai>^ adding elements ^ list ^ iterating ^</srai></template>
  </category>
	<category>
		<pattern>^ add items ^ list ^ iterating ^</pattern>
		<template><srai>^ adding elements ^ list ^ iterating ^</srai></template>
  </category>
	<category>
		<pattern>^ insert elements ^ list ^ iterating ^</pattern>
		<template><srai>^ adding elements ^ list ^ iterating ^</srai></template>
  </category>
	<category>
		<pattern>^ insert items ^ list ^ iterating ^</pattern>
		<template><srai>^ adding elements ^ list ^ iterating ^</srai></template>
  </category>
	<category>
		<pattern>^ inserting elements ^ list ^ iterating ^</pattern>
		<template><srai>^ adding elements ^ list ^ iterating ^</srai></template>
  </category>
	<category>
		<pattern>^ inser items ^ list ^ iterating ^</pattern>
		<template><srai>^ adding elements ^ list ^ iterating ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 107. Retrieving elemnts from an ArrayList by specifying the indexes -->
			^ retrieving elemnts ^ arraylist ^ index ^
		</pattern>
		<template>
			<random>
				<li>
					Yes you can use the subList method:
					<delay>2</delay>
					List&lt;...&gt; list2 = list1.subList(startIndex, endIndex);<break/>
					<delay>2</delay>
					This returns a view on that part of the original list, it does not copy the data.
					<delay>2</delay>
					If you want a copy:
					List&lt;...&gt; list2 = new ArrayList&lt;...&gt; (list1.subList(startIndex, endIndex));<break/>
				</li>
				<li>
					You can use the following logic<break/>
					/create an ArrayList object<break/>
					ArrayList arrayList = new ArrayList();<break/>
					//Add elements to Arraylist<break/>
					arrayList.add("1");<break/>
					arrayList.add("2");<break/>
					arrayList.add("3");<break/>
					arrayList.add("4");<break/>
					arrayList.add("5");<break/>
					/*<break/>
							To get a sub list of Java ArrayList use<break/>
							List subList(int startIndex, int endIndex) method.<break/>
							This method returns an object of type List containing elements from<break/>
							startIndex to endIndex - 1.<break/>
					*/<break/>
					List lst = arrayList.subList(1,3);<break/>
					//display elements of sub list.<break/>
					System.out.println("Sub list contains : ");<break/>
					for(int i=0; i&lt; lst.size() ; i++)<break/>
						System.out.println(lst.get(i));<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ retrieving elemnts ^ arraylist ^ index ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ retrieving items ^ arraylist ^ index ^</pattern>
		<template><srai>^ retrieving elemnts ^ arraylist ^ index ^</srai></template>
  </category>
	<category>
		<pattern>^ get elemnts ^ arraylist ^ index ^</pattern>
		<template><srai>^ retrieving elemnts ^ arraylist ^ index ^</srai></template>
  </category>
	<category>
		<pattern>^ get items ^ arraylist ^ index ^</pattern>
		<template><srai>^ retrieving elemnts ^ arraylist ^ index ^</srai></template>
  </category>
	<category>
		<pattern>^ arraylist ^ get elements ^ index ^</pattern>
		<template><srai>^ retrieving elemnts ^ arraylist ^ index ^</srai></template>
  </category>
	<category>
		<pattern>^ arraylist ^ get items ^ index ^</pattern>
		<template><srai>^ retrieving elemnts ^ arraylist ^ index ^</srai></template>
  </category>
	<category>
		<pattern>^ getting ^ elemnts ^ arraylist ^ index ^</pattern>
		<template><srai>^ retrieving elemnts ^ arraylist ^ index ^</srai></template>
  </category>
	<category>
		<pattern>^ getting ^ items ^ arraylist ^ index ^</pattern>
		<template><srai>^ retrieving elemnts ^ arraylist ^ index ^</srai></template>
  </category>
	<category>
		
		<pattern>
			<!-- 108. Is it possible to initialize array in an interface? -->
			^ initialize array ^ interface ^
		</pattern>
		<template>
			<random>
				<li>
					Why don't you just try it out?
					<delay>2</delay>
					public interface Example {<break/>
					    int[] values = { 2, 3, 5, 7, 11 };<break/>
					}<break/>
				</li>
				<li>
					Yes, but only if it's static.
					<delay>2</delay>
					In fact, any variables declared in an interface will automatically be static.
					<delay>2</delay>
					public interface ITest {<break/>
					    public static String[] test = {"1", "2"}; // this is ok<break/>
					    public String[] test2 = {"1", "2"}; // also ok, but will be silently converted to static by the compiler<break/>
					}<break/>
					<delay>2</delay>
					You can't have static initializers though.
					<delay>2</delay>
					public interface ITest {<break/>
					    public static String[] test;<break/>
					    static {<break/>
					        // this is not OK. No static initializers allowed in interfaces.<break/>
					    }<break/>
					}<break/>
					<delay>2</delay>
					Obviously, you can't have constructors in interfaces.
				</li>
				<li>
					Yes, it's possible.
					<delay>2</delay>
					See the code:
					public interface Test {<break/>
					  int[] a= {1,2,3};<break/>
					}<break/>
					public class Main {<break/>
					  public static void main(String[] args) {<break/>
					    int i1 = Test.a[0];<break/>
					    System.out.println(i1);<break/>
					  }<break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ initialize array ^ interface ^</postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ array ^ initialization ^ interface ^</pattern>
		<template><srai>^ initialize array ^ interface ^</srai></template>
  </category>
	<category>
		<pattern>^ init ^ array ^ interface ^</pattern>
		<template><srai>^ initialize array ^ interface ^</srai></template>
  </category>
	<category>
		<pattern>^ initialize ^ array ^ interface ^</pattern>
		<template><srai>^ initialize array ^ interface ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 109. Java: How to convert String[] to List or Set -->
			^ convert ^ array ^ list ^
		</pattern>
		<template>
			<random>
				<li>
					The easiest way would be:
					String[] myArray = ...;<break/>
					List&lt;String&gt; strs = Arrays.asList(myArray);<break/>
					using the handy Arrays utility class.
					<delay>2</delay>
					Note, that you can even do
					List&lt;String&gt; strs = Arrays.asList("a", "b", "c");<break/>
				</li>
				<li>
					This should do the trick:<break/>
					<delay>2</delay>
					java.util.Arrays.asList(new String[]{"a", "b"})<break/>
				</li>
				<li>
					The easiest way is through  
					Arrays.asList(stringArray);<break/>
				</li>
				<li>
					Arrays.asList() would do the trick here.
					<delay>2</delay>
					String[] words = {"ace", "boom", "crew", "dog", "eon"};   <break/>
					List&lt;String&gt; wordList = Arrays.asList(words);  <break/>
					For converting to Set, you can do as below
					Set&lt;T&gt; mySet = new HashSet&lt;T&gt;(Arrays.asList(words)); <break/>
				</li>
				<li>
					This should help you:<break/>
					String[] w = {"a", "b", "c", "d", "e"};  <break/>
					List&lt;String&gt; wL = Arrays.asList(w);  <break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ convert ^ array ^ list ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>
			<!-- 110. Optimal way to sort an array -->
			^ sort ^ array ^
		</pattern>
		<template>
			<random>
				<li>
					Use some kind of QuickSort or MergeSort if you want to implement fast sorting on your own.
					<delay>2</delay>
					Otherwise use the built in java sort functions.
				</li>
				<li>
					When you have the the Power bring it to good use...
					<delay>2</delay>
					Why reinvent the wheel ???<break/>
					Use  Arrays.sort() to sort the Array.
					<delay>2</delay>
					- If what you hold in the Array is some kind of object and it needs to be 
					sorted in More than One way.... then first convert it in to a ArrayList 
					(or List) using Arrays.asList(array)<break/>
					Example:<break/>
					Song[] dog = new Song[10];<break/>
					ArrayList&lt;Song&gt; list = new ArrayList&lt;Song&gt;(Arrays.asList(arr));<break/>
					Then use java.util.Comparator Interface, to sort the Object on basis of more 
					than one attribute. 
					<delay>2</delay>
					Example:
          Class Song can be sorted on the basis of its track title or Singer and more 
					using Comparator Interface.
					<delay>2</delay>
					- Using Collections are lot more flexible than Array.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ sort ^ array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ array ^ sorting ^</pattern>
		<template><srai>^ sort ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ sorting ^ arrays ^</pattern>
		<template><srai>^ sort ^ array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 111. Convert String to array of integer in java -->
			^ convert string ^ array ^ integer ^
		</pattern>
		<template>
			<random>
				<li>
					Try this:
					String[] array = "1,2,3,4,5".split(",");<break/>
					int[] result = new result[array.length];<break/>
					for (int i = 0; i &lt; array.length; i++) {<break/>
					    try {<break/>
					         result[i] = Integer.parseInt(array[i]);<break/>
					    } catch (NumberFormatException nfe) {};<break/>
					}<break/>
				</li>
				<li>
					Use StringTokenizer which will split string by comma and then put those values
					/tokens in array of integers.
					<delay>2</delay>
					public static int[] getIntegers(String numbers) {<break/>
					    StringTokenizer st = new StringTokenizer(numbers, ",");<break/>
					    int[] intArr = new int[st.countTokens()];<break/>
					    int i = 0;<break/>
					    while (st.hasMoreElements()) {<break/>
					        intArr[i] = Integer.parseInt((String) st.nextElement());<break/>
					        i++;<break/>
					    }<break/>
					    return intArr;<break/>
					}<break/>
				</li>
				<li>
					This code should work:<break/>
					String [] str = "1,2,3,4,5".split(",");<break/>
					int arrayInt[] = new int[str.length];<break/>
					for (int i = 0; i &lt; str.length; i++) <break/>
					    arrayInt[i]=Integer.valueOf(str[i]);<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ convert string ^ array ^ integer ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ converting string ^ array ^ integer ^</pattern>
		<template><srai>^ convert string ^ array ^ integer ^</srai></template>
  </category>
	<category>
		<pattern>^ convert string ^ integers ^ array ^</pattern>
		<template><srai>^ convert string ^ array ^ integer ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 112. Does the contains() method in Java ArrayList use binary search? -->
			^ arraylist ^ contains ^ binary search ^
		</pattern>
		<template>
			<random>
				<li>
					No, you need to use Collections to use binary search, usually after sorting it.  
					<delay>2</delay>
					An ArrayList doesn't know anything about its ordering, and you have to know 
					a list is sorted before you can use binary search.
					<delay>2</delay>
					Alternately, you could use TreeSet, which is as efficient as using a binary 
					search.
				</li>
				<li>
					No, it doesn't use binary search as lists don't have to be sorted.
					<delay>2</delay>
					Use the utility methods of the Collections class to first sort the list and 
					then to perform a binary search.
				</li>
				<li>
					No, it would mean adding a overhead at each insertion
					<delay>2</delay>
					so it's not included.
				</li>
				<li>
					No, you need to use Collections to use binary search, usually after sorting it. 
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ arraylist ^ contains ^ binary search ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ arraylist ^ contain ^ binary search ^</pattern>
		<template><srai>^ arraylist ^ contains ^ binary search ^</srai></template>
  </category>
	<category>
		<pattern>^ arraylist ^ contains() ^ binary search ^</pattern>
		<template><srai>^ arraylist ^ contains ^ binary search ^</srai></template>
  </category>
	<category>
		<pattern>^ contains method ^ arraylist ^ binary search ^</pattern>
		<template><srai>^ arraylist ^ contains ^ binary search ^</srai></template>
  </category>
	<category>
		<pattern>^ contain method ^ arraylist ^ binary search ^</pattern>
		<template><srai>^ arraylist ^ contains ^ binary search ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 113. How to find the maximum value in an array? -->
			^ find ^ maximum value ^ array ^
		</pattern>
		<template>
			<random>
				<li>
					Iterate over the Array.
					<delay>2</delay>
					First initialize the maximum value to the first element of the array and 
					then for each element optimize it if the element under consideration is greater.
				</li>
				<li>
					If you can change the order of the elements:
					int[] myArray = new int[]{1, 3, 8, 5, 7, };<break/>
					Arrays.sort(myArray);<break/>
					int max = myArray[myArray.length - 1];<break/>
					<delay>2</delay>
					If you can't change the order of the elements:
					int[] myArray = new int[]{1, 3, 8, 5, 7, };<break/>
					int max = Integer.MIN_VALUE;<break/>
					for(int i = 0; i &lt; myArray.length; i++) {<break/>
					      if(myArray[i] &gt; max) {<break/>
					         max = myArray[i];<break/>
					      }<break/>
					}<break/>
				</li>
				<li>
					Have a max int and set it to the first value in the array.
					<delay>2</delay>
					Then in a for loop iterate through the whole array and see if the max int 
					is larger than the int at the current index.
					<delay>2</delay>
					int max = array.get(0);<break/>
					for (int i = 1; i &lt; array.length; i++) {<break/>
					    if (array.get(i) &gt; max) {<break/>
					      max = array.get(i);<break/>
					    }<break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ find ^ maximum value ^ array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ find ^ maximum ^ array ^</pattern>
		<template><srai>^ find ^ maximum value ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ retrieve ^ maximum ^ array ^</pattern>
		<template><srai>^ find ^ maximum value ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ get ^ maximum ^ array ^</pattern>
		<template><srai>^ find ^ maximum value ^ array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 114. Split the String into a String array -->
			^ split ^ string ^ string array ^
		</pattern>
		<template>
			<random>
				<li>
					Try this:
					String arr[] = "George\nWashington".split("\\n"));<break/>
				</li>
				<li>
					Try this method<break/>
					String[] array = arr.split("\\n");<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ split ^ string ^ string array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ split ^ string ^ array ^ strings ^</pattern>
		<template><srai>^ split ^ string ^ string array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 115. compare int before its placed into an array? -->
			^ compare int ^ placed ^ array ^
		</pattern>
		<template>
			<random>
				<li>
					Use a Set&lt;Integer&gt;, duplicates will not be stored.
				</li>
				<li>
					The best way is called LinkedHashSet&lt;Integer&gt; if you need order or 
					just Set&lt;Integer&gt; (any implementation) if you don't
				</li>
				<li>
					boolean duplicate = false;<break/>
					int input = 5;<break/>
					int[] a = new int[5];<break/>
					for(int x : a){<break/>
							if(x == input){<break/>
									duplicate = true;<break/>
									break;<break/>
							}<break/>
					}<break/>
					if(!duplicate){<break/>
							a[pos] = input;<break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ compare int ^ placed ^ array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ compare int ^ place ^ it ^ array ^</pattern>
		<template><srai>^ compare int ^ placed ^ array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 116. Java Check Position of Array is not "" (Empty) -->
			^ check ^ position ^ array ^ empty string ^
		</pattern>
		<template>
			<random>
				<li>
					String array[] = new String {" ", "hi", "there", " ", "how"};<break/>
					use a for cicle:
					int empty<break/>
					for(int i=0; i&lt;=array.length(); i++){<break/>
					    if(array[i].equals(" ") || array[i].equals("")){<break/>
					        empty++;<break/>
					    }<break/>
					}<break/>
					System.out.println("empty values: " + empty);<break/>
				</li>
				<li>
					This is a very simple one-liner.
					<delay>2</delay>
					java.util.Collections.frequency(java.util.Arrays.asList(myArray), "");<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ check ^ position ^ array ^ empty string ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ control ^ position ^ array ^ empty string ^</pattern>
		<template><srai>^ check ^ position ^ array ^ empty string ^</srai></template>
  </category>
	<category>
		<pattern>^ see ^ position ^ array ^ empty string ^</pattern>
		<template><srai>^ check ^ position ^ array ^ empty string ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 117. Searching a list -->
			^ searching ^ item ^ list ^
		</pattern>
		<template>
			<random>
				<li>
					Try this,<break/>
					String[] A = {"cat", "dog", "mouse", "fox", "bear", "wolf", "eagle", "moose", "parrot", "rabbit"};<break/>
					String animal = (args[0]);<break/>
					if(Arrays.asList(A).contains(animal))<break/>
					   {<break/>
					      System.out.println(" String " + animal + " was found using " + compCount + " comparisions. ");<break/>
					   }<break/>
					   else<break/>
					   {<break/>
					      System.out.println(" String " + animal + " could not be found, and " + compCount + " comparisons were performed. ");<break/>
					   }<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ searching ^ item ^ list ^</postback>
			</reply>
			<reply>
				
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ search ^ item ^ list ^</pattern>
		<template><srai>^ searching ^ item ^ list ^</srai></template>
  </category>
	<category>
		<pattern>^ searching ^ element ^ list ^</pattern>
		<template><srai>^ searching ^ item ^ list ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 118. Java replacing char at index -->
			^ replacing char ^ index ^
		</pattern>
		<template>
			<random>
				<li>
					You could accomplish this by using substring() to pick apart and recreate 
					the string, but another way is to just convert it to a char[] and operate 
					on that, e.g.:<break/>
					char[] data = captureString[0].toCharArray();<break/>
					data[strOneRand] = Character.toUpperCase(data[strOneRand]); // or whatever<break/>
					String outputFinal = new String(data);<break/>
					<delay>2</delay>
					An example of accomplishing this with substring() can be found in the accepted 
					answer of Replace a character at a specific index in a string?.
					<delay>2</delay>
					An example of doing it with a StringBuilder can be found there as well.
				</li>
				<li>
					You just need to do this 
					char[] charArray = captureString[0].toCharArray();<break/>
					charArray[strOneRand] = THE_NEW_CHARECTOR_YOU_WANT_TO_REPLACE;<break/>
					String outputFinal = String.copyValueOf(charArray);<break/>
				</li>
				<li>
					Try this approach:<break/>
					String a = captureString[0].substring(0,strOneRand);<break/>
					String b = captureString[0].substring(strOneRand,strOneRand+1).toUpperCase;<break/>
					String c = captureString[0].substring(strOneRand+1);<break/>
					System.out.println(a+b+c);<break/>
					replace method will make the first occurrence of chosen character to upper case.
					<delay>2</delay>
					if input string is "aaaaa", you will always get "Aaaaa".
				</li>
				<li>
					Here is what I would do in your situation:
					public void replaceChar(String strPassed, int index){<break/>
					    char strArray[] = strPassed.toCharArray(); <break/>
					    strArray[index] = (char)(strArray[index] - 32);<break/>
					    strPassed[0] = new String(strArray);<break/>
					}<break/>
					<delay>2</delay>
					and then wherever I wanted to convert the character into UpperCase:
					replaceChar(capturString[0], strOneRand);<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ replacing char ^ index ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ replace ^ char ^ index ^</pattern>
		<template><srai>^ replacing char ^ index ^</srai></template>
  </category>
	<category>
		<pattern>^ replacing ^ char ^ index ^</pattern>
		<template><srai>^ replacing char ^ index ^</srai></template>
  </category>
	<category>
		<pattern>^ substitute char ^ index ^</pattern>
		<template><srai>^ replacing char ^ index ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 119. How to convert a Java 8 Stream to an Array? -->
			^ convert ^ stream ^ array ^
		</pattern>
		<template>
			<random>
				<li>
					The easiest method is to use the toArray(IntFunction&lt;A[]&gt; generator
					) method with an array constructor reference.
					<delay>2</delay>
					This is suggested in the API documentation for the method.
					<delay>2</delay>
					String[] stringArray = stringStream.toArray(String[]::new);<break/>
					What it does is find a method that takes in an integer (the size) as argument
					, and returns a String[], which is exactly what (one of the overloads of
					) new String[] does.
					<delay>2</delay>
					You could also write your own IntFunction:
					Stream&lt;String&gt; stringStream = ...;<break/>
					String[] stringArray = stringStream.toArray(size -&gt; new String[size]);<break/>
					<delay>2</delay>
					The purpose of the IntFunction&lt;A[]&gt; generator is to convert an integer
					, the size of the array, to a new array.
					<delay>2</delay>
					Example code:<break/>
					Stream&lt;String&gt; stringStream = Stream.of("a", "b", "c");<break/>
					String[] stringArray = stringStream.toArray(size -&gt; new String[size]);<break/>
					Arrays.stream(stringArray).forEach(System.out::println);<break/>
					Prints:
					a<break/>b<break/>c<break/>
				</li>
				<li>
					If you want to get an array of ints, with values from 1 to 10, from a Stream
					&lt;Integer&gt;, there is IntStream at your disposal.
					<delay>2</delay>
					Here we create a Stream with a Stream.of method and convert a Stream&lt;Integer
					&gt; to an IntStream using a mapToInt.
					<delay>2</delay>
					Then we can call IntStream's toArray method.
					<delay>2</delay>
					Stream&lt;Integer&gt;0
					<delay>2</delay>
					Here is the same thing, without the Stream&lt;Integer&gt;1, using only the 
					Stream&lt;Integer&gt;2: Stream&lt;Integer&gt;3
				</li>
				<li>
					You can create a custom collector that convert a stream to array. 
					<delay>2</delay>
					public static &lt;T&gt; Collector&lt;T, ?, T[]&gt; toArray( IntFunction&lt;T[]&gt; converter )<break/>
					{<break/>
						return Collectors.collectingAndThen( <break/>
							Collectors.toList(), <break/>
							list -&gt;list.toArray( converter.apply( list.size() ) ) );<break/>
					}<break/>
					
					and a quick use
					List&lt;String&gt; input = Arrays.asList( ..... );<break/>
					String[] result = input.stream().<break/>
						.collect( CustomCollectors.**toArray**( String[]::new ) );<break/>
				</li>
				<li>
					Convert text to string array where separating each value by comma, and trim 
					every field, for example:<break/>
					String[] stringArray = Arrays.stream(line.split(",")).map(String::trim).toArray(String[]::new);<break/>
				</li>
				<li>
					You can use the collector like this
					Stream&lt;String&gt; io = Stream.of(&quot;foo&quot; , &quot;lan&quot; , &quot;mql&quot;);<break/>
					io.collect(Collectors.toCollection(ArrayList&lt;String&gt;::new));<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ convert ^ stream ^ array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ save ^ stream ^ array ^</pattern>
		<template><srai>^ convert ^ stream ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ put ^ stream ^ array ^</pattern>
		<template><srai>^ convert ^ stream ^ array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 120. Filling in a matrix in java -->
			^ filling ^ matrix ^
		</pattern>
		<template>
			<random>
				<li>
					This code should do exactly what you want:<break/>
					int [][] matrix = new int[10][20];<break/>
					for(int i = 0; i &lt; 10; i++) {<break/>
					    for(int j = 0; j &lt; 20; j++) {<break/>
					        // read information from somewhere<break/>
					        matrix[i][j] = information;<break/>
					    }<break/>
					}<break/>
				</li>
				<li>
					Try this approach:<break/>
					int [][] arr = new int[x][y];<break/>
					for(int i = 0; i &lt; x; i++) {        // it will run you through the lines <break/>
					    for(int j = 0; j &lt; y; j++) {    // this will run you through each cell in the raw selected<break/>
					        arr[i][j] = &lt;the thing you want to fill here&gt; ;<break/>
					    }<break/>
					}<break/>
					you can look at a matrix as an array of arrays the first for is to run trough the array
					<delay>2</delay>
					the second is for the cells in each array 
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ filling ^ matrix ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ fill ^ matrix ^</pattern>
		<template><srai>^ filling ^ matrix ^</srai></template>
  </category>
	<category>
		<pattern>^ filling ^ 2d array ^</pattern>
		<template><srai>^ filling ^ matrix ^</srai></template>
  </category>
	<category>
		<pattern>^ populate ^ matrix ^</pattern>
		<template><srai>^ filling ^ matrix ^</srai></template>
  </category>
	<category>
		<pattern>^ populate ^ 2d array ^</pattern>
		<template><srai>^ filling ^ matrix ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 121. Sorting an array of String based on the strings sizes (length) -->
			^ sorting ^ array ^ string based ^ strings sizes ^
		</pattern>
		<template>
			<random>
				<li>
					You can implement a Comparator that uses the length and use Arrays.sort with 
					your Comparator.
					<delay>2</delay>
					The Comparator could look like this:
					class StringComparator implements Comparator&lt;String&gt;{<break/>
					   public int compare(String o1, String o2){<break/>
					      return Integer.compare(o1.length(), o2.length());<break/>
					   }<break/>
					}<break/>
					<delay>2</delay>
					Now you could sort with the following call:
					Arrays.sort(strings, new StringComparator());<break/>
				</li>
				<li>
					In Java 8, this can be done in one line,
					Arrays.sort(randomString, (s1,s2) -&gt; Integer.compare(s1.length(), s2.length()));<break/>
					<delay>2</delay>
					If you want reverse order (higher-length to lower-length), change it to, 
					<delay>2</delay>
					Arrays.sort(randomString, (s1,s2) -&gt; Integer.compare(s2.length(), s1.length()));<break/>
					<delay>2</delay>
					Another approach, use Comparator.comparing(String::length), Arrays.sort(yourArray, Comparator.comparing(String::length)); <break/>
					to reverse the order, Arrays.sort(yourArray, Comparator.comparing(String::length).reversed()); <break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ sorting ^ array ^ string based ^ strings sizes ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ sort ^ array ^ string based ^ string sizes ^</pattern>
		<template><srai>^ sorting ^ array ^ string based ^ strings sizes ^</srai></template>
  </category>
	<category>
		<pattern>^ sorting ^ array ^ string by ^ string sizes ^</pattern>
		<template><srai>^ sorting ^ array ^ string based ^ strings sizes ^</srai></template>
  </category>
	<category>
		<pattern>^ sort ^ array ^ string by ^ string sizes ^</pattern>
		<template><srai>^ sorting ^ array ^ string based ^ strings sizes ^</srai></template>
  </category>
	<category>
		<pattern>^ sort ^ array ^ strings based ^ strings sizes ^</pattern>
		<template><srai>^ sorting ^ array ^ string based ^ strings sizes ^</srai></template>
  </category>
	<category>
		<pattern>^ sorting ^ array ^ strings by ^ strings sizes ^</pattern>
		<template><srai>^ sorting ^ array ^ string based ^ strings sizes ^</srai></template>
  </category>
	<category>
		<pattern>^ sort ^ array ^ strings by ^ strings sizes ^</pattern>
		<template><srai>^ sorting ^ array ^ string based ^ strings sizes ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 122. How can I define a method that can return the biggest variable in a array -->
			^ method ^ return ^ biggest variable ^ array ^
		</pattern>
		<template>
			<random>
				<li>
					You could do something like:
					Integer array[] = {1, 4, 3, 2};<break/>
					int max = Collections.max(Arrays.asList(array));<break/>
					System.out.println(max);<break/>
					Output: 4<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ method ^ return ^ biggest variable ^ array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ method ^ returns ^ biggest variable ^ array ^</pattern>
		<template><srai>^ method ^ return ^ biggest variable ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ method ^ return ^ biggest item ^ array ^</pattern>
		<template><srai>^ method ^ return ^ biggest variable ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ method ^ returns ^ biggest item ^ array ^</pattern>
		<template><srai>^ method ^ return ^ biggest variable ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ method ^ return ^ biggest element ^ array ^</pattern>
		<template><srai>^ method ^ return ^ biggest variable ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ method ^ returns ^ biggest element ^ array ^</pattern>
		<template><srai>^ method ^ return ^ biggest variable ^ array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 123. How to access an array thread safely in Java? -->
			^ access ^ array thread safely ^
		</pattern>
		<template>
			<random>
				<li>
					Operation on array in java is not thread safe.
					<delay>2</delay>
					Instead you may use ArrayList with Collections.synchronizedList()   
					<delay>2</delay>
					Suppose we are trying to populate a synchronized ArrayList of String.
					<delay>2</delay>
					Then you can add item to the list like - 
					List&lt;String&gt; list = <break/>
					Collections.synchronizedList(new ArrayList&lt;String&gt;());<break/>
					//Adding elements to synchronized ArrayList<break/>
					list.add("Item1");<break/>
					list.add("Item2");<break/>
					list.add("Item3"); <break/>
					Then access them from a synchronized block like this
					<delay>2</delay>
					synchronized(list) {<break/>
						Iterator&lt;String&gt; iterator = list.iterator(); <break/>
						while (iterator.hasNext())<break/>
						System.out.println(iterator.next());<break/>
					}  <break/>
					<delay>2</delay>
					Or you may use a thread safe variant of ArrayList - CopyOnWriteArrayList.
					<delay>2</delay>
					Hope it will help.
				</li>
				<li>
					You will not get an invalid state when changing arrays using multiple threads.
					<delay>2</delay>
					However if a certain thread has edited a value in the array, there is no 
					guarantee that another thread will see the changes.
					<delay>2</delay>
					Similar issues occur for non-volatile variables.
				</li>
				<li>
					Array operations are not threadsafe.
					<delay>2</delay>
					you can either lock on a field, i would recommend to add a field e.g. named 
					LOCK and do the
					void add(){<break/>
					 syncronized(LOCK) {<break/>
					  // add<break/>
					 }<break/>
					}<break/>
					void get(int i){<break/>
					 synchronized(LOCK){ <break/>
					   // return<break/>
					 }<break/>
					}<break/>
					or simply use
					java.util.concurrent.*<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ access ^ array thread safely ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ access ^ array ^ thread safe ^</pattern>
		<template><srai>^ access ^ array thread safely ^</srai></template>
  </category>
	<category>
		<pattern>^ thread safe ^ array access ^</pattern>
		<template><srai>^ access ^ array thread safely ^</srai></template>
  </category>
	<category>
		<pattern>^ accessing ^ array ^ thread safe ^</pattern>
		<template><srai>^ access ^ array thread safely ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 124. Printing elements from Nth index onward in an array -->
			^ printing elements ^ nth index onward ^
		</pattern>
		<template>
			<random>
				<li>
					If you are using Java-8, you can do this :
					Arrays.stream(array).skip(2).forEach(System.out::println);<break/>
					<delay>2</delay>
					There won't be any exceptions thrown even if you pass a value to skip that 
					is greater than the length of the array.
					<delay>2</delay>
					You will simply get no output in such a case.
					<delay>2</delay>
					If you are not using Java-8, I don't see any challenge.
					<delay>2</delay>
					Just loop through index 3 to n and print the elements.
					<delay>2</delay>
				</li>
				<li>
					check the following code snippet
					//its three because you want to display last three elements.Note it should be less than array length<break/>
					int pointer=3;<break/>
					int[] inputArray= {1,2,3,4,5};<break/>
					for(int i=inputArray.length-pointer;i&lt;inputArray.length;i++){<break/>
							System.out.println(inputArray[i]);<break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ printing elements ^ nth index onward ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ print elements ^ nth index onward ^</pattern>
		<template><srai>^ printing elements ^ nth index onward ^</srai></template>
  </category>
	<category>
		<pattern>^ printing items ^ nth index onward ^</pattern>
		<template><srai>^ printing elements ^ nth index onward ^</srai></template>
  </category>
	<category>
		<pattern>^ print items ^ nth index onward ^</pattern>
		<template><srai>^ printing elements ^ nth index onward ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 125. How to add an Object into a certain x,y position in a 2D array of Objects -->
			^ add ^ object ^ specific ^ position ^ 2d array ^ 
		</pattern>
		<template>
			<random>
				<li>
					Try using array[row][col] = object<break/>
					Hope this helps!
				</li>
				<li>
				import java.util.*;<break/>
					class a_class{<break/>
					    private int i;<break/>
					    public a_class(int k){<break/>
					        i=k;<break/>
					    }<break/>
					    public void print(){<break/>
					        System.out.print(i+"\t");<break/>
					    }<break/>
					}<break/>
					class Stack_help{<break/>
					    public static void main(String []args){<break/>
					        a_class [][]a=new a_class[4][4];//creating a new array of 2d objects<break/>
					        for(int i=0;i&lt;4;i++){<break/>
					            for(int j=0;j&lt;4;j++){<break/>
					                a[i][j] = new a_class(i);<break/>
					                a[i][j].print();<break/>
					            }<break/>
					            System.out.println("\n");<break/>
					        }<break/>
					    }<break/>
					}<break/>
					Probably what you are asking just run this code you will get your answer
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ add ^ object ^ specific ^ position ^ 2d array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ add ^ element ^ specific ^ position ^ 2d array ^</pattern>
		<template><srai>^ add ^ object ^ specific ^ position ^ 2d array ^</srai></template>
  </category>
	<category>
		<pattern>^ add ^ item ^ specific ^ position ^ 2d array ^</pattern>
		<template><srai>^ add ^ object ^ specific ^ position ^ 2d array ^</srai></template>
  </category>
	<category>
		<pattern>^ add ^ item ^ position ^ 2d array ^</pattern>
		<template><srai>^ add ^ object ^ specific ^ position ^ 2d array ^</srai></template>
  </category>
	<category>
		<pattern>^ add ^ object ^ position ^ 2d array ^</pattern>
		<template><srai>^ add ^ object ^ specific ^ position ^ 2d array ^</srai></template>
  </category>
	<category>
		<pattern>^ add ^ element ^ position ^ 2d array ^</pattern>
		<template><srai>^ add ^ object ^ specific ^ position ^ 2d array ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 126. Setting an array as an input parameter for a method -->
			^ array ^ input parameter ^ method ^
		</pattern>
		<template>
			<random>
				<li>
					This should work<break/>
					public class FirstJavaClass {<break/>
					    public void method(double[] input) {<break/>
					        // ... do something amazing with it!<break/>
					    }<break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ array ^ input parameter ^ method ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ array ^ input parameter ^ method ^</pattern>
		<template><srai>^ array ^ input parameter ^ method ^</srai></template>
  </category>
	<category>
		<pattern>^ method ^ input parameter ^ array ^</pattern>
		<template><srai>^ array ^ input parameter ^ method ^</srai></template>
  </category>
	<category>
		<pattern>^ method ^ array ^ input parameter ^^</pattern>
		<template><srai>^ array ^ input parameter ^ method ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 127. Is there a way to see if certain integers are in certain places within an arraylist? -->
			^ see ^ integer ^ given position ^ arraylist ^
		</pattern>
		<template>
			<random>
				<li>
					Just compare the order and the array with a for-loop:
					public boolean isArrayInOrder(int[] array, int... order) {<break/>
					    if(array.length == order.length) {<break/>
					        for(int i = 0; i &lt; array.length; ++i) {<break/>
					            if(array[i] != order[i]) return false;<break/>
					        }<break/>
					        return true;<break/>
					    }<break/>
					    return false;<break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ see ^ integer ^ given position ^ arraylist ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ see ^ integer ^ certain position ^ arraylist ^</pattern>
		<template><srai>^ see ^ integer ^ given position ^ arraylist ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 128. Why Array in Java always need to fixed size? -->
			^ array ^ are ^ fixed size ^ arraylist not ^
		</pattern>
		<template>
			<random>
				<li>
					An ArrayList is backed by an array, whose size is fixed, but the ArrayList 
					class contains code that creates a larger array and copies the existing 
					array to it when the existing array is full.
					<delay>2</delay>
					That's the difference between arrays and ArrayLists.
				</li>
				<li>
					There is big difference between array and lists:
					1) if we certainly know size of collection - this is array, we need no dynamicaly changing size.
					<delay>2</delay>
					2) if we don't know, how many elements will be in our collection - this is 
					list, where size is not fixed.
					<delay>2</delay>
					In this answer "collection" doesn't means Collection class in Java, it's 
					just a a bunch of some objects
				</li>
				<li>
					The main difference between Array and ArrayList in Java is that Array is 
					a fixed length data structure while ArrayList is a variable length.
					<delay>2</delay>
					You can not change length of Array once create, but ArrayList can re-size 
					itself.
					<delay>2</delay>
					Another difference between Array and ArrayList in Java, you can not store 
					primitives in ArrayList, because it can only contain Objects.
					<delay>2</delay>
					Array can contain both primitives and Objects.
					<delay>2</delay>
					The Array is not a class, while ArrayList is an object with many methods.
					<delay>2</delay>
					The elements of the Array retrieved with for loop.
					<delay>2</delay>
					The elements of the ArrayList can be retrieved with for loop and iterators.
					<delay>2</delay>
					The Array cannot be synchronized, while ArrayList can be obtained a synchronized ver.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ array ^ are ^ fixed size ^ arraylist not ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ arrays ^ are ^ fixed size ^ arraylist ^ not ^</pattern>
		<template><srai>^ array ^ are ^ fixed size ^ arraylist not ^</srai></template>
  </category>
	<category>
		<pattern>^ arrays ^ are ^ fixed size ^ arraylists ^ not ^</pattern>
		<template><srai>^ array ^ are ^ fixed size ^ arraylist not ^</srai></template>
  </category>
	<category>
		<pattern>^ arrays ^ have ^ fixed size ^ arraylist ^ not ^</pattern>
		<template><srai>^ array ^ are ^ fixed size ^ arraylist not ^</srai></template>
  </category>
	<category>
		<pattern>^ arrays ^ have ^ fixed size ^ arraylists ^ not ^</pattern>
		<template><srai>^ array ^ are ^ fixed size ^ arraylist not ^</srai></template>
  </category>
	<category>
		<pattern>^ arrays ^ are ^ fixed size ^ arraylist don't ^</pattern>
		<template><srai>^ array ^ are ^ fixed size ^ arraylist not ^</srai></template>
  </category>
	<category>
		<pattern>^ arrays ^ are ^ fixed size ^ arraylists don't ^</pattern>
		<template><srai>^ array ^ are ^ fixed size ^ arraylist not ^</srai></template>
  </category>
	<category>
		<pattern>^ arrays ^ have ^ fixed size ^ arraylist don't ^</pattern>
		<template><srai>^ array ^ are ^ fixed size ^ arraylist not ^</srai></template>
  </category>
	<category>
		<pattern>^ arrays ^ have ^ fixed size ^ arraylists don't ^</pattern>
		<template><srai>^ array ^ are ^ fixed size ^ arraylist not ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 129. How to create 2d Array containing 2d Arraylist? (JAVA) -->
			^ create 2d array containing 2d arraylists ^
		</pattern>
		<template>
			<random>
				<li>
					You should use:
					List&lt;List&lt;String&gt;&gt; example = new ArrayList&lt;List&lt;String&gt;&gt;();<break/>
					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ create 2d array containing 2d arraylists ^ java </postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>
			<!-- 130. How to declare and call a 2d array in java? -->
			^ declare ^ call ^ 2d array ^
		</pattern>
		<template>
			This should do<break/>
			// declaration<break/>
			int [][] arr = new int[height][width];<break/>
			<delay>2</delay>
			//call<break/>
			System.out.println(arr[0][0])
		</template>
	</category>
	<category>
		<pattern>
			<!-- 131. Can rows have different column count? -->
			^ rows ^ different column count ^
		</pattern>
		<template>
			<random>
				<li>
					Yes, that is possible, here is example of iterating through them
					public static void main(String[] args) {<break/>
						int[][] numbers = new int[][] { { 1, 2, 3 }, { 1, 2, 3, 4 }, { 1, 2, 3, 4, 5 } };<break/>
						for(int i = 0; i&lt;numbers.length;i++) {<break/>
								for(int j = 0; j &lt; numbers[i].length; j++) {<break/>
										System.out.print(numbers[i][j]);<break/>
								}<break/>
								System.out.println("");<break/>
						}<break/>
					}<break/>
					output:
					123<break/>1234<break/>12345<break/>
				</li>
				<li>
					Yes, you can have different column count for each row.
					<delay>2</delay>
					data_type [][] array = new data_type[row][]
					array[0] = new data_type[size1]
					array[1] = new data_type[size2]
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ rows ^ different column count ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ rows ^ different column size ^</pattern>
		<template><srai>^ rows ^ different column count ^</srai></template>
  </category>
	<category>
		<pattern>^ rows ^ different columns count ^</pattern>
		<template><srai>^ rows ^ different column count ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 132. How do I return true if ArrayList is empty? -->
			^ return true ^ arraylist ^ empty 
		</pattern>
		<template>
			<random>
			<li>
				There is already a method provided by java.
				<delay>2</delay>
				list.isEmpty();<break/>
			</li>
			<li>
				You can use the method provided by Java<break/>
				list.isEmpty()
			</li>
			<li>
				This Java method should do what you are asking<break/>
				list.isEmpty()
			</li>
			</random>
		</template>
	</category>
	<category>
		<pattern>
			<!-- 133. What is the base class for byte array -->
			^ base class ^ byte array 
		</pattern>
		<template>
			The answer is byte[].class.
			<delay>2</delay>
			Example:
			byte[] receivedMessage = consumer.receiveBody(byte[].class, 15000); // in ms or 15 seconds<break/>
		</template>
	</category>
	<category>
		<pattern>
			<!-- 134. to reverse the elements of an array -->
			^ reverse ^ elements ^ array 
		</pattern>
		<template>
			You can use Collections.reverse(a);<break/>
		</template>
	</category>
	<category>
		<pattern>
			<!-- 135. How do I see if an array index I'm accessing is out of range of the array? -->
			^ see ^ array index ^ out of range ^
		</pattern>
		<template>
			<random>
				<li>
					if you have array like this(int[] a = new in[10])
					<delay>2</delay>
					you can test it like 
					if(index &lt; a.length)<break/>
					or if you have <break/>
					ArrayList&lt;Integer&gt; b = new ArrayList&lt;Integer&gt;(); <break/>
					you can test it like<break/>
					if( index &lt; b.size())<break/>
				</li>
				<li>
					The correct boolean expression to check if an index is out of bounds for array array is:
					<delay>2</delay>
					index &lt; 0 || index &gt;= array.length<break/>
					<delay>2</delay>
					As in: <break/>
					if (index &lt; 0 || index &gt;= array.length) {<break/>
					    System.out.println("Index is out of bounds");<break/>
					}<break/>
				</li>
				<li>
					Use array.length to find the length of the array and then compare your index 
					with array.length (it should be less than length of array and greater or 
					equal to 0).
					<delay>2</delay>
					As the index surpasses length java gives you exception(ArrayIndexOutOfBounds Exception).
				</li>
				<li>
					You can always check if the index you are trying to use can be accessed by 
					doing this:
					if(index &gt;= 0 and index &lt;= array.length1)<break/>
					//This checks to see if the index you are going to use is greater or equal 
					to 0 (since you cant access a negative index) and make sure it is less than 
					the maximum size of the whole array)
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ see ^ array index ^ out of range ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ control ^ array index ^ out of range ^</pattern>
		<template><srai>^ see ^ array index ^ out of range ^</srai></template>
  </category>
	<category>
		<pattern>^ test ^ array index ^ out of range ^</pattern>
		<template><srai>^ see ^ array index ^ out of range ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 136. How to remove duplicated elements in a List? -->
			^ remove duplicated ^ list ^
		</pattern>
		<template>
			<random>
				<li>
					You could have googled once before you posted your question here
					<delay>2</delay>
					, anyway check this link out.
					<delay>2</delay>
					A part of an array cannot be deleted.
					<delay>2</delay>
					You have two options, either you can shift elements to the left or create 
					a new array without the duplicate elements and delete the old array.
					<delay>2</delay>
					This might solve your query.
				</li>
				<li>
					If you want to have only unique records you can use HashSet, however as you 
					mentioned you want to remove all elements which are duplicates, you can 
					use this simplest piece of code to do it, what you will need to do is create 
					a new list which will only contain uniques and remove duplicates..take a look<break/>
					List cleanList = new ArrayList&lt;Integer&gt;();<break/>
					for(int n=0;n&lt;list.size();n++){<break/>
					  if(!cleanList.contains(list.get(n))){<break/>
					    cleanList.add(list.get(n));<break/>
					  }else{<break/>
					    cleanList.remove(list.get(n));<break/>
					  }<break/>
					}<break/>
					<delay>2</delay>
					The result in cleanList will be 3, 5.
					<delay>2</delay>
					See if you can use this or get ideas from the above script
					<delay>2</delay>
				</li>
				<li>
					May this can help you:
					import java.util.ArrayList;<break/>
					import java.util.Arrays;<break/>
					public class RemoveDuplicateElement {<break/>
					    public static void main(String[] args) {<break/>
					        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(1,2,1,3,5));<break/>
					        ArrayList&lt;Integer&gt; duplicateElementsRemovedList = new ArrayList&lt;Integer&gt;();<break/>
					        for (Integer elementToSearch :list) {<break/>
					            int found=0;<break/>
					            for (Integer element :list) {<break/>
					                if(elementToSearch.equals(element)) {<break/>
					                    found++;<break/>
					                }<break/>
					            }<break/>
					            if(found==1)<break/>
					            {<break/>
					                duplicateElementsRemovedList.add(elementToSearch);<break/>
					            }<break/>
					        }<break/>
					        for (Integer element :duplicateElementsRemovedList) {<break/>
					            System.out.println(element);<break/>
					        }<break/>
					    }<break/>
					}<break/>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ remove duplicated ^ list ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ delete duplicated ^ list ^</pattern>
		<template><srai>^ remove duplicated ^ list ^</srai></template>
  </category>
	<category>
		<pattern>^ list ^ remove duplicated ^</pattern>
		<template><srai>^ remove duplicated elements ^ list ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 137. JAVA 8 : How to initialize List Of List in one line -->
			^ initialize list of lists ^ 
		</pattern>
		<template>
			<random>
				<li>
					This should work fine<break/>
					List&lt;List&lt;Integer&gt;&gt; list = <break/>
					Arrays.asList(Arrays.asList(1,2,3), Arrays.asList(4,5,6));<break/>
				</li>
				<li>
					Try this code<break/>
					List&lt;List&lt;Integer&gt;&gt; list = Arrays.asList(Arrays.asList(1,2), Arrays.asList(3,4));<break/>
					<delay>2</delay>
					In Java 9+ you can replace Arrays.asList() with List.of().
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ initialize list of lists ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ build list of lists ^</pattern>
		<template><srai>^ initialize list of lists ^</srai></template>
  </category>
	<category>
		<pattern>^ create list of lists ^</pattern>
		<template><srai>^ initialize list of lists ^</srai></template>
  </category>
	<category>
		<pattern>^ initialize list of list ^</pattern>
		<template><srai>^ initialize list of lists ^</srai></template>
  </category>
	<category>
		<pattern>
			<!-- 138. How to write 2d arraylists in java? -->
			^ write 2d arraylists ^
		</pattern>
		<template>
			<random>
				<li>
					SomeObject[] is array and SomeObject[][] is 2D array.
					<delay>2</delay>
					Below you can see example integer 2D array.
					<delay>2</delay>
					int[][] array2d = new int[][] {<break/>
					  {1,2,3},<break/>
					  {4,5,6},<break/>
					  {7,8,9}<break/>
					};<break/>
					array2d[1][1] == 5; // this is true<break/>
					<delay>2</delay>
					There are no 2D ArrayLists, you can fake it by making normal array of ArrayLists 
					or ArrayList containing multiple ArrayLists.
					<delay>2</delay>
					// Array of ArrayLists<break/>
					ArrayList[] arr = new ArrayList[arraysize];<break/>
					// ArrayList containing another ArrayList<break/>
					ArrayList a = new ArrayList();<break/>
					ArrayList b = new ArrayList();<break/>
					a.add(b);<break/>
				</li>
				<li>
					2D arrays in Java are essentially arrays consisting of arrays.
					<delay>2</delay>
					Each element in the array is itself an array. 
					<delay>2</delay>
					int[][] arr = {<break/>
					    new int[] = { 1, 2, 3 },<break/>
					    new int[] = { 4, 5, 6 },<break/>
					    new int[] = { 7, 8, 9 }<break/>
					}<break/>
					<delay>2</delay>
					The same can be created with ArrayLists. 
					<delay>2</delay>
					ArrayList arrList = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();<break/>
					arrList.add(new ArrayList&lt;Integer&gt;(Arrays.asList(1, 2, 3)));<break/>
					arrList.add(new ArrayList&lt;Integer&gt;(Arrays.asList(4, 5, 6)));<break/>
					arrList.add(new ArrayList&lt;Integer&gt;(Arrays.asList(7, 8, 9)));<break/>
					<delay>2</delay>
					The data type of the parent ArrayList is &lt;ArrayList&lt;Integer&gt;&gt;.
					<delay>2</delay>
					Each element in the parent arrList is itself of type ArrayList which contains 
					Integers.
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ write 2d arraylists ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ write 2d arraylists ^</pattern>
		<template><srai>^ write 2d arraylists ^</srai></template>
  </category>
	<category>
		<pattern>^ build 2d arraylists ^</pattern>
		<template><srai></srai></template>
  </category>
	<category>
		<pattern>^ build two dimensional arraylists ^</pattern>
		<template><srai></srai></template>
  </category>
	<category>
		<pattern>
			<!-- 139. Why can't we directly print Arrays in java? -->
			^ directly print arrays ^
		</pattern>
		<template>
					Because in Java, arrays are treated like Objects and not as a primitive type.
					<delay>2</delay>
					By default, when printing any object, the object's toString() method is called.
					<delay>2</delay>
					Arrays do not override the default toString method and such do not provide 
					useful information about the contents of the array, so you should call Arrays
					.toString() instead. 
		</template>
	</category>
	<category>
		<pattern>
			<!-- 140. Storing multiple objects in a single array element in Java -->
			^ multiple objects ^ single array element ^
		</pattern>
		<template>
			<random>
				<li>
					No.
					<delay>2</delay>
					Any given element of an array is just that, one element.
					<delay>2</delay>
					The type of element does matter, though.
					<delay>2</delay>
					Consider an array of integers:
					<delay>2</delay>
					int[] x = {1, 4, 7, 10};<break/>
					<delay>2</delay>
					One element cannot 'hold' multiple elements.
					<delay>2</delay>
					But now consider an array of arrays of integers:
					<delay>2</delay>
					int[][] x = {<break/>
					    {1},<break/>
					    {2, 3},<break/>
					    {4, 5, 6},<break/>
					    {7, 8, 9, 10}<break/>
					};<break/>
					<delay>2</delay>
					Each element is still just a single element.
					<delay>2</delay>
					There are four elements each of type int[].
					<delay>2</delay>
					Then, each of those has one element per element.
					<delay>2</delay>
					You can theoretically have as many layers of this as you want.
					<delay>2</delay>
					It can get confusing very quickly.
					<delay>2</delay>
					Another way to fit 'multiple elements into one element' would be to write 
					your own class that holds multiple elements in whatever way is most useful 
					to you, and make an array of those.
					<delay>2</delay>
					Note: above, I've used primitive arrays to demonstrate.
					<delay>2</delay>
					However, this also works with Java List objects:
					ArrayList&lt;Integer&gt; x;  // list of integers<break/>
					ArrayList&lt;ArrayList&lt;Integer&gt;&gt; x;  // list of ArrayList&lt;Integer&gt; objects, each of which is itself a list of integers<break/>
					ArrayList&lt;Integer&gt;[] x;  // primitive array of ArrayList&lt;Integer&gt; objects<break/>
					// (I recommend not doing this, it can get confusing)<break/>
					If your question is about putting multiple types of objects in a single element
					, then you have to figure out what superclass encompasses both types (usually 
					Object, if the types are remotely different), and make your list that type:
					<delay>2</delay>
					Object[] x = {Integer.valueOf(5), Double.valueOf(3.14), &quot;some_string&quot;};<break/>
					Getting those objects back out again and putting them into their correct 
					type, is difficult, so I don't recommend this.
					<delay>2</delay>
					You can also try building your own Union type, and making the list be that type.
				</li>
				<li>
					You can store anything in an Object[] object array.
					<delay>2</delay>
					Something like this:<break/>
					Object[] objArr = new Object[10];<break/>
					objArr[0] = &quot;String&quot;;<break/>
					objArr[1] = Arrays.asList(1, 2, 4);<break/>
					objArr[2] = new ArrayList&lt;&gt;(); <break/>
					objArr[3] = 1;<break/>
					<delay>2</delay>
				</li>
			</random>
			<delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ multiple objects ^ single array element ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
		</template>
	</category>
	<category>
		<pattern>^ multiple objects ^ single array element ^</pattern>
		<template>^ multiple objects ^ single array element ^<srai></srai></template>
  </category>
	<category>
		<pattern>^ multiple objects ^ same array element ^</pattern>
		<template><srai>^ multiple objects ^ single array element ^</srai></template>
  </category>
	<category>
		<pattern>^ multiple objects ^ single array item ^</pattern>
		<template><srai>^ multiple objects ^ single array element ^</srai></template>
  </category>
	<category>
      <pattern>
			<!-- 141 how to create an array -->
			^ create ^ array ^</pattern>
      <template>
          <random>
              <li>
                  In java you can create arrays in the following way:<break/>
                // both are valid declarations
                int intArray[]; <break/> 
                or<break/>
                int[] intArray;<break/> 
                <delay>2</delay>
                You can create many types of arrays like so:<break/>
                byte byteArray[];<break/>
                short shortsArray[];<break/>
                boolean booleanArray[];<break/>
                long longArray[];<break/>
                float floatArray[];<break/>
                double doubleArray[];<break/>
                char charArray[];<break/>
                <delay>2</delay>
                Moreover <break/>
                // an array of references to objects of
                // the class MyClass (a class created by<break/>
                // user)<break/>
                MyClass myClassArray[]; <break/>
                
                Object[]  ao,        // array of Object<break/>
                Collection[] ca;  // array of Collectio of unknown type
              </li>
              <li>
                  You can either use array declaration or array literal <break/>
                  (but only when you declare and affect the variable right away, array literals cannot be used for re-assigning an array).
                  <delay>2</delay>
                  For primitive types:<break/>
                  int[] myIntArray = new int[3];<break/>
                int[] myIntArray = {1, 2, 3};<break/>
                int[] myIntArray = new int[]{1, 2, 3};<break/>
                <delay>2</delay>
                // Since Java 8. Doc of IntStream<break/>
                int [] myIntArray = IntStream.range(0, 100).toArray(); // From 0 to 99<break/>
                int [] myIntArray = IntStream.rangeClosed(0, 100).toArray(); // From 0 to 100<break/>
                int [] myIntArray = IntStream.of(12,25,36,85,28,96,47).toArray(); // The order is preserved.<break/>
                int [] myIntArray = IntStream.of(12,25,36,85,28,96,47).sorted().toArray(); // Sort <break/>
              </li>
          </random>
          <delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ create ^ array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
      </template>
  </category>
  <category>
		<pattern>^ build ^ array ^</pattern>
		<template>^ create ^ array ^<srai></srai></template>
  </category>
	<category>
		<pattern>^ create ^ arrays ^</pattern>
		<template><srai>^ create ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ declare ^ array ^</pattern>
		<template><srai>^ create ^ array ^</srai></template>
  </category>
  <category>
		<pattern>^ build ^ arrays ^</pattern>
		<template>^ create ^ array ^<srai></srai></template>
  </category>
	<category>
		<pattern>^ arrays ^ creation ^</pattern>
		<template><srai>^ create ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ delcare ^ arrays ^</pattern>
		<template><srai>^ create ^ array ^</srai></template>
  </category>
	<category>
      <pattern>
				<!-- 142 how to fill an array -->
				^ fill ^ array ^
			</pattern>
      <template>
          <random>
              <li>
                  You can insert elements in the array in the followin way:<break/>
									int [] array = [10];<break/>
									array[0] = value1;<break/>
									array[1] = value2;<break/>
									...<break/>
									and so on<break/>
              </li>
              <li>
                  Take a look at the following code<break/>
									Object [] arrayOfObjects = [10];<break/>
									arrayOfObjects[0] = newValue;<break/>
									arrayOfObjects[1] = newValue;<break/>
									arrayOfObjects[2] = newValue;<break/>
									arrayOfObjects[3] = newValue;<break/>
									<delay>2</delay>
									Hope this help.
              </li>
          </random>
          <delay>2</delay>
			<random>
				<li>What do you say, did you understand the answer? Do you want me to give you another one?</li>
				<li>If it isn't clear I could provide  you another answer? Do you want it?</li>
				<li>I could try and give you another answer if you didn't understand. Would you kike that?</li>
				<li>If you didn't understood I could provide you anoter answer. Do you want it?</li>
			</random>
			<reply>
				<text>Yes</text>
				<postback>^ fill ^ array ^</postback>
			</reply>
			<reply>
				<text>No</text>
				<postback>GOODANSWER</postback>
			</reply>
      </template>
  </category>
  <category>
		<pattern>^ insert ^ array ^</pattern>
		<template>^ fill ^ array ^<srai></srai></template>
  </category>
	<category>
		<pattern>^ fill ^ arrays ^</pattern>
		<template><srai>^ fill ^ array ^</srai></template>
  </category>
	<category>
		<pattern>^ insert ^ arrays ^</pattern>
		<template><srai>^ fill ^ array ^</srai></template>
  </category>
</aiml>